// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product_serial.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProductSerials = `-- name: CountProductSerials :one
SELECT COUNT(serial_id)
FROM product.serial
WHERE (
        (serial_id ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
        (product_id = $2 OR $2 IS NULL) AND
        (is_sold = $3 OR $3 IS NULL) AND
        (is_active = $4 OR $4 IS NULL) AND
        (date_created >= $5 OR $5 IS NULL) AND
        (date_created <= $6 OR $6 IS NULL)
        )
`

type CountProductSerialsParams struct {
	SerialID        pgtype.Text        `json:"serial_id"`
	ProductID       pgtype.Int8        `json:"product_id"`
	IsSold          pgtype.Bool        `json:"is_sold"`
	IsActive        pgtype.Bool        `json:"is_active"`
	DateCreatedFrom pgtype.Timestamptz `json:"date_created_from"`
	DateCreatedTo   pgtype.Timestamptz `json:"date_created_to"`
}

func (q *Queries) CountProductSerials(ctx context.Context, arg CountProductSerialsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductSerials,
		arg.SerialID,
		arg.ProductID,
		arg.IsSold,
		arg.IsActive,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductSerial = `-- name: CreateProductSerial :one
INSERT INTO product.serial (serial_id,
                            product_id,
                            is_sold,
                            is_active)
VALUES ($1, $2, $3, $4) RETURNING serial_id, product_id, is_sold, is_active, date_created
`

type CreateProductSerialParams struct {
	SerialID  string `json:"serial_id"`
	ProductID int64  `json:"product_id"`
	IsSold    bool   `json:"is_sold"`
	IsActive  bool   `json:"is_active"`
}

func (q *Queries) CreateProductSerial(ctx context.Context, arg CreateProductSerialParams) (ProductSerial, error) {
	row := q.db.QueryRow(ctx, createProductSerial,
		arg.SerialID,
		arg.ProductID,
		arg.IsSold,
		arg.IsActive,
	)
	var i ProductSerial
	err := row.Scan(
		&i.SerialID,
		&i.ProductID,
		&i.IsSold,
		&i.IsActive,
		&i.DateCreated,
	)
	return i, err
}

const deleteProductSerial = `-- name: DeleteProductSerial :exec
DELETE
FROM product.serial
WHERE serial_id = $1
`

func (q *Queries) DeleteProductSerial(ctx context.Context, serialID string) error {
	_, err := q.db.Exec(ctx, deleteProductSerial, serialID)
	return err
}

const getAvailableProducts = `-- name: GetAvailableProducts :many
SELECT serial_id, product_id, is_sold, is_active, date_created
FROM product.serial
WHERE (
        product_id = $1 AND
        is_sold = false AND
        is_active = true
        ) LIMIT $2
`

type GetAvailableProductsParams struct {
	ProductID int64 `json:"product_id"`
	Amount    int32 `json:"amount"`
}

func (q *Queries) GetAvailableProducts(ctx context.Context, arg GetAvailableProductsParams) ([]ProductSerial, error) {
	rows, err := q.db.Query(ctx, getAvailableProducts, arg.ProductID, arg.Amount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductSerial{}
	for rows.Next() {
		var i ProductSerial
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductID,
			&i.IsSold,
			&i.IsActive,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSerial = `-- name: GetProductSerial :one
SELECT serial_id, product_id, is_sold, is_active, date_created
FROM product.serial
WHERE serial_id = $1
`

func (q *Queries) GetProductSerial(ctx context.Context, serialID string) (ProductSerial, error) {
	row := q.db.QueryRow(ctx, getProductSerial, serialID)
	var i ProductSerial
	err := row.Scan(
		&i.SerialID,
		&i.ProductID,
		&i.IsSold,
		&i.IsActive,
		&i.DateCreated,
	)
	return i, err
}

const listProductSerials = `-- name: ListProductSerials :many
SELECT serial_id, product_id, is_sold, is_active, date_created
FROM product.serial
WHERE (
        (serial_id ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
        (product_id = $2 OR $2 IS NULL) AND
        (is_sold = $3 OR $3 IS NULL) AND
        (is_active = $4 OR $4 IS NULL) AND
        (date_created >= $5 OR $5 IS NULL) AND
        (date_created <= $6 OR $6 IS NULL)
        )
ORDER BY date_created DESC LIMIT $8
OFFSET $7
`

type ListProductSerialsParams struct {
	SerialID        pgtype.Text        `json:"serial_id"`
	ProductID       pgtype.Int8        `json:"product_id"`
	IsSold          pgtype.Bool        `json:"is_sold"`
	IsActive        pgtype.Bool        `json:"is_active"`
	DateCreatedFrom pgtype.Timestamptz `json:"date_created_from"`
	DateCreatedTo   pgtype.Timestamptz `json:"date_created_to"`
	Offset          int32              `json:"offset"`
	Limit           int32              `json:"limit"`
}

func (q *Queries) ListProductSerials(ctx context.Context, arg ListProductSerialsParams) ([]ProductSerial, error) {
	rows, err := q.db.Query(ctx, listProductSerials,
		arg.SerialID,
		arg.ProductID,
		arg.IsSold,
		arg.IsActive,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductSerial{}
	for rows.Next() {
		var i ProductSerial
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductID,
			&i.IsSold,
			&i.IsActive,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markProductSerialsAsSold = `-- name: MarkProductSerialsAsSold :exec
UPDATE product.serial
SET is_sold = true
WHERE serial_id = ANY ($1::text[])
`

func (q *Queries) MarkProductSerialsAsSold(ctx context.Context, serialIds []string) error {
	_, err := q.db.Exec(ctx, markProductSerialsAsSold, serialIds)
	return err
}

const updateProductSerial = `-- name: UpdateProductSerial :exec
UPDATE product.serial
SET is_sold   = COALESCE($2, is_sold),
    is_active = COALESCE($3, is_active)
WHERE serial_id = $1
`

type UpdateProductSerialParams struct {
	SerialID string      `json:"serial_id"`
	IsSold   pgtype.Bool `json:"is_sold"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateProductSerial(ctx context.Context, arg UpdateProductSerialParams) error {
	_, err := q.db.Exec(ctx, updateProductSerial, arg.SerialID, arg.IsSold, arg.IsActive)
	return err
}
