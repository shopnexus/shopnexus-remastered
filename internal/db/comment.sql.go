// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: comment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countComments = `-- name: CountComments :one
SELECT COUNT(id)
FROM product.comment
WHERE (account_id = $1 OR $1 IS NULL)
  AND (type = $2 OR $2 IS NULL)
  AND (dest_id = $3 OR $3 IS NULL)
  AND (body ILIKE '%' || $4 || '%' OR $4 IS NULL)
  AND (upvote >= $5 OR $5 IS NULL)
  AND (upvote <= $6 OR $6 IS NULL)
  AND (downvote >= $7 OR $7 IS NULL)
  AND (downvote <= $8 OR $8 IS NULL)
  AND (score >= $9 OR $9 IS NULL)
  AND (score <= $10 OR $10 IS NULL)
  AND (date_created >= $11 OR $11 IS NULL)
  AND (date_created <= $12 OR $12 IS NULL)
`

type CountCommentsParams struct {
	AccountID     pgtype.Int8            `json:"account_id"`
	Type          NullProductCommentType `json:"type"`
	DestID        pgtype.Int8            `json:"dest_id"`
	Body          pgtype.Text            `json:"body"`
	UpvoteFrom    pgtype.Int8            `json:"upvote_from"`
	UpvoteTo      pgtype.Int8            `json:"upvote_to"`
	DownvoteFrom  pgtype.Int8            `json:"downvote_from"`
	DownvoteTo    pgtype.Int8            `json:"downvote_to"`
	ScoreFrom     pgtype.Int4            `json:"score_from"`
	ScoreTo       pgtype.Int4            `json:"score_to"`
	CreatedAtFrom pgtype.Timestamptz     `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz     `json:"created_at_to"`
}

func (q *Queries) CountComments(ctx context.Context, arg CountCommentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countComments,
		arg.AccountID,
		arg.Type,
		arg.DestID,
		arg.Body,
		arg.UpvoteFrom,
		arg.UpvoteTo,
		arg.DownvoteFrom,
		arg.DownvoteTo,
		arg.ScoreFrom,
		arg.ScoreTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO product.comment (account_id, type, dest_id, body, upvote, downvote, score)
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, type, account_id, dest_id, body, upvote, downvote, score, date_created, date_updated
`

type CreateCommentParams struct {
	AccountID int64              `json:"account_id"`
	Type      ProductCommentType `json:"type"`
	DestID    int64              `json:"dest_id"`
	Body      string             `json:"body"`
	Upvote    int64              `json:"upvote"`
	Downvote  int64              `json:"downvote"`
	Score     int32              `json:"score"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (ProductComment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.AccountID,
		arg.Type,
		arg.DestID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
	)
	var i ProductComment
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AccountID,
		&i.DestID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM product.comment
WHERE (
        id = $1
          AND (account_id = $2 OR $2 IS NULL)
        )
`

type DeleteCommentParams struct {
	ID        int64       `json:"id"`
	AccountID pgtype.Int8 `json:"account_id"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.AccountID)
	return err
}

const getComment = `-- name: GetComment :one
WITH filtered_comment AS (SELECT c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated
                          FROM product.comment c
                          WHERE c.id = $1),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id = $1
                              AND res.type = 'COMMENT'
                            GROUP BY res.owner_id)
SELECT c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_comment c
       LEFT JOIN filtered_resources res ON res.owner_id = c.id
`

type GetCommentRow struct {
	ID          int64              `json:"id"`
	Type        ProductCommentType `json:"type"`
	AccountID   int64              `json:"account_id"`
	DestID      int64              `json:"dest_id"`
	Body        string             `json:"body"`
	Upvote      int64              `json:"upvote"`
	Downvote    int64              `json:"downvote"`
	Score       int32              `json:"score"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Resources   []string           `json:"resources"`
}

func (q *Queries) GetComment(ctx context.Context, id int64) (GetCommentRow, error) {
	row := q.db.QueryRow(ctx, getComment, id)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AccountID,
		&i.DestID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
		&i.Resources,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
WITH filtered_comment AS (SELECT c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated
                          FROM product.comment c
                          WHERE (c.account_id = $3 OR $3 IS NULL)
                            AND (c.type = $4 OR $4 IS NULL)
                            AND (c.dest_id = $5 OR $5 IS NULL)
                            AND (c.body ILIKE '%' || $6 || '%' OR $6 IS NULL)
                            AND (c.upvote >= $7 OR $7 IS NULL)
                            AND (c.upvote <= $8 OR $8 IS NULL)
                            AND (c.downvote >= $9 OR $9 IS NULL)
                            AND (c.downvote <= $10 OR $10 IS NULL)
                            AND (c.score >= $11 OR $11 IS NULL)
                            AND (c.score <= $12 OR $12 IS NULL)
                            AND (c.date_created >= $13 OR $13 IS NULL)
                            AND (c.date_created <= $14 OR $14 IS NULL)),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id IN (SELECT id FROM filtered_comment)
                              AND res.type = 'COMMENT'
                            GROUP BY res.owner_id)
SELECT c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_comment c
       LEFT JOIN filtered_resources res ON res.owner_id = c.id
ORDER BY c.date_created DESC LIMIT $2
OFFSET $1
`

type ListCommentsParams struct {
	Offset        int32                  `json:"offset"`
	Limit         int32                  `json:"limit"`
	AccountID     pgtype.Int8            `json:"account_id"`
	Type          NullProductCommentType `json:"type"`
	DestID        pgtype.Int8            `json:"dest_id"`
	Body          pgtype.Text            `json:"body"`
	UpvoteFrom    pgtype.Int8            `json:"upvote_from"`
	UpvoteTo      pgtype.Int8            `json:"upvote_to"`
	DownvoteFrom  pgtype.Int8            `json:"downvote_from"`
	DownvoteTo    pgtype.Int8            `json:"downvote_to"`
	ScoreFrom     pgtype.Int4            `json:"score_from"`
	ScoreTo       pgtype.Int4            `json:"score_to"`
	CreatedAtFrom pgtype.Timestamptz     `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz     `json:"created_at_to"`
}

type ListCommentsRow struct {
	ID          int64              `json:"id"`
	Type        ProductCommentType `json:"type"`
	AccountID   int64              `json:"account_id"`
	DestID      int64              `json:"dest_id"`
	Body        string             `json:"body"`
	Upvote      int64              `json:"upvote"`
	Downvote    int64              `json:"downvote"`
	Score       int32              `json:"score"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Resources   []string           `json:"resources"`
}

func (q *Queries) ListComments(ctx context.Context, arg ListCommentsParams) ([]ListCommentsRow, error) {
	rows, err := q.db.Query(ctx, listComments,
		arg.Offset,
		arg.Limit,
		arg.AccountID,
		arg.Type,
		arg.DestID,
		arg.Body,
		arg.UpvoteFrom,
		arg.UpvoteTo,
		arg.DownvoteFrom,
		arg.DownvoteTo,
		arg.ScoreFrom,
		arg.ScoreTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentsRow{}
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.AccountID,
			&i.DestID,
			&i.Body,
			&i.Upvote,
			&i.Downvote,
			&i.Score,
			&i.DateCreated,
			&i.DateUpdated,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :one
UPDATE product.comment
SET body     = COALESCE($2, body),
    upvote   = COALESCE($3, upvote),
    downvote = COALESCE($4, downvote),
    score    = COALESCE($5, score)
WHERE id = $1
  AND (account_id = $6 OR $6 IS NULL) RETURNING id, type, account_id, dest_id, body, upvote, downvote, score, date_created, date_updated
`

type UpdateCommentParams struct {
	ID        int64       `json:"id"`
	Body      pgtype.Text `json:"body"`
	Upvote    pgtype.Int8 `json:"upvote"`
	Downvote  pgtype.Int8 `json:"downvote"`
	Score     pgtype.Int4 `json:"score"`
	AccountID pgtype.Int8 `json:"account_id"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (ProductComment, error) {
	row := q.db.QueryRow(ctx, updateComment,
		arg.ID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.AccountID,
	)
	var i ProductComment
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AccountID,
		&i.DestID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}
