// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: brand.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBrands = `-- name: CountBrands :one
WITH filtered_brands AS (SELECT b.id
                         FROM product.brand b
                         WHERE (
                                 (name ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
                                 (description ILIKE '%' || $2 || '%' OR $2 IS NULL)
                                 ))
SELECT COUNT(id)
FROM filtered_brands
`

type CountBrandsParams struct {
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CountBrands(ctx context.Context, arg CountBrandsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBrands, arg.Name, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrand = `-- name: CreateBrand :one
INSERT INTO product.brand (name, description)
VALUES ($1, $2) RETURNING id, name, description
`

type CreateBrandParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (ProductBrand, error) {
	row := q.db.QueryRow(ctx, createBrand, arg.Name, arg.Description)
	var i ProductBrand
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE
FROM product.brand
WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBrand, id)
	return err
}

const getBrand = `-- name: GetBrand :one
WITH filtered_brand AS (SELECT b.id, b.name, b.description
                        FROM product.brand b
                        WHERE b.id = $1),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id = $1
                              AND res.type = 'BRAND'
                            GROUP BY res.owner_id)
SELECT b.id, b.name, b.description,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_brand b
       LEFT JOIN filtered_resources res ON res.owner_id = b.id
`

type GetBrandRow struct {
	ID          int64    `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Resources   []string `json:"resources"`
}

func (q *Queries) GetBrand(ctx context.Context, id int64) (GetBrandRow, error) {
	row := q.db.QueryRow(ctx, getBrand, id)
	var i GetBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Resources,
	)
	return i, err
}

const listBrands = `-- name: ListBrands :many
WITH filtered_brands AS (SELECT b.id, b.name, b.description
                         FROM product.brand b
                         WHERE (
                                 (name ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
                                 (description ILIKE '%' || $4 || '%' OR $4 IS NULL)
                                 )),
     filtered_resources AS (SELECT res.owner_id, array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id IN (SELECT id FROM filtered_brands)
                              AND res.type = 'BRAND'
                            GROUP BY res.owner_id)
SELECT b.id, b.name, b.description,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_brands b
       LEFT JOIN filtered_resources res ON res.owner_id = b.id
ORDER BY b.name DESC LIMIT $2
OFFSET $1
`

type ListBrandsParams struct {
	Offset      int32       `json:"offset"`
	Limit       int32       `json:"limit"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

type ListBrandsRow struct {
	ID          int64    `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Resources   []string `json:"resources"`
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]ListBrandsRow, error) {
	rows, err := q.db.Query(ctx, listBrands,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.Description,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBrandsRow{}
	for rows.Next() {
		var i ListBrandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :exec
UPDATE product.brand
SET name        = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
`

type UpdateBrandParams struct {
	ID          int64       `json:"id"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) error {
	_, err := q.db.Exec(ctx, updateBrand, arg.ID, arg.Name, arg.Description)
	return err
}
