// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AccountAccountType string

const (
	AccountAccountTypeACCOUNTTYPEUSER  AccountAccountType = "ACCOUNT_TYPE_USER"
	AccountAccountTypeACCOUNTTYPEADMIN AccountAccountType = "ACCOUNT_TYPE_ADMIN"
)

func (e *AccountAccountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountAccountType(s)
	case string:
		*e = AccountAccountType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountAccountType: %T", src)
	}
	return nil
}

type NullAccountAccountType struct {
	AccountAccountType AccountAccountType `json:"account_account_type"`
	Valid              bool               `json:"valid"` // Valid is true if AccountAccountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountAccountType) Scan(value interface{}) error {
	if value == nil {
		ns.AccountAccountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountAccountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountAccountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountAccountType), nil
}

func (e AccountAccountType) Valid() bool {
	switch e {
	case AccountAccountTypeACCOUNTTYPEUSER,
		AccountAccountTypeACCOUNTTYPEADMIN:
		return true
	}
	return false
}

func AllAccountAccountTypeValues() []AccountAccountType {
	return []AccountAccountType{
		AccountAccountTypeACCOUNTTYPEUSER,
		AccountAccountTypeACCOUNTTYPEADMIN,
	}
}

type AccountGender string

const (
	AccountGenderMALE   AccountGender = "MALE"
	AccountGenderFEMALE AccountGender = "FEMALE"
	AccountGenderOTHER  AccountGender = "OTHER"
)

func (e *AccountGender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountGender(s)
	case string:
		*e = AccountGender(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountGender: %T", src)
	}
	return nil
}

type NullAccountGender struct {
	AccountGender AccountGender `json:"account_gender"`
	Valid         bool          `json:"valid"` // Valid is true if AccountGender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountGender) Scan(value interface{}) error {
	if value == nil {
		ns.AccountGender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountGender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountGender), nil
}

func (e AccountGender) Valid() bool {
	switch e {
	case AccountGenderMALE,
		AccountGenderFEMALE,
		AccountGenderOTHER:
		return true
	}
	return false
}

func AllAccountGenderValues() []AccountGender {
	return []AccountGender{
		AccountGenderMALE,
		AccountGenderFEMALE,
		AccountGenderOTHER,
	}
}

type PaymentPaymentMethod string

const (
	PaymentPaymentMethodCASH  PaymentPaymentMethod = "CASH"
	PaymentPaymentMethodVNPAY PaymentPaymentMethod = "VNPAY"
	PaymentPaymentMethodMOMO  PaymentPaymentMethod = "MOMO"
)

func (e *PaymentPaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentPaymentMethod(s)
	case string:
		*e = PaymentPaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentPaymentMethod: %T", src)
	}
	return nil
}

type NullPaymentPaymentMethod struct {
	PaymentPaymentMethod PaymentPaymentMethod `json:"payment_payment_method"`
	Valid                bool                 `json:"valid"` // Valid is true if PaymentPaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentPaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentPaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentPaymentMethod), nil
}

func (e PaymentPaymentMethod) Valid() bool {
	switch e {
	case PaymentPaymentMethodCASH,
		PaymentPaymentMethodVNPAY,
		PaymentPaymentMethodMOMO:
		return true
	}
	return false
}

func AllPaymentPaymentMethodValues() []PaymentPaymentMethod {
	return []PaymentPaymentMethod{
		PaymentPaymentMethodCASH,
		PaymentPaymentMethodVNPAY,
		PaymentPaymentMethodMOMO,
	}
}

type PaymentRefundMethod string

const (
	PaymentRefundMethodPICKUP  PaymentRefundMethod = "PICK_UP"
	PaymentRefundMethodDROPOFF PaymentRefundMethod = "DROP_OFF"
)

func (e *PaymentRefundMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentRefundMethod(s)
	case string:
		*e = PaymentRefundMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentRefundMethod: %T", src)
	}
	return nil
}

type NullPaymentRefundMethod struct {
	PaymentRefundMethod PaymentRefundMethod `json:"payment_refund_method"`
	Valid               bool                `json:"valid"` // Valid is true if PaymentRefundMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentRefundMethod) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentRefundMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentRefundMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentRefundMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentRefundMethod), nil
}

func (e PaymentRefundMethod) Valid() bool {
	switch e {
	case PaymentRefundMethodPICKUP,
		PaymentRefundMethodDROPOFF:
		return true
	}
	return false
}

func AllPaymentRefundMethodValues() []PaymentRefundMethod {
	return []PaymentRefundMethod{
		PaymentRefundMethodPICKUP,
		PaymentRefundMethodDROPOFF,
	}
}

type PaymentStatus string

const (
	PaymentStatusPENDING  PaymentStatus = "PENDING"
	PaymentStatusSUCCESS  PaymentStatus = "SUCCESS"
	PaymentStatusCANCELED PaymentStatus = "CANCELED"
	PaymentStatusFAILED   PaymentStatus = "FAILED"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

func (e PaymentStatus) Valid() bool {
	switch e {
	case PaymentStatusPENDING,
		PaymentStatusSUCCESS,
		PaymentStatusCANCELED,
		PaymentStatusFAILED:
		return true
	}
	return false
}

func AllPaymentStatusValues() []PaymentStatus {
	return []PaymentStatus{
		PaymentStatusPENDING,
		PaymentStatusSUCCESS,
		PaymentStatusCANCELED,
		PaymentStatusFAILED,
	}
}

type ProductCommentType string

const (
	ProductCommentTypePRODUCTMODEL ProductCommentType = "PRODUCT_MODEL"
	ProductCommentTypeBRAND        ProductCommentType = "BRAND"
	ProductCommentTypeCOMMENT      ProductCommentType = "COMMENT"
)

func (e *ProductCommentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductCommentType(s)
	case string:
		*e = ProductCommentType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductCommentType: %T", src)
	}
	return nil
}

type NullProductCommentType struct {
	ProductCommentType ProductCommentType `json:"product_comment_type"`
	Valid              bool               `json:"valid"` // Valid is true if ProductCommentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductCommentType) Scan(value interface{}) error {
	if value == nil {
		ns.ProductCommentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductCommentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductCommentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductCommentType), nil
}

func (e ProductCommentType) Valid() bool {
	switch e {
	case ProductCommentTypePRODUCTMODEL,
		ProductCommentTypeBRAND,
		ProductCommentTypeCOMMENT:
		return true
	}
	return false
}

func AllProductCommentTypeValues() []ProductCommentType {
	return []ProductCommentType{
		ProductCommentTypePRODUCTMODEL,
		ProductCommentTypeBRAND,
		ProductCommentTypeCOMMENT,
	}
}

type ProductResourceType string

const (
	ProductResourceTypeBRAND        ProductResourceType = "BRAND"
	ProductResourceTypeCOMMENT      ProductResourceType = "COMMENT"
	ProductResourceTypePRODUCTMODEL ProductResourceType = "PRODUCT_MODEL"
	ProductResourceTypePRODUCT      ProductResourceType = "PRODUCT"
	ProductResourceTypeREFUND       ProductResourceType = "REFUND"
)

func (e *ProductResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductResourceType(s)
	case string:
		*e = ProductResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductResourceType: %T", src)
	}
	return nil
}

type NullProductResourceType struct {
	ProductResourceType ProductResourceType `json:"product_resource_type"`
	Valid               bool                `json:"valid"` // Valid is true if ProductResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ProductResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductResourceType), nil
}

func (e ProductResourceType) Valid() bool {
	switch e {
	case ProductResourceTypeBRAND,
		ProductResourceTypeCOMMENT,
		ProductResourceTypePRODUCTMODEL,
		ProductResourceTypePRODUCT,
		ProductResourceTypeREFUND:
		return true
	}
	return false
}

func AllProductResourceTypeValues() []ProductResourceType {
	return []ProductResourceType{
		ProductResourceTypeBRAND,
		ProductResourceTypeCOMMENT,
		ProductResourceTypePRODUCTMODEL,
		ProductResourceTypePRODUCT,
		ProductResourceTypeREFUND,
	}
}

type ProductSaleType string

const (
	ProductSaleTypeSALETYPETAG          ProductSaleType = "SALE_TYPE_TAG"
	ProductSaleTypeSALETYPEPRODUCTMODEL ProductSaleType = "SALE_TYPE_PRODUCT_MODEL"
	ProductSaleTypeSALETYPEBRAND        ProductSaleType = "SALE_TYPE_BRAND"
)

func (e *ProductSaleType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductSaleType(s)
	case string:
		*e = ProductSaleType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductSaleType: %T", src)
	}
	return nil
}

type NullProductSaleType struct {
	ProductSaleType ProductSaleType `json:"product_sale_type"`
	Valid           bool            `json:"valid"` // Valid is true if ProductSaleType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductSaleType) Scan(value interface{}) error {
	if value == nil {
		ns.ProductSaleType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductSaleType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductSaleType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductSaleType), nil
}

func (e ProductSaleType) Valid() bool {
	switch e {
	case ProductSaleTypeSALETYPETAG,
		ProductSaleTypeSALETYPEPRODUCTMODEL,
		ProductSaleTypeSALETYPEBRAND:
		return true
	}
	return false
}

func AllProductSaleTypeValues() []ProductSaleType {
	return []ProductSaleType{
		ProductSaleTypeSALETYPETAG,
		ProductSaleTypeSALETYPEPRODUCTMODEL,
		ProductSaleTypeSALETYPEBRAND,
	}
}

type AccountAddress struct {
	ID          int64              `json:"id"`
	UserID      int64              `json:"user_id"`
	FullName    string             `json:"full_name"`
	Phone       string             `json:"phone"`
	Address     string             `json:"address"`
	City        string             `json:"city"`
	Province    string             `json:"province"`
	Country     string             `json:"country"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

type AccountAdmin struct {
	ID           int64       `json:"id"`
	AvatarUrl    pgtype.Text `json:"avatar_url"`
	IsSuperAdmin bool        `json:"is_super_admin"`
}

type AccountBase struct {
	ID       int64              `json:"id"`
	Username string             `json:"username"`
	Password string             `json:"password"`
	Type     AccountAccountType `json:"type"`
}

type AccountCart struct {
	ID int64 `json:"id"`
}

type AccountItemOnCart struct {
	CartID      int64              `json:"cart_id"`
	ProductID   int64              `json:"product_id"`
	Quantity    int64              `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

type AccountPermission struct {
	ID          string      `json:"id"`
	Description pgtype.Text `json:"description"`
}

type AccountPermissionOnRole struct {
	RoleID       string `json:"role_id"`
	PermissionID string `json:"permission_id"`
}

type AccountRole struct {
	ID          string      `json:"id"`
	Description pgtype.Text `json:"description"`
}

type AccountRoleOnAdmin struct {
	AdminID int64  `json:"admin_id"`
	RoleID  string `json:"role_id"`
}

type AccountUser struct {
	ID               int64         `json:"id"`
	Email            string        `json:"email"`
	Phone            string        `json:"phone"`
	Gender           AccountGender `json:"gender"`
	FullName         string        `json:"full_name"`
	DefaultAddressID pgtype.Int8   `json:"default_address_id"`
	AvatarUrl        pgtype.Text   `json:"avatar_url"`
}

type PaymentBase struct {
	ID          int64                `json:"id"`
	UserID      int64                `json:"user_id"`
	Method      PaymentPaymentMethod `json:"method"`
	Status      PaymentStatus        `json:"status"`
	Address     string               `json:"address"`
	Total       int64                `json:"total"`
	DateCreated pgtype.Timestamptz   `json:"date_created"`
}

type PaymentProductOnPayment struct {
	ID         int64 `json:"id"`
	PaymentID  int64 `json:"payment_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
	Price      int64 `json:"price"`
	TotalPrice int64 `json:"total_price"`
}

type PaymentProductSerialOnProductOnPayment struct {
	ProductOnPaymentID int64  `json:"product_on_payment_id"`
	ProductSerialID    string `json:"product_serial_id"`
}

type PaymentRefund struct {
	ID                 int64               `json:"id"`
	ProductOnPaymentID int64               `json:"product_on_payment_id"`
	Method             PaymentRefundMethod `json:"method"`
	Status             PaymentStatus       `json:"status"`
	Reason             string              `json:"reason"`
	Address            string              `json:"address"`
	Amount             int64               `json:"amount"`
	ApprovedByID       pgtype.Int8         `json:"approved_by_id"`
	DateCreated        pgtype.Timestamptz  `json:"date_created"`
}

type PaymentVnpay struct {
	ID                   int64  `json:"id"`
	VnpAmount            string `json:"vnp_Amount"`
	VnpBankCode          string `json:"vnp_BankCode"`
	VnpCardType          string `json:"vnp_CardType"`
	VnpOrderInfo         string `json:"vnp_OrderInfo"`
	VnpPayDate           string `json:"vnp_PayDate"`
	VnpResponseCode      string `json:"vnp_ResponseCode"`
	VnpSecureHash        string `json:"vnp_SecureHash"`
	VnpTmnCode           string `json:"vnp_TmnCode"`
	VnpTransactionNo     string `json:"vnp_TransactionNo"`
	VnpTransactionStatus string `json:"vnp_TransactionStatus"`
	VnpTxnRef            string `json:"vnp_TxnRef"`
}

type ProductBase struct {
	ID              int64              `json:"id"`
	ProductModelID  int64              `json:"product_model_id"`
	AdditionalPrice int64              `json:"additional_price"`
	IsActive        bool               `json:"is_active"`
	CanCombine      bool               `json:"can_combine"`
	Metadata        []byte             `json:"metadata"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
}

type ProductBrand struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type ProductComment struct {
	ID          int64              `json:"id"`
	Type        ProductCommentType `json:"type"`
	AccountID   int64              `json:"account_id"`
	DestID      int64              `json:"dest_id"`
	Body        string             `json:"body"`
	Upvote      int64              `json:"upvote"`
	Downvote    int64              `json:"downvote"`
	Score       int32              `json:"score"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

type ProductModel struct {
	ID               int64              `json:"id"`
	Type             int64              `json:"type"`
	BrandID          int64              `json:"brand_id"`
	Name             string             `json:"name"`
	Description      string             `json:"description"`
	ListPrice        int64              `json:"list_price"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
}

type ProductResource struct {
	ID      int64               `json:"id"`
	Type    ProductResourceType `json:"type"`
	OwnerID int64               `json:"owner_id"`
	Url     string              `json:"url"`
	Order   int32               `json:"order"`
}

type ProductSale struct {
	ID               int64              `json:"id"`
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
}

type ProductSaleTracking struct {
	SaleID       int64 `json:"sale_id"`
	CurrentStock int64 `json:"current_stock"`
	Used         int64 `json:"used"`
}

type ProductSerial struct {
	SerialID    string             `json:"serial_id"`
	ProductID   int64              `json:"product_id"`
	IsSold      bool               `json:"is_sold"`
	IsActive    bool               `json:"is_active"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

type ProductTag struct {
	ID          int64  `json:"id"`
	Tag         string `json:"tag"`
	Description string `json:"description"`
}

type ProductTagOnProductModel struct {
	ProductModelID int64  `json:"product_model_id"`
	Tag            string `json:"tag"`
}

type ProductTracking struct {
	ProductID    int64 `json:"product_id"`
	CurrentStock int64 `json:"current_stock"`
	Sold         int64 `json:"sold"`
}

type ProductType struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}
