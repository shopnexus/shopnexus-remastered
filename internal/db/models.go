// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AccountAddressType string

const (
	AccountAddressTypeHome AccountAddressType = "Home"
	AccountAddressTypeWork AccountAddressType = "Work"
)

func (e *AccountAddressType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountAddressType(s)
	case string:
		*e = AccountAddressType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountAddressType: %T", src)
	}
	return nil
}

type NullAccountAddressType struct {
	AccountAddressType AccountAddressType `json:"account_address_type"`
	Valid              bool               `json:"valid"` // Valid is true if AccountAddressType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountAddressType) Scan(value interface{}) error {
	if value == nil {
		ns.AccountAddressType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountAddressType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountAddressType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountAddressType), nil
}

func (e AccountAddressType) Valid() bool {
	switch e {
	case AccountAddressTypeHome,
		AccountAddressTypeWork:
		return true
	}
	return false
}

func AllAccountAddressTypeValues() []AccountAddressType {
	return []AccountAddressType{
		AccountAddressTypeHome,
		AccountAddressTypeWork,
	}
}

type AccountGender string

const (
	AccountGenderMale   AccountGender = "Male"
	AccountGenderFemale AccountGender = "Female"
	AccountGenderOther  AccountGender = "Other"
)

func (e *AccountGender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountGender(s)
	case string:
		*e = AccountGender(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountGender: %T", src)
	}
	return nil
}

type NullAccountGender struct {
	AccountGender AccountGender `json:"account_gender"`
	Valid         bool          `json:"valid"` // Valid is true if AccountGender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountGender) Scan(value interface{}) error {
	if value == nil {
		ns.AccountGender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountGender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountGender), nil
}

func (e AccountGender) Valid() bool {
	switch e {
	case AccountGenderMale,
		AccountGenderFemale,
		AccountGenderOther:
		return true
	}
	return false
}

func AllAccountGenderValues() []AccountGender {
	return []AccountGender{
		AccountGenderMale,
		AccountGenderFemale,
		AccountGenderOther,
	}
}

type AccountStatus string

const (
	AccountStatusActive    AccountStatus = "Active"
	AccountStatusSuspended AccountStatus = "Suspended"
)

func (e *AccountStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountStatus(s)
	case string:
		*e = AccountStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountStatus: %T", src)
	}
	return nil
}

type NullAccountStatus struct {
	AccountStatus AccountStatus `json:"account_status"`
	Valid         bool          `json:"valid"` // Valid is true if AccountStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountStatus) Scan(value interface{}) error {
	if value == nil {
		ns.AccountStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountStatus), nil
}

func (e AccountStatus) Valid() bool {
	switch e {
	case AccountStatusActive,
		AccountStatusSuspended:
		return true
	}
	return false
}

func AllAccountStatusValues() []AccountStatus {
	return []AccountStatus{
		AccountStatusActive,
		AccountStatusSuspended,
	}
}

type AccountType string

const (
	AccountTypeCustomer AccountType = "Customer"
	AccountTypeVendor   AccountType = "Vendor"
)

func (e *AccountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountType(s)
	case string:
		*e = AccountType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountType: %T", src)
	}
	return nil
}

type NullAccountType struct {
	AccountType AccountType `json:"account_type"`
	Valid       bool        `json:"valid"` // Valid is true if AccountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountType) Scan(value interface{}) error {
	if value == nil {
		ns.AccountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountType), nil
}

func (e AccountType) Valid() bool {
	switch e {
	case AccountTypeCustomer,
		AccountTypeVendor:
		return true
	}
	return false
}

func AllAccountTypeValues() []AccountType {
	return []AccountType{
		AccountTypeCustomer,
		AccountTypeVendor,
	}
}

type CatalogCommentRefType string

const (
	CatalogCommentRefTypeProductSPU CatalogCommentRefType = "ProductSPU"
	CatalogCommentRefTypeComment    CatalogCommentRefType = "Comment"
)

func (e *CatalogCommentRefType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CatalogCommentRefType(s)
	case string:
		*e = CatalogCommentRefType(s)
	default:
		return fmt.Errorf("unsupported scan type for CatalogCommentRefType: %T", src)
	}
	return nil
}

type NullCatalogCommentRefType struct {
	CatalogCommentRefType CatalogCommentRefType `json:"catalog_comment_ref_type"`
	Valid                 bool                  `json:"valid"` // Valid is true if CatalogCommentRefType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCatalogCommentRefType) Scan(value interface{}) error {
	if value == nil {
		ns.CatalogCommentRefType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CatalogCommentRefType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCatalogCommentRefType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CatalogCommentRefType), nil
}

func (e CatalogCommentRefType) Valid() bool {
	switch e {
	case CatalogCommentRefTypeProductSPU,
		CatalogCommentRefTypeComment:
		return true
	}
	return false
}

func AllCatalogCommentRefTypeValues() []CatalogCommentRefType {
	return []CatalogCommentRefType{
		CatalogCommentRefTypeProductSPU,
		CatalogCommentRefTypeComment,
	}
}

type InventoryProductStatus string

const (
	InventoryProductStatusActive   InventoryProductStatus = "Active"
	InventoryProductStatusInactive InventoryProductStatus = "Inactive"
	InventoryProductStatusSold     InventoryProductStatus = "Sold"
	InventoryProductStatusDamaged  InventoryProductStatus = "Damaged"
)

func (e *InventoryProductStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InventoryProductStatus(s)
	case string:
		*e = InventoryProductStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InventoryProductStatus: %T", src)
	}
	return nil
}

type NullInventoryProductStatus struct {
	InventoryProductStatus InventoryProductStatus `json:"inventory_product_status"`
	Valid                  bool                   `json:"valid"` // Valid is true if InventoryProductStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInventoryProductStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InventoryProductStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InventoryProductStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInventoryProductStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InventoryProductStatus), nil
}

func (e InventoryProductStatus) Valid() bool {
	switch e {
	case InventoryProductStatusActive,
		InventoryProductStatusInactive,
		InventoryProductStatusSold,
		InventoryProductStatusDamaged:
		return true
	}
	return false
}

func AllInventoryProductStatusValues() []InventoryProductStatus {
	return []InventoryProductStatus{
		InventoryProductStatusActive,
		InventoryProductStatusInactive,
		InventoryProductStatusSold,
		InventoryProductStatusDamaged,
	}
}

type InventoryStockType string

const (
	InventoryStockTypeProductSKU InventoryStockType = "ProductSKU"
	InventoryStockTypePromotion  InventoryStockType = "Promotion"
)

func (e *InventoryStockType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InventoryStockType(s)
	case string:
		*e = InventoryStockType(s)
	default:
		return fmt.Errorf("unsupported scan type for InventoryStockType: %T", src)
	}
	return nil
}

type NullInventoryStockType struct {
	InventoryStockType InventoryStockType `json:"inventory_stock_type"`
	Valid              bool               `json:"valid"` // Valid is true if InventoryStockType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInventoryStockType) Scan(value interface{}) error {
	if value == nil {
		ns.InventoryStockType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InventoryStockType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInventoryStockType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InventoryStockType), nil
}

func (e InventoryStockType) Valid() bool {
	switch e {
	case InventoryStockTypeProductSKU,
		InventoryStockTypePromotion:
		return true
	}
	return false
}

func AllInventoryStockTypeValues() []InventoryStockType {
	return []InventoryStockType{
		InventoryStockTypeProductSKU,
		InventoryStockTypePromotion,
	}
}

type OrderInvoiceRefType string

const (
	OrderInvoiceRefTypeOrder OrderInvoiceRefType = "Order"
	OrderInvoiceRefTypeFee   OrderInvoiceRefType = "Fee"
)

func (e *OrderInvoiceRefType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderInvoiceRefType(s)
	case string:
		*e = OrderInvoiceRefType(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderInvoiceRefType: %T", src)
	}
	return nil
}

type NullOrderInvoiceRefType struct {
	OrderInvoiceRefType OrderInvoiceRefType `json:"order_invoice_ref_type"`
	Valid               bool                `json:"valid"` // Valid is true if OrderInvoiceRefType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderInvoiceRefType) Scan(value interface{}) error {
	if value == nil {
		ns.OrderInvoiceRefType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderInvoiceRefType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderInvoiceRefType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderInvoiceRefType), nil
}

func (e OrderInvoiceRefType) Valid() bool {
	switch e {
	case OrderInvoiceRefTypeOrder,
		OrderInvoiceRefTypeFee:
		return true
	}
	return false
}

func AllOrderInvoiceRefTypeValues() []OrderInvoiceRefType {
	return []OrderInvoiceRefType{
		OrderInvoiceRefTypeOrder,
		OrderInvoiceRefTypeFee,
	}
}

type OrderInvoiceType string

const (
	OrderInvoiceTypeSale       OrderInvoiceType = "Sale"
	OrderInvoiceTypeService    OrderInvoiceType = "Service"
	OrderInvoiceTypeAdjustment OrderInvoiceType = "Adjustment"
)

func (e *OrderInvoiceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderInvoiceType(s)
	case string:
		*e = OrderInvoiceType(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderInvoiceType: %T", src)
	}
	return nil
}

type NullOrderInvoiceType struct {
	OrderInvoiceType OrderInvoiceType `json:"order_invoice_type"`
	Valid            bool             `json:"valid"` // Valid is true if OrderInvoiceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderInvoiceType) Scan(value interface{}) error {
	if value == nil {
		ns.OrderInvoiceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderInvoiceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderInvoiceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderInvoiceType), nil
}

func (e OrderInvoiceType) Valid() bool {
	switch e {
	case OrderInvoiceTypeSale,
		OrderInvoiceTypeService,
		OrderInvoiceTypeAdjustment:
		return true
	}
	return false
}

func AllOrderInvoiceTypeValues() []OrderInvoiceType {
	return []OrderInvoiceType{
		OrderInvoiceTypeSale,
		OrderInvoiceTypeService,
		OrderInvoiceTypeAdjustment,
	}
}

type OrderPaymentMethod string

const (
	OrderPaymentMethodCOD     OrderPaymentMethod = "COD"
	OrderPaymentMethodCard    OrderPaymentMethod = "Card"
	OrderPaymentMethodEWallet OrderPaymentMethod = "EWallet"
	OrderPaymentMethodCrypto  OrderPaymentMethod = "Crypto"
)

func (e *OrderPaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderPaymentMethod(s)
	case string:
		*e = OrderPaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderPaymentMethod: %T", src)
	}
	return nil
}

type NullOrderPaymentMethod struct {
	OrderPaymentMethod OrderPaymentMethod `json:"order_payment_method"`
	Valid              bool               `json:"valid"` // Valid is true if OrderPaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.OrderPaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderPaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderPaymentMethod), nil
}

func (e OrderPaymentMethod) Valid() bool {
	switch e {
	case OrderPaymentMethodCOD,
		OrderPaymentMethodCard,
		OrderPaymentMethodEWallet,
		OrderPaymentMethodCrypto:
		return true
	}
	return false
}

func AllOrderPaymentMethodValues() []OrderPaymentMethod {
	return []OrderPaymentMethod{
		OrderPaymentMethodCOD,
		OrderPaymentMethodCard,
		OrderPaymentMethodEWallet,
		OrderPaymentMethodCrypto,
	}
}

type OrderRefundMethod string

const (
	OrderRefundMethodPickUp  OrderRefundMethod = "PickUp"
	OrderRefundMethodDropOff OrderRefundMethod = "DropOff"
)

func (e *OrderRefundMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderRefundMethod(s)
	case string:
		*e = OrderRefundMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderRefundMethod: %T", src)
	}
	return nil
}

type NullOrderRefundMethod struct {
	OrderRefundMethod OrderRefundMethod `json:"order_refund_method"`
	Valid             bool              `json:"valid"` // Valid is true if OrderRefundMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderRefundMethod) Scan(value interface{}) error {
	if value == nil {
		ns.OrderRefundMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderRefundMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderRefundMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderRefundMethod), nil
}

func (e OrderRefundMethod) Valid() bool {
	switch e {
	case OrderRefundMethodPickUp,
		OrderRefundMethodDropOff:
		return true
	}
	return false
}

func AllOrderRefundMethodValues() []OrderRefundMethod {
	return []OrderRefundMethod{
		OrderRefundMethodPickUp,
		OrderRefundMethodDropOff,
	}
}

type PromotionRefType string

const (
	PromotionRefTypeAll        PromotionRefType = "All"
	PromotionRefTypeProductSpu PromotionRefType = "ProductSpu"
	PromotionRefTypeProductSku PromotionRefType = "ProductSku"
	PromotionRefTypeCategory   PromotionRefType = "Category"
	PromotionRefTypeBrand      PromotionRefType = "Brand"
)

func (e *PromotionRefType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PromotionRefType(s)
	case string:
		*e = PromotionRefType(s)
	default:
		return fmt.Errorf("unsupported scan type for PromotionRefType: %T", src)
	}
	return nil
}

type NullPromotionRefType struct {
	PromotionRefType PromotionRefType `json:"promotion_ref_type"`
	Valid            bool             `json:"valid"` // Valid is true if PromotionRefType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPromotionRefType) Scan(value interface{}) error {
	if value == nil {
		ns.PromotionRefType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PromotionRefType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPromotionRefType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PromotionRefType), nil
}

func (e PromotionRefType) Valid() bool {
	switch e {
	case PromotionRefTypeAll,
		PromotionRefTypeProductSpu,
		PromotionRefTypeProductSku,
		PromotionRefTypeCategory,
		PromotionRefTypeBrand:
		return true
	}
	return false
}

func AllPromotionRefTypeValues() []PromotionRefType {
	return []PromotionRefType{
		PromotionRefTypeAll,
		PromotionRefTypeProductSpu,
		PromotionRefTypeProductSku,
		PromotionRefTypeCategory,
		PromotionRefTypeBrand,
	}
}

type PromotionType string

const (
	PromotionTypeDiscount PromotionType = "Discount"
	PromotionTypeBundle   PromotionType = "Bundle"
	PromotionTypeBuyXGetY PromotionType = "BuyXGetY"
	PromotionTypeCashback PromotionType = "Cashback"
)

func (e *PromotionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PromotionType(s)
	case string:
		*e = PromotionType(s)
	default:
		return fmt.Errorf("unsupported scan type for PromotionType: %T", src)
	}
	return nil
}

type NullPromotionType struct {
	PromotionType PromotionType `json:"promotion_type"`
	Valid         bool          `json:"valid"` // Valid is true if PromotionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPromotionType) Scan(value interface{}) error {
	if value == nil {
		ns.PromotionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PromotionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPromotionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PromotionType), nil
}

func (e PromotionType) Valid() bool {
	switch e {
	case PromotionTypeDiscount,
		PromotionTypeBundle,
		PromotionTypeBuyXGetY,
		PromotionTypeCashback:
		return true
	}
	return false
}

func AllPromotionTypeValues() []PromotionType {
	return []PromotionType{
		PromotionTypeDiscount,
		PromotionTypeBundle,
		PromotionTypeBuyXGetY,
		PromotionTypeCashback,
	}
}

type SharedResourceType string

const (
	SharedResourceTypeAvatar        SharedResourceType = "Avatar"
	SharedResourceTypeProductImage  SharedResourceType = "ProductImage"
	SharedResourceTypeBrandLogo     SharedResourceType = "BrandLogo"
	SharedResourceTypeRefund        SharedResourceType = "Refund"
	SharedResourceTypeReturnDispute SharedResourceType = "ReturnDispute"
)

func (e *SharedResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SharedResourceType(s)
	case string:
		*e = SharedResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for SharedResourceType: %T", src)
	}
	return nil
}

type NullSharedResourceType struct {
	SharedResourceType SharedResourceType `json:"shared_resource_type"`
	Valid              bool               `json:"valid"` // Valid is true if SharedResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSharedResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.SharedResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SharedResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSharedResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SharedResourceType), nil
}

func (e SharedResourceType) Valid() bool {
	switch e {
	case SharedResourceTypeAvatar,
		SharedResourceTypeProductImage,
		SharedResourceTypeBrandLogo,
		SharedResourceTypeRefund,
		SharedResourceTypeReturnDispute:
		return true
	}
	return false
}

func AllSharedResourceTypeValues() []SharedResourceType {
	return []SharedResourceType{
		SharedResourceTypeAvatar,
		SharedResourceTypeProductImage,
		SharedResourceTypeBrandLogo,
		SharedResourceTypeRefund,
		SharedResourceTypeReturnDispute,
	}
}

type SharedStatus string

const (
	SharedStatusPending    SharedStatus = "Pending"
	SharedStatusProcessing SharedStatus = "Processing"
	SharedStatusSuccess    SharedStatus = "Success"
	SharedStatusCanceled   SharedStatus = "Canceled"
	SharedStatusFailed     SharedStatus = "Failed"
)

func (e *SharedStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SharedStatus(s)
	case string:
		*e = SharedStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SharedStatus: %T", src)
	}
	return nil
}

type NullSharedStatus struct {
	SharedStatus SharedStatus `json:"shared_status"`
	Valid        bool         `json:"valid"` // Valid is true if SharedStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSharedStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SharedStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SharedStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSharedStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SharedStatus), nil
}

func (e SharedStatus) Valid() bool {
	switch e {
	case SharedStatusPending,
		SharedStatusProcessing,
		SharedStatusSuccess,
		SharedStatusCanceled,
		SharedStatusFailed:
		return true
	}
	return false
}

func AllSharedStatusValues() []SharedStatus {
	return []SharedStatus{
		SharedStatusPending,
		SharedStatusProcessing,
		SharedStatusSuccess,
		SharedStatusCanceled,
		SharedStatusFailed,
	}
}

type SystemEventType string

const (
	SystemEventTypeCreated SystemEventType = "Created"
	SystemEventTypeUpdated SystemEventType = "Updated"
	SystemEventTypeDeleted SystemEventType = "Deleted"
)

func (e *SystemEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SystemEventType(s)
	case string:
		*e = SystemEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for SystemEventType: %T", src)
	}
	return nil
}

type NullSystemEventType struct {
	SystemEventType SystemEventType `json:"system_event_type"`
	Valid           bool            `json:"valid"` // Valid is true if SystemEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSystemEventType) Scan(value interface{}) error {
	if value == nil {
		ns.SystemEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SystemEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSystemEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SystemEventType), nil
}

func (e SystemEventType) Valid() bool {
	switch e {
	case SystemEventTypeCreated,
		SystemEventTypeUpdated,
		SystemEventTypeDeleted:
		return true
	}
	return false
}

func AllSystemEventTypeValues() []SystemEventType {
	return []SystemEventType{
		SystemEventTypeCreated,
		SystemEventTypeUpdated,
		SystemEventTypeDeleted,
	}
}

type AccountAddress struct {
	ID            int64              `json:"id"`
	Code          string             `json:"code"`
	AccountID     int64              `json:"account_id"`
	Type          AccountAddressType `json:"type"`
	FullName      string             `json:"full_name"`
	Phone         string             `json:"phone"`
	PhoneVerified bool               `json:"phone_verified"`
	AddressLine   string             `json:"address_line"`
	City          string             `json:"city"`
	StateProvince string             `json:"state_province"`
	Country       string             `json:"country"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

type AccountBase struct {
	ID          int64              `json:"id"`
	Code        string             `json:"code"`
	Type        AccountType        `json:"type"`
	Status      AccountStatus      `json:"status"`
	Phone       pgtype.Text        `json:"phone"`
	Email       pgtype.Text        `json:"email"`
	Username    pgtype.Text        `json:"username"`
	Password    pgtype.Text        `json:"password"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

type AccountCartItem struct {
	ID          int64              `json:"id"`
	CartID      int64              `json:"cart_id"`
	SkuID       int64              `json:"sku_id"`
	Quantity    int64              `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

type AccountCustomer struct {
	ID               int64              `json:"id"`
	DefaultAddressID pgtype.Int8        `json:"default_address_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
}

type AccountIncomeHistory struct {
	ID             int64              `json:"id"`
	AccountID      int64              `json:"account_id"`
	Type           string             `json:"type"`
	Income         int64              `json:"income"`
	CurrentBalance int64              `json:"current_balance"`
	Note           pgtype.Text        `json:"note"`
	DateCreated    pgtype.Timestamptz `json:"date_created"`
	Hash           []byte             `json:"hash"`
	PrevHash       []byte             `json:"prev_hash"`
}

type AccountNotification struct {
	ID            int64              `json:"id"`
	AccountID     int64              `json:"account_id"`
	Type          string             `json:"type"`
	Channel       string             `json:"channel"`
	IsRead        bool               `json:"is_read"`
	Content       string             `json:"content"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
	DateSent      pgtype.Timestamptz `json:"date_sent"`
	DateScheduled pgtype.Timestamptz `json:"date_scheduled"`
}

type AccountProfile struct {
	ID            int64              `json:"id"`
	Gender        NullAccountGender  `json:"gender"`
	Name          pgtype.Text        `json:"name"`
	DateOfBirth   pgtype.Date        `json:"date_of_birth"`
	AvatarRsID    pgtype.Int8        `json:"avatar_rs_id"`
	EmailVerified bool               `json:"email_verified"`
	PhoneVerified bool               `json:"phone_verified"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

type AccountVendor struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

type CatalogBrand struct {
	ID          int64  `json:"id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type CatalogCategory struct {
	ID          int64       `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	ParentID    pgtype.Int8 `json:"parent_id"`
}

type CatalogComment struct {
	ID          int64                 `json:"id"`
	Code        string                `json:"code"`
	AccountID   int64                 `json:"account_id"`
	RefType     CatalogCommentRefType `json:"ref_type"`
	RefID       int64                 `json:"ref_id"`
	Body        string                `json:"body"`
	Upvote      int64                 `json:"upvote"`
	Downvote    int64                 `json:"downvote"`
	Score       int32                 `json:"score"`
	DateCreated pgtype.Timestamptz    `json:"date_created"`
	DateUpdated pgtype.Timestamptz    `json:"date_updated"`
}

type CatalogProductSku struct {
	ID          int64              `json:"id"`
	Code        string             `json:"code"`
	SpuID       int64              `json:"spu_id"`
	Price       int64              `json:"price"`
	CanCombine  bool               `json:"can_combine"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
}

type CatalogProductSkuAttribute struct {
	ID          int64              `json:"id"`
	Code        string             `json:"code"`
	SkuID       int64              `json:"sku_id"`
	Name        string             `json:"name"`
	Value       string             `json:"value"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

type CatalogProductSpu struct {
	ID               int64              `json:"id"`
	Code             string             `json:"code"`
	AccountID        int64              `json:"account_id"`
	CategoryID       int64              `json:"category_id"`
	BrandID          int64              `json:"brand_id"`
	Name             string             `json:"name"`
	Description      string             `json:"description"`
	IsActive         bool               `json:"is_active"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
}

type CatalogProductSpuTag struct {
	ID    int64 `json:"id"`
	SpuID int64 `json:"spu_id"`
	TagID int64 `json:"tag_id"`
}

type CatalogTag struct {
	ID          int64  `json:"id"`
	Tag         string `json:"tag"`
	Description string `json:"description"`
}

type InventorySkuSerial struct {
	ID           int64                  `json:"id"`
	SerialNumber string                 `json:"serial_number"`
	SkuID        int64                  `json:"sku_id"`
	Status       InventoryProductStatus `json:"status"`
	DateCreated  pgtype.Timestamptz     `json:"date_created"`
}

type InventoryStock struct {
	ID           int64              `json:"id"`
	RefType      InventoryStockType `json:"ref_type"`
	RefID        int64              `json:"ref_id"`
	CurrentStock int64              `json:"current_stock"`
	Sold         int64              `json:"sold"`
	DateCreated  pgtype.Timestamptz `json:"date_created"`
}

type InventoryStockHistory struct {
	ID          int64              `json:"id"`
	StockID     int64              `json:"stock_id"`
	Change      int64              `json:"change"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

type OrderBase struct {
	ID            int64              `json:"id"`
	Code          string             `json:"code"`
	CustomerID    int64              `json:"customer_id"`
	PaymentMethod OrderPaymentMethod `json:"payment_method"`
	Status        SharedStatus       `json:"status"`
	Address       string             `json:"address"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

type OrderInvoice struct {
	ID              int64               `json:"id"`
	Code            string              `json:"code"`
	Type            OrderInvoiceType    `json:"type"`
	RefType         OrderInvoiceRefType `json:"ref_type"`
	RefID           int64               `json:"ref_id"`
	SellerAccountID pgtype.Int8         `json:"seller_account_id"`
	BuyerAccountID  int64               `json:"buyer_account_id"`
	Status          SharedStatus        `json:"status"`
	PaymentMethod   OrderPaymentMethod  `json:"payment_method"`
	Address         string              `json:"address"`
	Phone           string              `json:"phone"`
	Subtotal        int64               `json:"subtotal"`
	Total           int64               `json:"total"`
	FileRsID        string              `json:"file_rs_id"`
	DateCreated     pgtype.Timestamptz  `json:"date_created"`
	Hash            []byte              `json:"hash"`
	PrevHash        []byte              `json:"prev_hash"`
}

type OrderInvoiceItem struct {
	ID        int64  `json:"id"`
	InvoiceID int64  `json:"invoice_id"`
	Snapshot  []byte `json:"snapshot"`
	Quantity  int64  `json:"quantity"`
	UnitPrice int64  `json:"unit_price"`
	Subtotal  int64  `json:"subtotal"`
	Total     int64  `json:"total"`
}

type OrderItem struct {
	ID       int64  `json:"id"`
	Code     string `json:"code"`
	OrderID  int64  `json:"order_id"`
	SkuID    int64  `json:"sku_id"`
	Quantity int64  `json:"quantity"`
}

type OrderItemSerial struct {
	ID              int64 `json:"id"`
	OrderItemID     int64 `json:"order_item_id"`
	ProductSerialID int64 `json:"product_serial_id"`
}

type OrderRefund struct {
	ID           int64              `json:"id"`
	Code         string             `json:"code"`
	OrderItemID  int64              `json:"order_item_id"`
	ReviewedByID pgtype.Int8        `json:"reviewed_by_id"`
	Method       OrderRefundMethod  `json:"method"`
	Status       SharedStatus       `json:"status"`
	Reason       string             `json:"reason"`
	Address      pgtype.Text        `json:"address"`
	DateCreated  pgtype.Timestamptz `json:"date_created"`
}

type OrderRefundDispute struct {
	ID          int64              `json:"id"`
	Code        string             `json:"code"`
	RefundID    int64              `json:"refund_id"`
	IssuedByID  int64              `json:"issued_by_id"`
	Reason      string             `json:"reason"`
	Status      SharedStatus       `json:"status"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

type OrderVnpay struct {
	ID                   int64  `json:"id"`
	VnpAmount            string `json:"vnp_Amount"`
	VnpBankCode          string `json:"vnp_BankCode"`
	VnpCardType          string `json:"vnp_CardType"`
	VnpOrderInfo         string `json:"vnp_OrderInfo"`
	VnpPayDate           string `json:"vnp_PayDate"`
	VnpResponseCode      string `json:"vnp_ResponseCode"`
	VnpSecureHash        string `json:"vnp_SecureHash"`
	VnpTmnCode           string `json:"vnp_TmnCode"`
	VnpTransactionNo     string `json:"vnp_TransactionNo"`
	VnpTransactionStatus string `json:"vnp_TransactionStatus"`
	VnpTxnRef            string `json:"vnp_TxnRef"`
}

type PromotionBase struct {
	ID               int64              `json:"id"`
	Code             string             `json:"code"`
	OwnerID          pgtype.Int8        `json:"owner_id"`
	RefType          PromotionRefType   `json:"ref_type"`
	RefID            pgtype.Int8        `json:"ref_id"`
	Type             PromotionType      `json:"type"`
	Title            string             `json:"title"`
	Description      pgtype.Text        `json:"description"`
	IsActive         bool               `json:"is_active"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	ScheduleTz       pgtype.Text        `json:"schedule_tz"`
	ScheduleStart    pgtype.Timestamptz `json:"schedule_start"`
	ScheduleDuration pgtype.Int4        `json:"schedule_duration"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
}

type PromotionDiscount struct {
	ID              int64       `json:"id"`
	MinSpend        int64       `json:"min_spend"`
	MaxDiscount     int64       `json:"max_discount"`
	DiscountPercent pgtype.Int4 `json:"discount_percent"`
	DiscountPrice   pgtype.Int8 `json:"discount_price"`
}

type SharedResource struct {
	ID        int64              `json:"id"`
	MimeType  string             `json:"mime_type"`
	OwnerID   int64              `json:"owner_id"`
	OwnerType SharedResourceType `json:"owner_type"`
	Url       string             `json:"url"`
	Order     int32              `json:"order"`
}

type SystemEvent struct {
	ID            int64              `json:"id"`
	AccountID     pgtype.Int8        `json:"account_id"`
	AggregateID   int64              `json:"aggregate_id"`
	AggregateType string             `json:"aggregate_type"`
	EventType     SystemEventType    `json:"event_type"`
	Payload       []byte             `json:"payload"`
	Version       int64              `json:"version"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
}

type SystemSearchSync struct {
	ID         int64              `json:"id"`
	Name       string             `json:"name"`
	LastSynced pgtype.Timestamptz `json:"last_synced"`
}
