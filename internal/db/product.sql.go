// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(id)
FROM product.base p
         LEFT JOIN product.tracking pt ON p.id = pt.product_id
WHERE (
          (p.id = $1 OR $1 IS NULL) AND
          (product_model_id = $2 OR $2 IS NULL) AND
          (pt.current_stock >= $3 OR $3 IS NULL) AND
          (pt.current_stock <= $4 OR $4 IS NULL) AND
          (pt.sold >= $5 OR $5 IS NULL) AND
          (pt.sold <= $6 OR $6 IS NULL) AND
          (additional_price >= $7 OR $7 IS NULL) AND
          (additional_price <= $8 OR $8 IS NULL) AND
          (is_active = $9 OR $9 IS NULL) AND
          (can_combine = $10 OR $10 IS NULL) AND
          (metadata @> $11 OR $11 IS NULL) AND
          (date_created >= $12 OR $12 IS NULL) AND
          (date_created <= $13 OR $13 IS NULL)
          )
`

type CountProductsParams struct {
	ID                  pgtype.Int8        `json:"id"`
	ProductModelID      pgtype.Int8        `json:"product_model_id"`
	CurrentStockFrom    pgtype.Int8        `json:"current_stock_from"`
	CurrentStockTo      pgtype.Int8        `json:"current_stock_to"`
	SoldFrom            pgtype.Int8        `json:"sold_from"`
	SoldTo              pgtype.Int8        `json:"sold_to"`
	AdditionalPriceFrom pgtype.Int8        `json:"additional_price_from"`
	AdditionalPriceTo   pgtype.Int8        `json:"additional_price_to"`
	IsActive            pgtype.Bool        `json:"is_active"`
	CanCombine          pgtype.Bool        `json:"can_combine"`
	Metadata            []byte             `json:"metadata"`
	DateCreatedFrom     pgtype.Timestamptz `json:"date_created_from"`
	DateCreatedTo       pgtype.Timestamptz `json:"date_created_to"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.ID,
		arg.ProductModelID,
		arg.CurrentStockFrom,
		arg.CurrentStockTo,
		arg.SoldFrom,
		arg.SoldTo,
		arg.AdditionalPriceFrom,
		arg.AdditionalPriceTo,
		arg.IsActive,
		arg.CanCombine,
		arg.Metadata,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
WITH new_product AS (
INSERT
INTO product.base (product_model_id,
                   additional_price,
                   is_active,
                   can_combine,
                   metadata)
VALUES ($1, $2, $3, $4, $5)
    RETURNING id, product_model_id, additional_price, is_active, can_combine, metadata, date_created
    )
INSERT
INTO product.tracking (product_id, current_stock, sold)
SELECT new_product.id, $6, 0
FROM new_product RETURNING product_id, current_stock, sold
`

type CreateProductParams struct {
	ProductModelID  int64  `json:"product_model_id"`
	AdditionalPrice int64  `json:"additional_price"`
	IsActive        bool   `json:"is_active"`
	CanCombine      bool   `json:"can_combine"`
	Metadata        []byte `json:"metadata"`
	CurrentStock    int64  `json:"current_stock"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (ProductTracking, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ProductModelID,
		arg.AdditionalPrice,
		arg.IsActive,
		arg.CanCombine,
		arg.Metadata,
		arg.CurrentStock,
	)
	var i ProductTracking
	err := row.Scan(&i.ProductID, &i.CurrentStock, &i.Sold)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE
FROM product.base
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getProduct = `-- name: GetProduct :one
WITH filtered_product AS (SELECT p.id, p.product_model_id, p.additional_price, p.is_active, p.can_combine, p.metadata, p.date_created, pt.current_stock, pt.sold
                          FROM product.base p
                                   LEFT JOIN product.tracking pt ON p.id = pt.product_id
                          WHERE p.id = $1),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id = $1
                              AND res.type = 'PRODUCT'
                            GROUP BY res.owner_id)
SELECT p.id, p.product_model_id, p.additional_price, p.is_active, p.can_combine, p.metadata, p.date_created, p.current_stock, p.sold,
       pt.product_id, pt.current_stock, pt.sold,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_product p
         INNER JOIN product.tracking pt ON p.id = pt.product_id
         LEFT JOIN filtered_resources res ON res.owner_id = p.id
`

type GetProductRow struct {
	ID              int64              `json:"id"`
	ProductModelID  int64              `json:"product_model_id"`
	AdditionalPrice int64              `json:"additional_price"`
	IsActive        bool               `json:"is_active"`
	CanCombine      bool               `json:"can_combine"`
	Metadata        []byte             `json:"metadata"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
	CurrentStock    pgtype.Int8        `json:"current_stock"`
	Sold            pgtype.Int8        `json:"sold"`
	ProductID       int64              `json:"product_id"`
	CurrentStock_2  int64              `json:"current_stock_2"`
	Sold_2          int64              `json:"sold_2"`
	Resources       []string           `json:"resources"`
}

func (q *Queries) GetProduct(ctx context.Context, id int64) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.ProductModelID,
		&i.AdditionalPrice,
		&i.IsActive,
		&i.CanCombine,
		&i.Metadata,
		&i.DateCreated,
		&i.CurrentStock,
		&i.Sold,
		&i.ProductID,
		&i.CurrentStock_2,
		&i.Sold_2,
		&i.Resources,
	)
	return i, err
}

const getProductByPOPID = `-- name: GetProductByPOPID :one
WITH filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id = $1
                              AND res.type = 'PRODUCT'
                            GROUP BY res.owner_id)
SELECT p.id, p.product_model_id, p.additional_price, p.is_active, p.can_combine, p.metadata, p.date_created,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM product.base p
         LEFT JOIN filtered_resources res ON res.owner_id = p.id
         INNER JOIN payment.product_on_payment pop ON p.id = pop.product_id
WHERE pop.id = $1
`

type GetProductByPOPIDRow struct {
	ID              int64              `json:"id"`
	ProductModelID  int64              `json:"product_model_id"`
	AdditionalPrice int64              `json:"additional_price"`
	IsActive        bool               `json:"is_active"`
	CanCombine      bool               `json:"can_combine"`
	Metadata        []byte             `json:"metadata"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
	Resources       []string           `json:"resources"`
}

func (q *Queries) GetProductByPOPID(ctx context.Context, id int64) (GetProductByPOPIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByPOPID, id)
	var i GetProductByPOPIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductModelID,
		&i.AdditionalPrice,
		&i.IsActive,
		&i.CanCombine,
		&i.Metadata,
		&i.DateCreated,
		&i.Resources,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
WITH filtered_product AS (SELECT p.id, p.product_model_id, p.additional_price, p.is_active, p.can_combine, p.metadata, p.date_created, pt.current_stock, pt.sold
                          FROM product.base p
                                   LEFT JOIN product.tracking pt ON p.id = pt.product_id
                          WHERE (
                                    (p.id = $3 OR $3 IS NULL) AND
                                    (p.product_model_id = $4 OR
                                     $4 IS NULL) AND
                                    (pt.current_stock >= $5 OR
                                     $5 IS NULL) AND
                                    (pt.current_stock <= $6 OR
                                     $6 IS NULL) AND
                                    (pt.sold >= $7 OR $7 IS NULL) AND
                                    (pt.sold <= $8 OR $8 IS NULL) AND
                                    (p.additional_price >= $9 OR
                                     $9 IS NULL) AND
                                    (p.additional_price <= $10 OR
                                     $10 IS NULL) AND
                                    (p.is_active = $11 OR $11 IS NULL) AND
                                    (p.can_combine = $12 OR $12 IS NULL) AND
                                    (p.metadata @> $13 OR $13 IS NULL) AND
                                    (p.date_created >= $14 OR
                                     $14 IS NULL) AND
                                    (p.date_created <= $15 OR
                                     $15 IS NULL)
                                    )),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id IN (SELECT id FROM filtered_product)
                              AND res.type = 'PRODUCT'
                            GROUP BY res.owner_id)
SELECT p.id, p.product_model_id, p.additional_price, p.is_active, p.can_combine, p.metadata, p.date_created, p.current_stock, p.sold,
       pt.product_id, pt.current_stock, pt.sold,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_product p
         INNER JOIN product.tracking pt ON p.id = pt.product_id
         LEFT JOIN filtered_resources res ON res.owner_id = p.id
ORDER BY date_created DESC LIMIT $2
OFFSET $1
`

type ListProductsParams struct {
	Offset              int32              `json:"offset"`
	Limit               int32              `json:"limit"`
	ID                  pgtype.Int8        `json:"id"`
	ProductModelID      pgtype.Int8        `json:"product_model_id"`
	CurrentStockFrom    pgtype.Int8        `json:"current_stock_from"`
	CurrentStockTo      pgtype.Int8        `json:"current_stock_to"`
	SoldFrom            pgtype.Int8        `json:"sold_from"`
	SoldTo              pgtype.Int8        `json:"sold_to"`
	AdditionalPriceFrom pgtype.Int8        `json:"additional_price_from"`
	AdditionalPriceTo   pgtype.Int8        `json:"additional_price_to"`
	IsActive            pgtype.Bool        `json:"is_active"`
	CanCombine          pgtype.Bool        `json:"can_combine"`
	Metadata            []byte             `json:"metadata"`
	DateCreatedFrom     pgtype.Timestamptz `json:"date_created_from"`
	DateCreatedTo       pgtype.Timestamptz `json:"date_created_to"`
}

type ListProductsRow struct {
	ID              int64              `json:"id"`
	ProductModelID  int64              `json:"product_model_id"`
	AdditionalPrice int64              `json:"additional_price"`
	IsActive        bool               `json:"is_active"`
	CanCombine      bool               `json:"can_combine"`
	Metadata        []byte             `json:"metadata"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
	CurrentStock    pgtype.Int8        `json:"current_stock"`
	Sold            pgtype.Int8        `json:"sold"`
	ProductID       int64              `json:"product_id"`
	CurrentStock_2  int64              `json:"current_stock_2"`
	Sold_2          int64              `json:"sold_2"`
	Resources       []string           `json:"resources"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Offset,
		arg.Limit,
		arg.ID,
		arg.ProductModelID,
		arg.CurrentStockFrom,
		arg.CurrentStockTo,
		arg.SoldFrom,
		arg.SoldTo,
		arg.AdditionalPriceFrom,
		arg.AdditionalPriceTo,
		arg.IsActive,
		arg.CanCombine,
		arg.Metadata,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductsRow{}
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductModelID,
			&i.AdditionalPrice,
			&i.IsActive,
			&i.CanCombine,
			&i.Metadata,
			&i.DateCreated,
			&i.CurrentStock,
			&i.Sold,
			&i.ProductID,
			&i.CurrentStock_2,
			&i.Sold_2,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE product.base
SET product_model_id = COALESCE($2, product_model_id),
    additional_price = COALESCE($3, additional_price),
    can_combine      = COALESCE($4, can_combine),
    is_active        = COALESCE($5, is_active),
    metadata         = COALESCE($6, metadata)
WHERE id = $1
`

type UpdateProductParams struct {
	ID              int64       `json:"id"`
	ProductModelID  pgtype.Int8 `json:"product_model_id"`
	AdditionalPrice pgtype.Int8 `json:"additional_price"`
	CanCombine      pgtype.Bool `json:"can_combine"`
	IsActive        pgtype.Bool `json:"is_active"`
	Metadata        []byte      `json:"metadata"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.ProductModelID,
		arg.AdditionalPrice,
		arg.CanCombine,
		arg.IsActive,
		arg.Metadata,
	)
	return err
}

const updateProductSold = `-- name: UpdateProductSold :exec
UPDATE product.tracking
SET current_stock = current_stock - $1,
    sold          = sold + $1
WHERE (product_id = ANY ($2::bigint[]))
  AND (current_stock - $1 >= 0)
`

type UpdateProductSoldParams struct {
	Amount int64   `json:"amount"`
	Ids    []int64 `json:"ids"`
}

func (q *Queries) UpdateProductSold(ctx context.Context, arg UpdateProductSoldParams) error {
	_, err := q.db.Exec(ctx, updateProductSold, arg.Amount, arg.Ids)
	return err
}

const updateProductTracking = `-- name: UpdateProductTracking :exec
UPDATE product.tracking
SET current_stock = COALESCE($2, current_stock),
    sold          = COALESCE($3, sold)
WHERE product_id = $1
`

type UpdateProductTrackingParams struct {
	ProductID    int64       `json:"product_id"`
	CurrentStock pgtype.Int8 `json:"current_stock"`
	Sold         pgtype.Int8 `json:"sold"`
}

func (q *Queries) UpdateProductTracking(ctx context.Context, arg UpdateProductTrackingParams) error {
	_, err := q.db.Exec(ctx, updateProductTracking, arg.ProductID, arg.CurrentStock, arg.Sold)
	return err
}
