// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAdminRole = `-- name: AddAdminRole :exec
INSERT INTO "account".role_on_admin (admin_id, role_id)
VALUES ($1, $2) ON CONFLICT (admin_id, role_id) DO NOTHING
`

type AddAdminRoleParams struct {
	AdminID int64  `json:"admin_id"`
	RoleID  string `json:"role_id"`
}

func (q *Queries) AddAdminRole(ctx context.Context, arg AddAdminRoleParams) error {
	_, err := q.db.Exec(ctx, addAdminRole, arg.AdminID, arg.RoleID)
	return err
}

const createAccountAdmin = `-- name: CreateAccountAdmin :one
WITH base AS (
INSERT
INTO "account".base (username, password, type)
VALUES ($1, $2, 'ADMIN')
  RETURNING id
  )
INSERT
INTO "account".admin (id)
SELECT id
FROM base RETURNING id
`

type CreateAccountAdminParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) CreateAccountAdmin(ctx context.Context, arg CreateAccountAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountAdmin, arg.Username, arg.Password)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAccountUser = `-- name: CreateAccountUser :one
WITH base AS (
INSERT
INTO "account".base (username, password, type)
VALUES ($1, $2, 'USER')
  RETURNING id
  )
INSERT
INTO "account".user (id, email, phone, gender, full_name)
SELECT id, $3, $4, $5, $6
FROM base RETURNING id
`

type CreateAccountUserParams struct {
	Username string        `json:"username"`
	Password string        `json:"password"`
	Email    string        `json:"email"`
	Phone    string        `json:"phone"`
	Gender   AccountGender `json:"gender"`
	FullName string        `json:"full_name"`
}

func (q *Queries) CreateAccountUser(ctx context.Context, arg CreateAccountUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAccountAdmin = `-- name: GetAccountAdmin :one
WITH filtered_roles AS (SELECT r.admin_id,
                               array_agg(r.role_id) as roles
                        FROM "account".role_on_admin r
                        WHERE r.admin_id = $1
                        GROUP BY r.admin_id)
SELECT a.id, a.avatar_url, a.is_super_admin,
       b.id, b.username, b.password, b.type,
       COALESCE(r.roles, '{}') ::text[] as roles
FROM "account".admin a
       INNER JOIN "account".base b ON a.id = b.id
       LEFT JOIN filtered_roles r ON r.admin_id = a.id
WHERE (
        a.id = $2 OR
        b.username = $3
        )
`

type GetAccountAdminParams struct {
	AdminID  int64       `json:"admin_id"`
	ID       pgtype.Int8 `json:"id"`
	Username pgtype.Text `json:"username"`
}

type GetAccountAdminRow struct {
	ID           int64              `json:"id"`
	AvatarUrl    pgtype.Text        `json:"avatar_url"`
	IsSuperAdmin bool               `json:"is_super_admin"`
	ID_2         int64              `json:"id_2"`
	Username     string             `json:"username"`
	Password     string             `json:"password"`
	Type         AccountAccountType `json:"type"`
	Roles        []string           `json:"roles"`
}

func (q *Queries) GetAccountAdmin(ctx context.Context, arg GetAccountAdminParams) (GetAccountAdminRow, error) {
	row := q.db.QueryRow(ctx, getAccountAdmin, arg.AdminID, arg.ID, arg.Username)
	var i GetAccountAdminRow
	err := row.Scan(
		&i.ID,
		&i.AvatarUrl,
		&i.IsSuperAdmin,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Type,
		&i.Roles,
	)
	return i, err
}

const getAccountBase = `-- name: GetAccountBase :one
SELECT id, username, password, type
FROM "account".base
WHERE id = $1
`

func (q *Queries) GetAccountBase(ctx context.Context, id int64) (AccountBase, error) {
	row := q.db.QueryRow(ctx, getAccountBase, id)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const getAccountUser = `-- name: GetAccountUser :one
SELECT u.id, u.email, u.phone, u.gender, u.full_name, u.default_address_id, u.avatar_url, b.id, b.username, b.password, b.type
FROM "account".user u
       INNER JOIN "account".base b ON u.id = b.id
WHERE (
        u.id = $1 OR
        u.email = $2 OR
        u.phone = $3 OR
        b.username = $4
        )
`

type GetAccountUserParams struct {
	ID       pgtype.Int8 `json:"id"`
	Email    pgtype.Text `json:"email"`
	Phone    pgtype.Text `json:"phone"`
	Username pgtype.Text `json:"username"`
}

type GetAccountUserRow struct {
	ID               int64              `json:"id"`
	Email            string             `json:"email"`
	Phone            string             `json:"phone"`
	Gender           AccountGender      `json:"gender"`
	FullName         string             `json:"full_name"`
	DefaultAddressID pgtype.Int8        `json:"default_address_id"`
	AvatarUrl        pgtype.Text        `json:"avatar_url"`
	ID_2             int64              `json:"id_2"`
	Username         string             `json:"username"`
	Password         string             `json:"password"`
	Type             AccountAccountType `json:"type"`
}

func (q *Queries) GetAccountUser(ctx context.Context, arg GetAccountUserParams) (GetAccountUserRow, error) {
	row := q.db.QueryRow(ctx, getAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Username,
	)
	var i GetAccountUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
		&i.AvatarUrl,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const getAdminPermissions = `-- name: GetAdminPermissions :one
SELECT array_agg(DISTINCT p.permission_id)::TEXT[] AS permissions
FROM "account".role_on_admin r
       INNER JOIN "account".permission_on_role p ON r.role_id = p.role_id
WHERE r.admin_id = $1
`

func (q *Queries) GetAdminPermissions(ctx context.Context, adminID int64) ([]string, error) {
	row := q.db.QueryRow(ctx, getAdminPermissions, adminID)
	var permissions []string
	err := row.Scan(&permissions)
	return permissions, err
}

const getRolePermissions = `-- name: GetRolePermissions :one
SELECT array_agg(p.permission_id) as permissions
FROM "account".permission_on_role p
       INNER JOIN "account".role r ON p.role_id = r.id
WHERE r.id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getRolePermissions, id)
	var permissions interface{}
	err := row.Scan(&permissions)
	return permissions, err
}

const removeAdminRole = `-- name: RemoveAdminRole :exec
DELETE
FROM "account".role_on_admin
WHERE admin_id = $1
  AND role_id = $2
`

type RemoveAdminRoleParams struct {
	AdminID int64  `json:"admin_id"`
	RoleID  string `json:"role_id"`
}

func (q *Queries) RemoveAdminRole(ctx context.Context, arg RemoveAdminRoleParams) error {
	_, err := q.db.Exec(ctx, removeAdminRole, arg.AdminID, arg.RoleID)
	return err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE "account".base
SET username = COALESCE($2, username),
    password = COALESCE($3, password)
WHERE id = $1 RETURNING id, username, password, type
`

type UpdateAccountParams struct {
	ID       int64       `json:"id"`
	Username pgtype.Text `json:"username"`
	Password pgtype.Text `json:"password"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (AccountBase, error) {
	row := q.db.QueryRow(ctx, updateAccount, arg.ID, arg.Username, arg.Password)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const updateAccountAdmin = `-- name: UpdateAccountAdmin :one
UPDATE "account".admin
SET avatar_url = COALESCE($2, avatar_url)
WHERE id = $1 RETURNING id, avatar_url, is_super_admin
`

type UpdateAccountAdminParams struct {
	ID        int64       `json:"id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) UpdateAccountAdmin(ctx context.Context, arg UpdateAccountAdminParams) (AccountAdmin, error) {
	row := q.db.QueryRow(ctx, updateAccountAdmin, arg.ID, arg.AvatarUrl)
	var i AccountAdmin
	err := row.Scan(&i.ID, &i.AvatarUrl, &i.IsSuperAdmin)
	return i, err
}

const updateAccountUser = `-- name: UpdateAccountUser :one
UPDATE "account".user
SET email              = COALESCE($2, email),
    phone              = COALESCE($3, phone),
    gender             = COALESCE($4, gender),
    full_name          = COALESCE($5, full_name),
    default_address_id = CASE
                           WHEN $6 = TRUE THEN NULL
                           ELSE COALESCE($7, default_address_id) END,
    avatar_url         = COALESCE($8, avatar_url)
WHERE id = $1 RETURNING id, email, phone, gender, full_name, default_address_id, avatar_url
`

type UpdateAccountUserParams struct {
	ID                   int64             `json:"id"`
	Email                pgtype.Text       `json:"email"`
	Phone                pgtype.Text       `json:"phone"`
	Gender               NullAccountGender `json:"gender"`
	FullName             pgtype.Text       `json:"full_name"`
	NullDefaultAddressID interface{}       `json:"null_default_address_id"`
	DefaultAddressID     pgtype.Int8       `json:"default_address_id"`
	AvatarUrl            pgtype.Text       `json:"avatar_url"`
}

func (q *Queries) UpdateAccountUser(ctx context.Context, arg UpdateAccountUserParams) (AccountUser, error) {
	row := q.db.QueryRow(ctx, updateAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
		arg.NullDefaultAddressID,
		arg.DefaultAddressID,
		arg.AvatarUrl,
	)
	var i AccountUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
		&i.AvatarUrl,
	)
	return i, err
}
