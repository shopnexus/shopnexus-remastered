// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sale.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSales = `-- name: CountSales :one
SELECT COUNT(*)
FROM product.sale s
       LEFT JOIN product.sale_tracking st ON s.id = st.sale_id
WHERE ($1::text IS NULL OR s.type = $1)
  AND ($2::bigint IS NULL OR s.item_id = $2)
  AND ($3::timestamptz IS NULL OR s.date_started >= $3)
  AND ($4::timestamptz IS NULL OR s.date_started <= $4)
  AND ($5::timestamptz IS NULL OR s.date_ended >= $5)
  AND ($6::timestamptz IS NULL OR s.date_ended <= $6)
  AND ($7::boolean IS NULL OR s.is_active = $7)
`

type CountSalesParams struct {
	Type            pgtype.Text        `json:"type"`
	ItemID          pgtype.Int8        `json:"item_id"`
	DateStartedFrom pgtype.Timestamptz `json:"date_started_from"`
	DateStartedTo   pgtype.Timestamptz `json:"date_started_to"`
	DateEndedFrom   pgtype.Timestamptz `json:"date_ended_from"`
	DateEndedTo     pgtype.Timestamptz `json:"date_ended_to"`
	IsActive        pgtype.Bool        `json:"is_active"`
}

func (q *Queries) CountSales(ctx context.Context, arg CountSalesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSales,
		arg.Type,
		arg.ItemID,
		arg.DateStartedFrom,
		arg.DateStartedTo,
		arg.DateEndedFrom,
		arg.DateEndedTo,
		arg.IsActive,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSale = `-- name: CreateSale :one
WITH new_sale AS (
INSERT
INTO product.sale (type,
                   item_id,
                   date_started,
                   date_ended,
                   is_active,
                   discount_percent,
                   discount_price,
                   max_discount_price)
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
  ) RETURNING id, type, item_id, date_created, date_started, date_ended, is_active, discount_percent, discount_price, max_discount_price
  ), new_sale_tracking AS (
INSERT
INTO product.sale_tracking (sale_id, current_stock, used)
SELECT id, $9, 0
FROM new_sale
  RETURNING sale_id, current_stock, used
  )
SELECT ns.id, ns.type, ns.item_id, ns.date_created, ns.date_started, ns.date_ended, ns.is_active, ns.discount_percent, ns.discount_price, ns.max_discount_price, nst.current_stock, nst.used
FROM new_sale ns
       JOIN new_sale_tracking nst ON ns.id = nst.sale_id
`

type CreateSaleParams struct {
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
	CurrentStock     int64              `json:"current_stock"`
}

type CreateSaleRow struct {
	ID               int64              `json:"id"`
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
	CurrentStock     int64              `json:"current_stock"`
	Used             int64              `json:"used"`
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (CreateSaleRow, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.Type,
		arg.ItemID,
		arg.DateStarted,
		arg.DateEnded,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
		arg.MaxDiscountPrice,
		arg.CurrentStock,
	)
	var i CreateSaleRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ItemID,
		&i.DateCreated,
		&i.DateStarted,
		&i.DateEnded,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
		&i.MaxDiscountPrice,
		&i.CurrentStock,
		&i.Used,
	)
	return i, err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE
FROM product.sale
WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSale, id)
	return err
}

const getAvailableSales = `-- name: GetAvailableSales :many
SELECT s.id, s.type, s.item_id, s.date_created, s.date_started, s.date_ended, s.is_active, s.discount_percent, s.discount_price, s.max_discount_price, st.current_stock, st.used
FROM product.sale s
       LEFT JOIN product.sale_tracking st ON s.id = st.sale_id
WHERE s.is_active = true
  AND st.current_stock > 0
  AND s.date_started <= CURRENT_TIMESTAMP
  AND (s.date_ended IS NULL OR s.date_ended >= CURRENT_TIMESTAMP)
  AND (
  (s.type = 'PRODUCT_MODEL' AND s.item_id = $1::bigint) OR
  (s.type = 'BRAND' AND s.item_id = $2::bigint) OR
  (s.type = 'TAG' AND s.item_id IN (SELECT product_model_id
                                    FROM product.tag_on_product_model
                                    WHERE tag = ANY ($3::text[])))
  )
`

type GetAvailableSalesParams struct {
	ProductModelID int64    `json:"product_model_id"`
	BrandID        int64    `json:"brand_id"`
	Tags           []string `json:"tags"`
}

type GetAvailableSalesRow struct {
	ID               int64              `json:"id"`
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
	CurrentStock     pgtype.Int8        `json:"current_stock"`
	Used             pgtype.Int8        `json:"used"`
}

func (q *Queries) GetAvailableSales(ctx context.Context, arg GetAvailableSalesParams) ([]GetAvailableSalesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSales, arg.ProductModelID, arg.BrandID, arg.Tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSalesRow{}
	for rows.Next() {
		var i GetAvailableSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ItemID,
			&i.DateCreated,
			&i.DateStarted,
			&i.DateEnded,
			&i.IsActive,
			&i.DiscountPercent,
			&i.DiscountPrice,
			&i.MaxDiscountPrice,
			&i.CurrentStock,
			&i.Used,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSale = `-- name: GetSale :one
SELECT s.id, s.type, s.item_id, s.date_created, s.date_started, s.date_ended, s.is_active, s.discount_percent, s.discount_price, s.max_discount_price, st.current_stock, st.used
FROM product.sale s
       LEFT JOIN product.sale_tracking st ON s.id = st.sale_id
WHERE s.id = $1
`

type GetSaleRow struct {
	ID               int64              `json:"id"`
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
	CurrentStock     pgtype.Int8        `json:"current_stock"`
	Used             pgtype.Int8        `json:"used"`
}

func (q *Queries) GetSale(ctx context.Context, id int64) (GetSaleRow, error) {
	row := q.db.QueryRow(ctx, getSale, id)
	var i GetSaleRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ItemID,
		&i.DateCreated,
		&i.DateStarted,
		&i.DateEnded,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
		&i.MaxDiscountPrice,
		&i.CurrentStock,
		&i.Used,
	)
	return i, err
}

const listSales = `-- name: ListSales :many
SELECT s.id, s.type, s.item_id, s.date_created, s.date_started, s.date_ended, s.is_active, s.discount_percent, s.discount_price, s.max_discount_price, st.current_stock, st.used
FROM product.sale s
       LEFT JOIN product.sale_tracking st ON s.id = st.sale_id
WHERE ($1::text IS NULL OR s.type = $1)
  AND ($2::bigint IS NULL OR s.item_id = $2)
  AND ($3::timestamptz IS NULL OR s.date_started >= $3)
  AND ($4::timestamptz IS NULL OR s.date_started <= $4)
  AND ($5::timestamptz IS NULL OR s.date_ended >= $5)
  AND ($6::timestamptz IS NULL OR s.date_ended <= $6)
  AND ($7::boolean IS NULL OR s.is_active = $7)
ORDER BY s.id LIMIT $9
OFFSET $8
`

type ListSalesParams struct {
	Type            pgtype.Text        `json:"type"`
	ItemID          pgtype.Int8        `json:"item_id"`
	DateStartedFrom pgtype.Timestamptz `json:"date_started_from"`
	DateStartedTo   pgtype.Timestamptz `json:"date_started_to"`
	DateEndedFrom   pgtype.Timestamptz `json:"date_ended_from"`
	DateEndedTo     pgtype.Timestamptz `json:"date_ended_to"`
	IsActive        pgtype.Bool        `json:"is_active"`
	Offset          int32              `json:"offset"`
	Limit           int32              `json:"limit"`
}

type ListSalesRow struct {
	ID               int64              `json:"id"`
	Type             ProductSaleType    `json:"type"`
	ItemID           int64              `json:"item_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateStarted      pgtype.Timestamptz `json:"date_started"`
	DateEnded        pgtype.Timestamptz `json:"date_ended"`
	IsActive         bool               `json:"is_active"`
	DiscountPercent  pgtype.Int4        `json:"discount_percent"`
	DiscountPrice    pgtype.Int8        `json:"discount_price"`
	MaxDiscountPrice int64              `json:"max_discount_price"`
	CurrentStock     pgtype.Int8        `json:"current_stock"`
	Used             pgtype.Int8        `json:"used"`
}

func (q *Queries) ListSales(ctx context.Context, arg ListSalesParams) ([]ListSalesRow, error) {
	rows, err := q.db.Query(ctx, listSales,
		arg.Type,
		arg.ItemID,
		arg.DateStartedFrom,
		arg.DateStartedTo,
		arg.DateEndedFrom,
		arg.DateEndedTo,
		arg.IsActive,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSalesRow{}
	for rows.Next() {
		var i ListSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ItemID,
			&i.DateCreated,
			&i.DateStarted,
			&i.DateEnded,
			&i.IsActive,
			&i.DiscountPercent,
			&i.DiscountPrice,
			&i.MaxDiscountPrice,
			&i.CurrentStock,
			&i.Used,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSale = `-- name: UpdateSale :exec
UPDATE product.sale
SET type               = COALESCE($2, type),
    item_id            = COALESCE($3, item_id),
    date_started       = COALESCE($4, date_started),
    date_ended         = COALESCE($5, date_ended),
    is_active          = COALESCE($6, is_active),
    discount_percent   = COALESCE($7, discount_percent),
    discount_price     = COALESCE($8, discount_price),
    max_discount_price = COALESCE($9, max_discount_price)
WHERE id = $1
`

type UpdateSaleParams struct {
	ID               int64               `json:"id"`
	Type             NullProductSaleType `json:"type"`
	ItemID           pgtype.Int8         `json:"item_id"`
	DateStarted      pgtype.Timestamptz  `json:"date_started"`
	DateEnded        pgtype.Timestamptz  `json:"date_ended"`
	IsActive         pgtype.Bool         `json:"is_active"`
	DiscountPercent  pgtype.Int4         `json:"discount_percent"`
	DiscountPrice    pgtype.Int8         `json:"discount_price"`
	MaxDiscountPrice pgtype.Int8         `json:"max_discount_price"`
}

func (q *Queries) UpdateSale(ctx context.Context, arg UpdateSaleParams) error {
	_, err := q.db.Exec(ctx, updateSale,
		arg.ID,
		arg.Type,
		arg.ItemID,
		arg.DateStarted,
		arg.DateEnded,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
		arg.MaxDiscountPrice,
	)
	return err
}

const updateSaleTracking = `-- name: UpdateSaleTracking :exec
UPDATE product.sale_tracking
SET current_stock = COALESCE($2, current_stock),
    used          = COALESCE($3, used)
WHERE sale_id = $1
`

type UpdateSaleTrackingParams struct {
	SaleID       int64       `json:"sale_id"`
	CurrentStock pgtype.Int8 `json:"current_stock"`
	Used         pgtype.Int8 `json:"used"`
}

func (q *Queries) UpdateSaleTracking(ctx context.Context, arg UpdateSaleTrackingParams) error {
	_, err := q.db.Exec(ctx, updateSaleTracking, arg.SaleID, arg.CurrentStock, arg.Used)
	return err
}
