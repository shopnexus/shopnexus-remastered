// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAccount = `-- name: CountAccount :one
SELECT COUNT(*)
FROM "account"."account"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("status" = $4 OR $4 IS NULL) AND
    ("phone" = $5 OR $5 IS NULL) AND
    ("email" = $6 OR $6 IS NULL) AND
    ("username" = $7 OR $7 IS NULL) AND
    ("password" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
`

type CountAccountParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	Type        NullAccountType    `json:"type"`
	Status      NullAccountStatus  `json:"status"`
	Phone       pgtype.Text        `json:"phone"`
	Email       pgtype.Text        `json:"email"`
	Username    pgtype.Text        `json:"username"`
	Password    pgtype.Text        `json:"password"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountAccount(ctx context.Context, arg CountAccountParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAccount,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.Phone,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddress = `-- name: CountAddress :one
SELECT COUNT(*)
FROM "account"."address"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("type" = $4 OR $4 IS NULL) AND
    ("full_name" = $5 OR $5 IS NULL) AND
    ("phone" = $6 OR $6 IS NULL) AND
    ("phone_verified" = $7 OR $7 IS NULL) AND
    ("address_line" = $8 OR $8 IS NULL) AND
    ("city" = $9 OR $9 IS NULL) AND
    ("state_province" = $10 OR $10 IS NULL) AND
    ("country" = $11 OR $11 IS NULL) AND
    ("date_created" = $12 OR $12 IS NULL) AND
    ("date_updated" = $13 OR $13 IS NULL)
)
`

type CountAddressParams struct {
	ID            pgtype.Int8            `json:"id"`
	Code          pgtype.Text            `json:"code"`
	AccountID     pgtype.Int8            `json:"account_id"`
	Type          NullAccountAddressType `json:"type"`
	FullName      pgtype.Text            `json:"full_name"`
	Phone         pgtype.Text            `json:"phone"`
	PhoneVerified pgtype.Bool            `json:"phone_verified"`
	AddressLine   pgtype.Text            `json:"address_line"`
	City          pgtype.Text            `json:"city"`
	StateProvince pgtype.Text            `json:"state_province"`
	Country       pgtype.Text            `json:"country"`
	DateCreated   pgtype.Timestamptz     `json:"date_created"`
	DateUpdated   pgtype.Timestamptz     `json:"date_updated"`
}

func (q *Queries) CountAddress(ctx context.Context, arg CountAddressParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAddress,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.Type,
		arg.FullName,
		arg.Phone,
		arg.PhoneVerified,
		arg.AddressLine,
		arg.City,
		arg.StateProvince,
		arg.Country,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBrand = `-- name: CountBrand :one
SELECT COUNT(*)
FROM "catalog"."brand"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL)
)
`

type CountBrandParams struct {
	ID   pgtype.Int8 `json:"id"`
	Code pgtype.Text `json:"code"`
}

func (q *Queries) CountBrand(ctx context.Context, arg CountBrandParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBrand, arg.ID, arg.Code)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCartItem = `-- name: CountCartItem :one
SELECT COUNT(*)
FROM "account"."cart_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("cart_id" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("quantity" = $4 OR $4 IS NULL) AND
    ("date_created" = $5 OR $5 IS NULL) AND
    ("date_updated" = $6 OR $6 IS NULL)
)
`

type CountCartItemParams struct {
	ID          pgtype.Int8        `json:"id"`
	CartID      pgtype.Int8        `json:"cart_id"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Quantity    pgtype.Int8        `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountCartItem(ctx context.Context, arg CountCartItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCartItem,
		arg.ID,
		arg.CartID,
		arg.SkuID,
		arg.Quantity,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCategory = `-- name: CountCategory :one
SELECT COUNT(*)
FROM "catalog"."category"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("name" = $2 OR $2 IS NULL) AND
    ("parent_id" = $3 OR $3 IS NULL)
)
`

type CountCategoryParams struct {
	ID       pgtype.Int8 `json:"id"`
	Name     pgtype.Text `json:"name"`
	ParentID pgtype.Int8 `json:"parent_id"`
}

func (q *Queries) CountCategory(ctx context.Context, arg CountCategoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCategory, arg.ID, arg.Name, arg.ParentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countComment = `-- name: CountComment :one
SELECT COUNT(*)
FROM "catalog"."comment"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("upvote" = $6 OR $6 IS NULL) AND
    ("downvote" = $7 OR $7 IS NULL) AND
    ("score" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
`

type CountCommentParams struct {
	ID          pgtype.Int8                `json:"id"`
	Code        pgtype.Text                `json:"code"`
	AccountID   pgtype.Int8                `json:"account_id"`
	RefType     NullCatalogCommentDestType `json:"ref_type"`
	RefID       pgtype.Int8                `json:"ref_id"`
	Upvote      pgtype.Int8                `json:"upvote"`
	Downvote    pgtype.Int8                `json:"downvote"`
	Score       pgtype.Int4                `json:"score"`
	DateCreated pgtype.Timestamptz         `json:"date_created"`
	DateUpdated pgtype.Timestamptz         `json:"date_updated"`
}

func (q *Queries) CountComment(ctx context.Context, arg CountCommentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countComment,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCustomer = `-- name: CountCustomer :one
SELECT COUNT(*)
FROM "account"."customer"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("default_address_id" = $3 OR $3 IS NULL) AND
    ("date_created" = $4 OR $4 IS NULL) AND
    ("date_updated" = $5 OR $5 IS NULL)
)
`

type CountCustomerParams struct {
	ID               pgtype.Int8        `json:"id"`
	AccountID        pgtype.Int8        `json:"account_id"`
	DefaultAddressID pgtype.Int8        `json:"default_address_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountCustomer(ctx context.Context, arg CountCustomerParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomer,
		arg.ID,
		arg.AccountID,
		arg.DefaultAddressID,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEvent = `-- name: CountEvent :one
SELECT COUNT(*)
FROM "system"."event"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("aggregate_id" = $3 OR $3 IS NULL) AND
    ("aggregate_type" = $4 OR $4 IS NULL) AND
    ("event_type" = $5 OR $5 IS NULL) AND
    ("payload" = $6 OR $6 IS NULL) AND
    ("version" = $7 OR $7 IS NULL) AND
    ("date_created" = $8 OR $8 IS NULL)
)
`

type CountEventParams struct {
	ID            pgtype.Int8         `json:"id"`
	AccountID     pgtype.Int8         `json:"account_id"`
	AggregateID   pgtype.Int8         `json:"aggregate_id"`
	AggregateType pgtype.Text         `json:"aggregate_type"`
	EventType     NullSystemEventType `json:"event_type"`
	Payload       []byte              `json:"payload"`
	Version       pgtype.Int8         `json:"version"`
	DateCreated   pgtype.Timestamptz  `json:"date_created"`
}

func (q *Queries) CountEvent(ctx context.Context, arg CountEventParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvent,
		arg.ID,
		arg.AccountID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Payload,
		arg.Version,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoice = `-- name: CountInvoice :one
SELECT COUNT(*)
FROM "payment"."invoice"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("seller_account_id" = $6 OR $6 IS NULL) AND
    ("buyer_account_id" = $7 OR $7 IS NULL) AND
    ("status" = $8 OR $8 IS NULL) AND
    ("payment_method" = $9 OR $9 IS NULL) AND
    ("subtotal" = $10 OR $10 IS NULL) AND
    ("total" = $11 OR $11 IS NULL) AND
    ("date_created" = $12 OR $12 IS NULL) AND
    ("hash" = $13 OR $13 IS NULL) AND
    ("prev_hash" = $14 OR $14 IS NULL)
)
`

type CountInvoiceParams struct {
	ID              pgtype.Int8               `json:"id"`
	Code            pgtype.Text               `json:"code"`
	Type            NullPaymentInvoiceType    `json:"type"`
	RefType         NullPaymentInvoiceRefType `json:"ref_type"`
	RefID           pgtype.Int8               `json:"ref_id"`
	SellerAccountID pgtype.Int8               `json:"seller_account_id"`
	BuyerAccountID  pgtype.Int8               `json:"buyer_account_id"`
	Status          NullSharedStatus          `json:"status"`
	PaymentMethod   NullPaymentPaymentMethod  `json:"payment_method"`
	Subtotal        pgtype.Int8               `json:"subtotal"`
	Total           pgtype.Int8               `json:"total"`
	DateCreated     pgtype.Timestamptz        `json:"date_created"`
	Hash            []byte                    `json:"hash"`
	PrevHash        []byte                    `json:"prev_hash"`
}

func (q *Queries) CountInvoice(ctx context.Context, arg CountInvoiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoice,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.RefType,
		arg.RefID,
		arg.SellerAccountID,
		arg.BuyerAccountID,
		arg.Status,
		arg.PaymentMethod,
		arg.Subtotal,
		arg.Total,
		arg.DateCreated,
		arg.Hash,
		arg.PrevHash,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoiceItem = `-- name: CountInvoiceItem :one
SELECT COUNT(*)
FROM "payment"."invoice_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("invoice_id" = $2 OR $2 IS NULL) AND
    ("snapshot" = $3 OR $3 IS NULL) AND
    ("quantity" = $4 OR $4 IS NULL) AND
    ("unit_price" = $5 OR $5 IS NULL) AND
    ("subtotal" = $6 OR $6 IS NULL) AND
    ("total" = $7 OR $7 IS NULL)
)
`

type CountInvoiceItemParams struct {
	ID        pgtype.Int8 `json:"id"`
	InvoiceID pgtype.Int8 `json:"invoice_id"`
	Snapshot  []byte      `json:"snapshot"`
	Quantity  pgtype.Int8 `json:"quantity"`
	UnitPrice pgtype.Int8 `json:"unit_price"`
	Subtotal  pgtype.Int8 `json:"subtotal"`
	Total     pgtype.Int8 `json:"total"`
}

func (q *Queries) CountInvoiceItem(ctx context.Context, arg CountInvoiceItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoiceItem,
		arg.ID,
		arg.InvoiceID,
		arg.Snapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
		arg.Total,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrder = `-- name: CountOrder :one
SELECT COUNT(*)
FROM "payment"."order"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("customer_id" = $3 OR $3 IS NULL) AND
    ("payment_method" = $4 OR $4 IS NULL) AND
    ("status" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
`

type CountOrderParams struct {
	ID            pgtype.Int8              `json:"id"`
	Code          pgtype.Text              `json:"code"`
	CustomerID    pgtype.Int8              `json:"customer_id"`
	PaymentMethod NullPaymentPaymentMethod `json:"payment_method"`
	Status        NullSharedStatus         `json:"status"`
	DateCreated   pgtype.Timestamptz       `json:"date_created"`
	DateUpdated   pgtype.Timestamptz       `json:"date_updated"`
}

func (q *Queries) CountOrder(ctx context.Context, arg CountOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrder,
		arg.ID,
		arg.Code,
		arg.CustomerID,
		arg.PaymentMethod,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrderItem = `-- name: CountOrderItem :one
SELECT COUNT(*)
FROM "payment"."order_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("order_id" = $3 OR $3 IS NULL) AND
    ("sku_id" = $4 OR $4 IS NULL) AND
    ("quantity" = $5 OR $5 IS NULL)
)
`

type CountOrderItemParams struct {
	ID       pgtype.Int8 `json:"id"`
	Code     pgtype.Text `json:"code"`
	OrderID  pgtype.Int8 `json:"order_id"`
	SkuID    pgtype.Int8 `json:"sku_id"`
	Quantity pgtype.Int8 `json:"quantity"`
}

func (q *Queries) CountOrderItem(ctx context.Context, arg CountOrderItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrderItem,
		arg.ID,
		arg.Code,
		arg.OrderID,
		arg.SkuID,
		arg.Quantity,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrderItemSerial = `-- name: CountOrderItemSerial :one
SELECT COUNT(*)
FROM "payment"."order_item_serial"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("order_item_id" = $2 OR $2 IS NULL) AND
    ("product_serial_id" = $3 OR $3 IS NULL)
)
`

type CountOrderItemSerialParams struct {
	ID              pgtype.Int8 `json:"id"`
	OrderItemID     pgtype.Int8 `json:"order_item_id"`
	ProductSerialID pgtype.Int8 `json:"product_serial_id"`
}

func (q *Queries) CountOrderItemSerial(ctx context.Context, arg CountOrderItemSerialParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrderItemSerial, arg.ID, arg.OrderItemID, arg.ProductSerialID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductSku = `-- name: CountProductSku :one
SELECT COUNT(*)
FROM "catalog"."product_sku"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("spu_id" = $3 OR $3 IS NULL) AND
    ("price" = $4 OR $4 IS NULL) AND
    ("can_combine" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_deleted" = $7 OR $7 IS NULL)
)
`

type CountProductSkuParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	SpuID       pgtype.Int8        `json:"spu_id"`
	Price       pgtype.Int8        `json:"price"`
	CanCombine  pgtype.Bool        `json:"can_combine"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CountProductSku(ctx context.Context, arg CountProductSkuParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductSku,
		arg.ID,
		arg.Code,
		arg.SpuID,
		arg.Price,
		arg.CanCombine,
		arg.DateCreated,
		arg.DateDeleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductSkuAttribute = `-- name: CountProductSkuAttribute :one
SELECT COUNT(*)
FROM "catalog"."product_sku_attribute"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("name" = $4 OR $4 IS NULL) AND
    ("value" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
`

type CountProductSkuAttributeParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Name        pgtype.Text        `json:"name"`
	Value       pgtype.Text        `json:"value"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountProductSkuAttribute(ctx context.Context, arg CountProductSkuAttributeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductSkuAttribute,
		arg.ID,
		arg.Code,
		arg.SkuID,
		arg.Name,
		arg.Value,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductSpu = `-- name: CountProductSpu :one
SELECT COUNT(*)
FROM "catalog"."product_spu"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("category_id" = $4 OR $4 IS NULL) AND
    ("brand_id" = $5 OR $5 IS NULL) AND
    ("is_active" = $6 OR $6 IS NULL) AND
    ("date_manufactured" = $7 OR $7 IS NULL) AND
    ("date_created" = $8 OR $8 IS NULL) AND
    ("date_updated" = $9 OR $9 IS NULL) AND
    ("date_deleted" = $10 OR $10 IS NULL)
)
`

type CountProductSpuParams struct {
	ID               pgtype.Int8        `json:"id"`
	Code             pgtype.Text        `json:"code"`
	AccountID        pgtype.Int8        `json:"account_id"`
	CategoryID       pgtype.Int8        `json:"category_id"`
	BrandID          pgtype.Int8        `json:"brand_id"`
	IsActive         pgtype.Bool        `json:"is_active"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CountProductSpu(ctx context.Context, arg CountProductSpuParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductSpu,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.CategoryID,
		arg.BrandID,
		arg.IsActive,
		arg.DateManufactured,
		arg.DateCreated,
		arg.DateUpdated,
		arg.DateDeleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductSpuTag = `-- name: CountProductSpuTag :one
SELECT COUNT(*)
FROM "catalog"."product_spu_tag"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("spu_id" = $2 OR $2 IS NULL) AND
    ("tag_id" = $3 OR $3 IS NULL)
)
`

type CountProductSpuTagParams struct {
	ID    pgtype.Int8 `json:"id"`
	SpuID pgtype.Int8 `json:"spu_id"`
	TagID pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) CountProductSpuTag(ctx context.Context, arg CountProductSpuTagParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductSpuTag, arg.ID, arg.SpuID, arg.TagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProfile = `-- name: CountProfile :one
SELECT COUNT(*)
FROM "account"."profile"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("gender" = $3 OR $3 IS NULL) AND
    ("name" = $4 OR $4 IS NULL) AND
    ("date_of_birth" = $5 OR $5 IS NULL) AND
    ("avatar_rs_id" = $6 OR $6 IS NULL) AND
    ("email_verified" = $7 OR $7 IS NULL) AND
    ("phone_verified" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
`

type CountProfileParams struct {
	ID            pgtype.Int8        `json:"id"`
	AccountID     pgtype.Int8        `json:"account_id"`
	Gender        NullAccountGender  `json:"gender"`
	Name          pgtype.Text        `json:"name"`
	DateOfBirth   pgtype.Date        `json:"date_of_birth"`
	AvatarRsID    pgtype.Int8        `json:"avatar_rs_id"`
	EmailVerified pgtype.Bool        `json:"email_verified"`
	PhoneVerified pgtype.Bool        `json:"phone_verified"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountProfile(ctx context.Context, arg CountProfileParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProfile,
		arg.ID,
		arg.AccountID,
		arg.Gender,
		arg.Name,
		arg.DateOfBirth,
		arg.AvatarRsID,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPromotion = `-- name: CountPromotion :one
SELECT COUNT(*)
FROM "promotion"."promotion"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("is_active" = $4 OR $4 IS NULL) AND
    ("date_started" = $5 OR $5 IS NULL) AND
    ("date_ended" = $6 OR $6 IS NULL) AND
    ("date_created" = $7 OR $7 IS NULL)
)
`

type CountPromotionParams struct {
	ID          pgtype.Int8                `json:"id"`
	Code        pgtype.Text                `json:"code"`
	Type        NullPromotionPromotionType `json:"type"`
	IsActive    pgtype.Bool                `json:"is_active"`
	DateStarted pgtype.Timestamptz         `json:"date_started"`
	DateEnded   pgtype.Timestamptz         `json:"date_ended"`
	DateCreated pgtype.Timestamptz         `json:"date_created"`
}

func (q *Queries) CountPromotion(ctx context.Context, arg CountPromotionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPromotion,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.IsActive,
		arg.DateStarted,
		arg.DateEnded,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPromotionRedemption = `-- name: CountPromotionRedemption :one
SELECT COUNT(*)
FROM "promotion"."promotion_redemption"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("promotion_id" = $2 OR $2 IS NULL) AND
    ("version" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL)
)
`

type CountPromotionRedemptionParams struct {
	ID          pgtype.Int8                   `json:"id"`
	PromotionID pgtype.Int8                   `json:"promotion_id"`
	Version     pgtype.Int8                   `json:"version"`
	RefType     NullPromotionPromotionRefType `json:"ref_type"`
	RefID       pgtype.Int8                   `json:"ref_id"`
	DateCreated pgtype.Timestamptz            `json:"date_created"`
}

func (q *Queries) CountPromotionRedemption(ctx context.Context, arg CountPromotionRedemptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPromotionRedemption,
		arg.ID,
		arg.PromotionID,
		arg.Version,
		arg.RefType,
		arg.RefID,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPromotionVoucher = `-- name: CountPromotionVoucher :one
SELECT COUNT(*)
FROM "promotion"."promotion_voucher"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("promotion_id" = $2 OR $2 IS NULL) AND
    ("min_spend" = $3 OR $3 IS NULL) AND
    ("max_discount" = $4 OR $4 IS NULL) AND
    ("discount_percent" = $5 OR $5 IS NULL) AND
    ("discount_price" = $6 OR $6 IS NULL)
)
`

type CountPromotionVoucherParams struct {
	ID              pgtype.Int8 `json:"id"`
	PromotionID     pgtype.Int8 `json:"promotion_id"`
	MinSpend        pgtype.Int8 `json:"min_spend"`
	MaxDiscount     pgtype.Int8 `json:"max_discount"`
	DiscountPercent pgtype.Int4 `json:"discount_percent"`
	DiscountPrice   pgtype.Int8 `json:"discount_price"`
}

func (q *Queries) CountPromotionVoucher(ctx context.Context, arg CountPromotionVoucherParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPromotionVoucher,
		arg.ID,
		arg.PromotionID,
		arg.MinSpend,
		arg.MaxDiscount,
		arg.DiscountPercent,
		arg.DiscountPrice,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRefund = `-- name: CountRefund :one
SELECT COUNT(*)
FROM "payment"."refund"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("order_item_id" = $3 OR $3 IS NULL) AND
    ("reviewed_by_id" = $4 OR $4 IS NULL) AND
    ("method" = $5 OR $5 IS NULL) AND
    ("status" = $6 OR $6 IS NULL) AND
    ("date_created" = $7 OR $7 IS NULL)
)
`

type CountRefundParams struct {
	ID           pgtype.Int8             `json:"id"`
	Code         pgtype.Text             `json:"code"`
	OrderItemID  pgtype.Int8             `json:"order_item_id"`
	ReviewedByID pgtype.Int8             `json:"reviewed_by_id"`
	Method       NullPaymentRefundMethod `json:"method"`
	Status       NullSharedStatus        `json:"status"`
	DateCreated  pgtype.Timestamptz      `json:"date_created"`
}

func (q *Queries) CountRefund(ctx context.Context, arg CountRefundParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefund,
		arg.ID,
		arg.Code,
		arg.OrderItemID,
		arg.ReviewedByID,
		arg.Method,
		arg.Status,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRefundDispute = `-- name: CountRefundDispute :one
SELECT COUNT(*)
FROM "payment"."refund_dispute"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("refund_id" = $3 OR $3 IS NULL) AND
    ("vendor_id" = $4 OR $4 IS NULL) AND
    ("status" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
`

type CountRefundDisputeParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	RefundID    pgtype.Int8        `json:"refund_id"`
	VendorID    pgtype.Int8        `json:"vendor_id"`
	Status      NullSharedStatus   `json:"status"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CountRefundDispute(ctx context.Context, arg CountRefundDisputeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefundDispute,
		arg.ID,
		arg.Code,
		arg.RefundID,
		arg.VendorID,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countResource = `-- name: CountResource :one
SELECT COUNT(*)
FROM "shared"."resource"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("owner_id" = $2 OR $2 IS NULL) AND
    ("owner_type" = $3 OR $3 IS NULL) AND
    ("order" = $4 OR $4 IS NULL)
)
`

type CountResourceParams struct {
	ID        pgtype.Int8            `json:"id"`
	OwnerID   pgtype.Int8            `json:"owner_id"`
	OwnerType NullSharedResourceType `json:"owner_type"`
	Order     pgtype.Int4            `json:"order"`
}

func (q *Queries) CountResource(ctx context.Context, arg CountResourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResource,
		arg.ID,
		arg.OwnerID,
		arg.OwnerType,
		arg.Order,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchSync = `-- name: CountSearchSync :one
SELECT COUNT(*)
FROM "system"."search_sync"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("name" = $2 OR $2 IS NULL) AND
    ("last_synced" = $3 OR $3 IS NULL)
)
`

type CountSearchSyncParams struct {
	ID         pgtype.Int8        `json:"id"`
	Name       pgtype.Text        `json:"name"`
	LastSynced pgtype.Timestamptz `json:"last_synced"`
}

func (q *Queries) CountSearchSync(ctx context.Context, arg CountSearchSyncParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchSync, arg.ID, arg.Name, arg.LastSynced)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSkuSerial = `-- name: CountSkuSerial :one
SELECT COUNT(*)
FROM "inventory"."sku_serial"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("serial_number" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("status" = $4 OR $4 IS NULL) AND
    ("date_created" = $5 OR $5 IS NULL)
)
`

type CountSkuSerialParams struct {
	ID           pgtype.Int8                `json:"id"`
	SerialNumber pgtype.Text                `json:"serial_number"`
	SkuID        pgtype.Int8                `json:"sku_id"`
	Status       NullInventoryProductStatus `json:"status"`
	DateCreated  pgtype.Timestamptz         `json:"date_created"`
}

func (q *Queries) CountSkuSerial(ctx context.Context, arg CountSkuSerialParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSkuSerial,
		arg.ID,
		arg.SerialNumber,
		arg.SkuID,
		arg.Status,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStock = `-- name: CountStock :one
SELECT COUNT(*)
FROM "inventory"."stock"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("ref_type" = $2 OR $2 IS NULL) AND
    ("ref_id" = $3 OR $3 IS NULL) AND
    ("current_stock" = $4 OR $4 IS NULL) AND
    ("sold" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL)
)
`

type CountStockParams struct {
	ID           pgtype.Int8            `json:"id"`
	RefType      NullInventoryStockType `json:"ref_type"`
	RefID        pgtype.Int8            `json:"ref_id"`
	CurrentStock pgtype.Int8            `json:"current_stock"`
	Sold         pgtype.Int8            `json:"sold"`
	DateCreated  pgtype.Timestamptz     `json:"date_created"`
}

func (q *Queries) CountStock(ctx context.Context, arg CountStockParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStock,
		arg.ID,
		arg.RefType,
		arg.RefID,
		arg.CurrentStock,
		arg.Sold,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStockHistory = `-- name: CountStockHistory :one
SELECT COUNT(*)
FROM "inventory"."stock_history"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("stock_id" = $2 OR $2 IS NULL) AND
    ("change" = $3 OR $3 IS NULL) AND
    ("date_created" = $4 OR $4 IS NULL)
)
`

type CountStockHistoryParams struct {
	ID          pgtype.Int8        `json:"id"`
	StockID     pgtype.Int8        `json:"stock_id"`
	Change      pgtype.Int8        `json:"change"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

func (q *Queries) CountStockHistory(ctx context.Context, arg CountStockHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStockHistory,
		arg.ID,
		arg.StockID,
		arg.Change,
		arg.DateCreated,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTag = `-- name: CountTag :one
SELECT COUNT(*)
FROM "catalog"."tag"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("tag" = $2 OR $2 IS NULL)
)
`

type CountTagParams struct {
	ID  pgtype.Int8 `json:"id"`
	Tag pgtype.Text `json:"tag"`
}

func (q *Queries) CountTag(ctx context.Context, arg CountTagParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTag, arg.ID, arg.Tag)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVendor = `-- name: CountVendor :one
SELECT COUNT(*)
FROM "account"."vendor"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL)
)
`

type CountVendorParams struct {
	ID        pgtype.Int8 `json:"id"`
	AccountID pgtype.Int8 `json:"account_id"`
}

func (q *Queries) CountVendor(ctx context.Context, arg CountVendorParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVendor, arg.ID, arg.AccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVnpay = `-- name: CountVnpay :one
SELECT COUNT(*)
FROM "payment"."vnpay"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("order_id" = $2 OR $2 IS NULL)
)
`

type CountVnpayParams struct {
	ID      pgtype.Int8 `json:"id"`
	OrderID pgtype.Int8 `json:"order_id"`
}

func (q *Queries) CountVnpay(ctx context.Context, arg CountVnpayParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVnpay, arg.ID, arg.OrderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO "account"."account" ("code", "type", "status", "phone", "email", "username", "password", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, code, type, status, phone, email, username, password, date_created, date_updated
`

type CreateAccountParams struct {
	Code        string             `json:"code"`
	Type        AccountType        `json:"type"`
	Status      AccountStatus      `json:"status"`
	Phone       pgtype.Text        `json:"phone"`
	Email       pgtype.Text        `json:"email"`
	Username    pgtype.Text        `json:"username"`
	Password    pgtype.Text        `json:"password"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (AccountAccount, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.Phone,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountAccount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Phone,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createAddress = `-- name: CreateAddress :one
INSERT INTO "account"."address" ("code", "account_id", "type", "full_name", "phone", "phone_verified", "address_line", "city", "state_province", "country", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, code, account_id, type, full_name, phone, phone_verified, address_line, city, state_province, country, date_created, date_updated
`

type CreateAddressParams struct {
	Code          string             `json:"code"`
	AccountID     int64              `json:"account_id"`
	Type          AccountAddressType `json:"type"`
	FullName      string             `json:"full_name"`
	Phone         string             `json:"phone"`
	PhoneVerified bool               `json:"phone_verified"`
	AddressLine   string             `json:"address_line"`
	City          string             `json:"city"`
	StateProvince string             `json:"state_province"`
	Country       string             `json:"country"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (AccountAddress, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.Code,
		arg.AccountID,
		arg.Type,
		arg.FullName,
		arg.Phone,
		arg.PhoneVerified,
		arg.AddressLine,
		arg.City,
		arg.StateProvince,
		arg.Country,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountAddress
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.Type,
		&i.FullName,
		&i.Phone,
		&i.PhoneVerified,
		&i.AddressLine,
		&i.City,
		&i.StateProvince,
		&i.Country,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createBrand = `-- name: CreateBrand :one
INSERT INTO "catalog"."brand" ("code", "name", "description")
VALUES ($1, $2, $3)
RETURNING id, code, name, description
`

type CreateBrandParams struct {
	Code        string `json:"code"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (CatalogBrand, error) {
	row := q.db.QueryRow(ctx, createBrand, arg.Code, arg.Name, arg.Description)
	var i CatalogBrand
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const createCartItem = `-- name: CreateCartItem :one
INSERT INTO "account"."cart_item" ("cart_id", "sku_id", "quantity", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, cart_id, sku_id, quantity, date_created, date_updated
`

type CreateCartItemParams struct {
	CartID      int64              `json:"cart_id"`
	SkuID       int64              `json:"sku_id"`
	Quantity    int64              `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateCartItem(ctx context.Context, arg CreateCartItemParams) (AccountCartItem, error) {
	row := q.db.QueryRow(ctx, createCartItem,
		arg.CartID,
		arg.SkuID,
		arg.Quantity,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountCartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.SkuID,
		&i.Quantity,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO "catalog"."category" ("name", "description", "parent_id")
VALUES ($1, $2, $3)
RETURNING id, name, description, parent_id
`

type CreateCategoryParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	ParentID    pgtype.Int8 `json:"parent_id"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (CatalogCategory, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Description, arg.ParentID)
	var i CatalogCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO "catalog"."comment" ("code", "account_id", "ref_type", "ref_id", "body", "upvote", "downvote", "score", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, code, account_id, ref_type, ref_id, body, upvote, downvote, score, date_created, date_updated
`

type CreateCommentParams struct {
	Code        string                 `json:"code"`
	AccountID   int64                  `json:"account_id"`
	RefType     CatalogCommentDestType `json:"ref_type"`
	RefID       int64                  `json:"ref_id"`
	Body        string                 `json:"body"`
	Upvote      int64                  `json:"upvote"`
	Downvote    int64                  `json:"downvote"`
	Score       int32                  `json:"score"`
	DateCreated pgtype.Timestamptz     `json:"date_created"`
	DateUpdated pgtype.Timestamptz     `json:"date_updated"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (CatalogComment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i CatalogComment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.RefType,
		&i.RefID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO "account"."customer" ("account_id", "default_address_id", "date_created", "date_updated")
VALUES ($1, $2, $3, $4)
RETURNING id, account_id, default_address_id, date_created, date_updated
`

type CreateCustomerParams struct {
	AccountID        int64              `json:"account_id"`
	DefaultAddressID pgtype.Int8        `json:"default_address_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (AccountCustomer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.AccountID,
		arg.DefaultAddressID,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountCustomer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.DefaultAddressID,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultAccount = `-- name: CreateDefaultAccount :one
INSERT INTO "account"."account" ("code", "type", "phone", "email", "username", "password")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, code, type, status, phone, email, username, password, date_created, date_updated
`

type CreateDefaultAccountParams struct {
	Code     string      `json:"code"`
	Type     AccountType `json:"type"`
	Phone    pgtype.Text `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Username pgtype.Text `json:"username"`
	Password pgtype.Text `json:"password"`
}

func (q *Queries) CreateDefaultAccount(ctx context.Context, arg CreateDefaultAccountParams) (AccountAccount, error) {
	row := q.db.QueryRow(ctx, createDefaultAccount,
		arg.Code,
		arg.Type,
		arg.Phone,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i AccountAccount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Phone,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultAddress = `-- name: CreateDefaultAddress :one
INSERT INTO "account"."address" ("code", "account_id", "full_name", "phone", "address_line", "city", "state_province", "country")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, code, account_id, type, full_name, phone, phone_verified, address_line, city, state_province, country, date_created, date_updated
`

type CreateDefaultAddressParams struct {
	Code          string `json:"code"`
	AccountID     int64  `json:"account_id"`
	FullName      string `json:"full_name"`
	Phone         string `json:"phone"`
	AddressLine   string `json:"address_line"`
	City          string `json:"city"`
	StateProvince string `json:"state_province"`
	Country       string `json:"country"`
}

func (q *Queries) CreateDefaultAddress(ctx context.Context, arg CreateDefaultAddressParams) (AccountAddress, error) {
	row := q.db.QueryRow(ctx, createDefaultAddress,
		arg.Code,
		arg.AccountID,
		arg.FullName,
		arg.Phone,
		arg.AddressLine,
		arg.City,
		arg.StateProvince,
		arg.Country,
	)
	var i AccountAddress
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.Type,
		&i.FullName,
		&i.Phone,
		&i.PhoneVerified,
		&i.AddressLine,
		&i.City,
		&i.StateProvince,
		&i.Country,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultBrand = `-- name: CreateDefaultBrand :one
INSERT INTO "catalog"."brand" ("code", "name", "description")
VALUES ($1, $2, $3)
RETURNING id, code, name, description
`

type CreateDefaultBrandParams struct {
	Code        string `json:"code"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateDefaultBrand(ctx context.Context, arg CreateDefaultBrandParams) (CatalogBrand, error) {
	row := q.db.QueryRow(ctx, createDefaultBrand, arg.Code, arg.Name, arg.Description)
	var i CatalogBrand
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const createDefaultCartItem = `-- name: CreateDefaultCartItem :one
INSERT INTO "account"."cart_item" ("cart_id", "sku_id", "quantity")
VALUES ($1, $2, $3)
RETURNING id, cart_id, sku_id, quantity, date_created, date_updated
`

type CreateDefaultCartItemParams struct {
	CartID   int64 `json:"cart_id"`
	SkuID    int64 `json:"sku_id"`
	Quantity int64 `json:"quantity"`
}

func (q *Queries) CreateDefaultCartItem(ctx context.Context, arg CreateDefaultCartItemParams) (AccountCartItem, error) {
	row := q.db.QueryRow(ctx, createDefaultCartItem, arg.CartID, arg.SkuID, arg.Quantity)
	var i AccountCartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.SkuID,
		&i.Quantity,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultCategory = `-- name: CreateDefaultCategory :one
INSERT INTO "catalog"."category" ("name", "parent_id")
VALUES ($1, $2)
RETURNING id, name, description, parent_id
`

type CreateDefaultCategoryParams struct {
	Name     string      `json:"name"`
	ParentID pgtype.Int8 `json:"parent_id"`
}

func (q *Queries) CreateDefaultCategory(ctx context.Context, arg CreateDefaultCategoryParams) (CatalogCategory, error) {
	row := q.db.QueryRow(ctx, createDefaultCategory, arg.Name, arg.ParentID)
	var i CatalogCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
	)
	return i, err
}

const createDefaultComment = `-- name: CreateDefaultComment :one
INSERT INTO "catalog"."comment" ("code", "account_id", "ref_type", "ref_id", "body")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, code, account_id, ref_type, ref_id, body, upvote, downvote, score, date_created, date_updated
`

type CreateDefaultCommentParams struct {
	Code      string                 `json:"code"`
	AccountID int64                  `json:"account_id"`
	RefType   CatalogCommentDestType `json:"ref_type"`
	RefID     int64                  `json:"ref_id"`
	Body      string                 `json:"body"`
}

func (q *Queries) CreateDefaultComment(ctx context.Context, arg CreateDefaultCommentParams) (CatalogComment, error) {
	row := q.db.QueryRow(ctx, createDefaultComment,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
		arg.Body,
	)
	var i CatalogComment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.RefType,
		&i.RefID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultCustomer = `-- name: CreateDefaultCustomer :one
INSERT INTO "account"."customer" ("account_id", "default_address_id")
VALUES ($1, $2)
RETURNING id, account_id, default_address_id, date_created, date_updated
`

type CreateDefaultCustomerParams struct {
	AccountID        int64       `json:"account_id"`
	DefaultAddressID pgtype.Int8 `json:"default_address_id"`
}

func (q *Queries) CreateDefaultCustomer(ctx context.Context, arg CreateDefaultCustomerParams) (AccountCustomer, error) {
	row := q.db.QueryRow(ctx, createDefaultCustomer, arg.AccountID, arg.DefaultAddressID)
	var i AccountCustomer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.DefaultAddressID,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultEvent = `-- name: CreateDefaultEvent :one
INSERT INTO "system"."event" ("account_id", "aggregate_id", "aggregate_type", "event_type", "payload", "version")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, account_id, aggregate_id, aggregate_type, event_type, payload, version, date_created
`

type CreateDefaultEventParams struct {
	AccountID     pgtype.Int8     `json:"account_id"`
	AggregateID   int64           `json:"aggregate_id"`
	AggregateType string          `json:"aggregate_type"`
	EventType     SystemEventType `json:"event_type"`
	Payload       []byte          `json:"payload"`
	Version       int64           `json:"version"`
}

func (q *Queries) CreateDefaultEvent(ctx context.Context, arg CreateDefaultEventParams) (SystemEvent, error) {
	row := q.db.QueryRow(ctx, createDefaultEvent,
		arg.AccountID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Payload,
		arg.Version,
	)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.Payload,
		&i.Version,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultInvoice = `-- name: CreateDefaultInvoice :one
INSERT INTO "payment"."invoice" ("code", "type", "ref_type", "ref_id", "seller_account_id", "buyer_account_id", "status", "payment_method", "address", "phone", "subtotal", "total", "file_rs_id", "hash", "prev_hash")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
RETURNING id, code, type, ref_type, ref_id, seller_account_id, buyer_account_id, status, payment_method, address, phone, subtotal, total, file_rs_id, date_created, hash, prev_hash
`

type CreateDefaultInvoiceParams struct {
	Code            string                `json:"code"`
	Type            PaymentInvoiceType    `json:"type"`
	RefType         PaymentInvoiceRefType `json:"ref_type"`
	RefID           int64                 `json:"ref_id"`
	SellerAccountID pgtype.Int8           `json:"seller_account_id"`
	BuyerAccountID  int64                 `json:"buyer_account_id"`
	Status          SharedStatus          `json:"status"`
	PaymentMethod   PaymentPaymentMethod  `json:"payment_method"`
	Address         string                `json:"address"`
	Phone           string                `json:"phone"`
	Subtotal        int64                 `json:"subtotal"`
	Total           int64                 `json:"total"`
	FileRsID        string                `json:"file_rs_id"`
	Hash            []byte                `json:"hash"`
	PrevHash        []byte                `json:"prev_hash"`
}

func (q *Queries) CreateDefaultInvoice(ctx context.Context, arg CreateDefaultInvoiceParams) (PaymentInvoice, error) {
	row := q.db.QueryRow(ctx, createDefaultInvoice,
		arg.Code,
		arg.Type,
		arg.RefType,
		arg.RefID,
		arg.SellerAccountID,
		arg.BuyerAccountID,
		arg.Status,
		arg.PaymentMethod,
		arg.Address,
		arg.Phone,
		arg.Subtotal,
		arg.Total,
		arg.FileRsID,
		arg.Hash,
		arg.PrevHash,
	)
	var i PaymentInvoice
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.RefType,
		&i.RefID,
		&i.SellerAccountID,
		&i.BuyerAccountID,
		&i.Status,
		&i.PaymentMethod,
		&i.Address,
		&i.Phone,
		&i.Subtotal,
		&i.Total,
		&i.FileRsID,
		&i.DateCreated,
		&i.Hash,
		&i.PrevHash,
	)
	return i, err
}

const createDefaultInvoiceItem = `-- name: CreateDefaultInvoiceItem :one
INSERT INTO "payment"."invoice_item" ("invoice_id", "snapshot", "quantity", "unit_price", "subtotal", "total")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, invoice_id, snapshot, quantity, unit_price, subtotal, total
`

type CreateDefaultInvoiceItemParams struct {
	InvoiceID int64  `json:"invoice_id"`
	Snapshot  []byte `json:"snapshot"`
	Quantity  int64  `json:"quantity"`
	UnitPrice int64  `json:"unit_price"`
	Subtotal  int64  `json:"subtotal"`
	Total     int64  `json:"total"`
}

func (q *Queries) CreateDefaultInvoiceItem(ctx context.Context, arg CreateDefaultInvoiceItemParams) (PaymentInvoiceItem, error) {
	row := q.db.QueryRow(ctx, createDefaultInvoiceItem,
		arg.InvoiceID,
		arg.Snapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
		arg.Total,
	)
	var i PaymentInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Snapshot,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Total,
	)
	return i, err
}

const createDefaultOrder = `-- name: CreateDefaultOrder :one
INSERT INTO "payment"."order" ("code", "customer_id", "payment_method", "status", "address", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, code, customer_id, payment_method, status, address, date_created, date_updated
`

type CreateDefaultOrderParams struct {
	Code          string               `json:"code"`
	CustomerID    int64                `json:"customer_id"`
	PaymentMethod PaymentPaymentMethod `json:"payment_method"`
	Status        SharedStatus         `json:"status"`
	Address       string               `json:"address"`
	DateUpdated   pgtype.Timestamptz   `json:"date_updated"`
}

func (q *Queries) CreateDefaultOrder(ctx context.Context, arg CreateDefaultOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, createDefaultOrder,
		arg.Code,
		arg.CustomerID,
		arg.PaymentMethod,
		arg.Status,
		arg.Address,
		arg.DateUpdated,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CustomerID,
		&i.PaymentMethod,
		&i.Status,
		&i.Address,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultOrderItem = `-- name: CreateDefaultOrderItem :one
INSERT INTO "payment"."order_item" ("code", "order_id", "sku_id", "quantity")
VALUES ($1, $2, $3, $4)
RETURNING id, code, order_id, sku_id, quantity
`

type CreateDefaultOrderItemParams struct {
	Code     string `json:"code"`
	OrderID  int64  `json:"order_id"`
	SkuID    int64  `json:"sku_id"`
	Quantity int64  `json:"quantity"`
}

func (q *Queries) CreateDefaultOrderItem(ctx context.Context, arg CreateDefaultOrderItemParams) (PaymentOrderItem, error) {
	row := q.db.QueryRow(ctx, createDefaultOrderItem,
		arg.Code,
		arg.OrderID,
		arg.SkuID,
		arg.Quantity,
	)
	var i PaymentOrderItem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderID,
		&i.SkuID,
		&i.Quantity,
	)
	return i, err
}

const createDefaultOrderItemSerial = `-- name: CreateDefaultOrderItemSerial :one
INSERT INTO "payment"."order_item_serial" ("order_item_id", "product_serial_id")
VALUES ($1, $2)
RETURNING id, order_item_id, product_serial_id
`

type CreateDefaultOrderItemSerialParams struct {
	OrderItemID     int64 `json:"order_item_id"`
	ProductSerialID int64 `json:"product_serial_id"`
}

func (q *Queries) CreateDefaultOrderItemSerial(ctx context.Context, arg CreateDefaultOrderItemSerialParams) (PaymentOrderItemSerial, error) {
	row := q.db.QueryRow(ctx, createDefaultOrderItemSerial, arg.OrderItemID, arg.ProductSerialID)
	var i PaymentOrderItemSerial
	err := row.Scan(&i.ID, &i.OrderItemID, &i.ProductSerialID)
	return i, err
}

const createDefaultProductSku = `-- name: CreateDefaultProductSku :one
INSERT INTO "catalog"."product_sku" ("code", "spu_id", "price", "date_deleted")
VALUES ($1, $2, $3, $4)
RETURNING id, code, spu_id, price, can_combine, date_created, date_deleted
`

type CreateDefaultProductSkuParams struct {
	Code        string             `json:"code"`
	SpuID       int64              `json:"spu_id"`
	Price       int64              `json:"price"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CreateDefaultProductSku(ctx context.Context, arg CreateDefaultProductSkuParams) (CatalogProductSku, error) {
	row := q.db.QueryRow(ctx, createDefaultProductSku,
		arg.Code,
		arg.SpuID,
		arg.Price,
		arg.DateDeleted,
	)
	var i CatalogProductSku
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SpuID,
		&i.Price,
		&i.CanCombine,
		&i.DateCreated,
		&i.DateDeleted,
	)
	return i, err
}

const createDefaultProductSkuAttribute = `-- name: CreateDefaultProductSkuAttribute :one
INSERT INTO "catalog"."product_sku_attribute" ("code", "sku_id", "name", "value")
VALUES ($1, $2, $3, $4)
RETURNING id, code, sku_id, name, value, date_created, date_updated
`

type CreateDefaultProductSkuAttributeParams struct {
	Code  string `json:"code"`
	SkuID int64  `json:"sku_id"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (q *Queries) CreateDefaultProductSkuAttribute(ctx context.Context, arg CreateDefaultProductSkuAttributeParams) (CatalogProductSkuAttribute, error) {
	row := q.db.QueryRow(ctx, createDefaultProductSkuAttribute,
		arg.Code,
		arg.SkuID,
		arg.Name,
		arg.Value,
	)
	var i CatalogProductSkuAttribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SkuID,
		&i.Name,
		&i.Value,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultProductSpu = `-- name: CreateDefaultProductSpu :one
INSERT INTO "catalog"."product_spu" ("code", "account_id", "category_id", "brand_id", "name", "description", "date_manufactured", "date_deleted")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, code, account_id, category_id, brand_id, name, description, is_active, date_manufactured, date_created, date_updated, date_deleted
`

type CreateDefaultProductSpuParams struct {
	Code             string             `json:"code"`
	AccountID        int64              `json:"account_id"`
	CategoryID       int64              `json:"category_id"`
	BrandID          int64              `json:"brand_id"`
	Name             string             `json:"name"`
	Description      string             `json:"description"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CreateDefaultProductSpu(ctx context.Context, arg CreateDefaultProductSpuParams) (CatalogProductSpu, error) {
	row := q.db.QueryRow(ctx, createDefaultProductSpu,
		arg.Code,
		arg.AccountID,
		arg.CategoryID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.DateManufactured,
		arg.DateDeleted,
	)
	var i CatalogProductSpu
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.CategoryID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.DateManufactured,
		&i.DateCreated,
		&i.DateUpdated,
		&i.DateDeleted,
	)
	return i, err
}

const createDefaultProductSpuTag = `-- name: CreateDefaultProductSpuTag :one
INSERT INTO "catalog"."product_spu_tag" ("spu_id", "tag_id")
VALUES ($1, $2)
RETURNING id, spu_id, tag_id
`

type CreateDefaultProductSpuTagParams struct {
	SpuID int64 `json:"spu_id"`
	TagID int64 `json:"tag_id"`
}

func (q *Queries) CreateDefaultProductSpuTag(ctx context.Context, arg CreateDefaultProductSpuTagParams) (CatalogProductSpuTag, error) {
	row := q.db.QueryRow(ctx, createDefaultProductSpuTag, arg.SpuID, arg.TagID)
	var i CatalogProductSpuTag
	err := row.Scan(&i.ID, &i.SpuID, &i.TagID)
	return i, err
}

const createDefaultProfile = `-- name: CreateDefaultProfile :one
INSERT INTO "account"."profile" ("account_id", "gender", "name", "date_of_birth", "avatar_rs_id")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, account_id, gender, name, date_of_birth, avatar_rs_id, email_verified, phone_verified, date_created, date_updated
`

type CreateDefaultProfileParams struct {
	AccountID   int64             `json:"account_id"`
	Gender      NullAccountGender `json:"gender"`
	Name        pgtype.Text       `json:"name"`
	DateOfBirth pgtype.Date       `json:"date_of_birth"`
	AvatarRsID  pgtype.Int8       `json:"avatar_rs_id"`
}

func (q *Queries) CreateDefaultProfile(ctx context.Context, arg CreateDefaultProfileParams) (AccountProfile, error) {
	row := q.db.QueryRow(ctx, createDefaultProfile,
		arg.AccountID,
		arg.Gender,
		arg.Name,
		arg.DateOfBirth,
		arg.AvatarRsID,
	)
	var i AccountProfile
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Gender,
		&i.Name,
		&i.DateOfBirth,
		&i.AvatarRsID,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultPromotion = `-- name: CreateDefaultPromotion :one
INSERT INTO "promotion"."promotion" ("code", "type", "date_ended")
VALUES ($1, $2, $3)
RETURNING id, code, type, is_active, date_started, date_ended, date_created
`

type CreateDefaultPromotionParams struct {
	Code      string                 `json:"code"`
	Type      PromotionPromotionType `json:"type"`
	DateEnded pgtype.Timestamptz     `json:"date_ended"`
}

func (q *Queries) CreateDefaultPromotion(ctx context.Context, arg CreateDefaultPromotionParams) (PromotionPromotion, error) {
	row := q.db.QueryRow(ctx, createDefaultPromotion, arg.Code, arg.Type, arg.DateEnded)
	var i PromotionPromotion
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.IsActive,
		&i.DateStarted,
		&i.DateEnded,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultPromotionRedemption = `-- name: CreateDefaultPromotionRedemption :one
INSERT INTO "promotion"."promotion_redemption" ("promotion_id", "version", "ref_type", "ref_id")
VALUES ($1, $2, $3, $4)
RETURNING id, promotion_id, version, ref_type, ref_id, date_created
`

type CreateDefaultPromotionRedemptionParams struct {
	PromotionID int64                     `json:"promotion_id"`
	Version     int64                     `json:"version"`
	RefType     PromotionPromotionRefType `json:"ref_type"`
	RefID       int64                     `json:"ref_id"`
}

func (q *Queries) CreateDefaultPromotionRedemption(ctx context.Context, arg CreateDefaultPromotionRedemptionParams) (PromotionPromotionRedemption, error) {
	row := q.db.QueryRow(ctx, createDefaultPromotionRedemption,
		arg.PromotionID,
		arg.Version,
		arg.RefType,
		arg.RefID,
	)
	var i PromotionPromotionRedemption
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.Version,
		&i.RefType,
		&i.RefID,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultPromotionVoucher = `-- name: CreateDefaultPromotionVoucher :one
INSERT INTO "promotion"."promotion_voucher" ("promotion_id", "discount_percent", "discount_price")
VALUES ($1, $2, $3)
RETURNING id, promotion_id, min_spend, max_discount, discount_percent, discount_price
`

type CreateDefaultPromotionVoucherParams struct {
	PromotionID     int64       `json:"promotion_id"`
	DiscountPercent pgtype.Int4 `json:"discount_percent"`
	DiscountPrice   pgtype.Int8 `json:"discount_price"`
}

func (q *Queries) CreateDefaultPromotionVoucher(ctx context.Context, arg CreateDefaultPromotionVoucherParams) (PromotionPromotionVoucher, error) {
	row := q.db.QueryRow(ctx, createDefaultPromotionVoucher, arg.PromotionID, arg.DiscountPercent, arg.DiscountPrice)
	var i PromotionPromotionVoucher
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.MinSpend,
		&i.MaxDiscount,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const createDefaultRefund = `-- name: CreateDefaultRefund :one
INSERT INTO "payment"."refund" ("code", "order_item_id", "reviewed_by_id", "method", "status", "reason", "address")
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, code, order_item_id, reviewed_by_id, method, status, reason, address, date_created
`

type CreateDefaultRefundParams struct {
	Code         string              `json:"code"`
	OrderItemID  int64               `json:"order_item_id"`
	ReviewedByID pgtype.Int8         `json:"reviewed_by_id"`
	Method       PaymentRefundMethod `json:"method"`
	Status       SharedStatus        `json:"status"`
	Reason       string              `json:"reason"`
	Address      pgtype.Text         `json:"address"`
}

func (q *Queries) CreateDefaultRefund(ctx context.Context, arg CreateDefaultRefundParams) (PaymentRefund, error) {
	row := q.db.QueryRow(ctx, createDefaultRefund,
		arg.Code,
		arg.OrderItemID,
		arg.ReviewedByID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
	)
	var i PaymentRefund
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderItemID,
		&i.ReviewedByID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultRefundDispute = `-- name: CreateDefaultRefundDispute :one
INSERT INTO "payment"."refund_dispute" ("code", "refund_id", "vendor_id", "reason", "date_updated")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, code, refund_id, vendor_id, reason, status, date_created, date_updated
`

type CreateDefaultRefundDisputeParams struct {
	Code        string             `json:"code"`
	RefundID    int64              `json:"refund_id"`
	VendorID    int64              `json:"vendor_id"`
	Reason      string             `json:"reason"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateDefaultRefundDispute(ctx context.Context, arg CreateDefaultRefundDisputeParams) (PaymentRefundDispute, error) {
	row := q.db.QueryRow(ctx, createDefaultRefundDispute,
		arg.Code,
		arg.RefundID,
		arg.VendorID,
		arg.Reason,
		arg.DateUpdated,
	)
	var i PaymentRefundDispute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.RefundID,
		&i.VendorID,
		&i.Reason,
		&i.Status,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createDefaultResource = `-- name: CreateDefaultResource :one
INSERT INTO "shared"."resource" ("mime_type", "owner_id", "owner_type", "url", "order")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, mime_type, owner_id, owner_type, url, "order"
`

type CreateDefaultResourceParams struct {
	MimeType  string             `json:"mime_type"`
	OwnerID   int64              `json:"owner_id"`
	OwnerType SharedResourceType `json:"owner_type"`
	Url       string             `json:"url"`
	Order     int32              `json:"order"`
}

func (q *Queries) CreateDefaultResource(ctx context.Context, arg CreateDefaultResourceParams) (SharedResource, error) {
	row := q.db.QueryRow(ctx, createDefaultResource,
		arg.MimeType,
		arg.OwnerID,
		arg.OwnerType,
		arg.Url,
		arg.Order,
	)
	var i SharedResource
	err := row.Scan(
		&i.ID,
		&i.MimeType,
		&i.OwnerID,
		&i.OwnerType,
		&i.Url,
		&i.Order,
	)
	return i, err
}

const createDefaultSearchSync = `-- name: CreateDefaultSearchSync :one
INSERT INTO "system"."search_sync" ("name")
VALUES ($1)
RETURNING id, name, last_synced
`

func (q *Queries) CreateDefaultSearchSync(ctx context.Context, name string) (SystemSearchSync, error) {
	row := q.db.QueryRow(ctx, createDefaultSearchSync, name)
	var i SystemSearchSync
	err := row.Scan(&i.ID, &i.Name, &i.LastSynced)
	return i, err
}

const createDefaultSkuSerial = `-- name: CreateDefaultSkuSerial :one
INSERT INTO "inventory"."sku_serial" ("serial_number", "sku_id", "status")
VALUES ($1, $2, $3)
RETURNING id, serial_number, sku_id, status, date_created
`

type CreateDefaultSkuSerialParams struct {
	SerialNumber string                 `json:"serial_number"`
	SkuID        int64                  `json:"sku_id"`
	Status       InventoryProductStatus `json:"status"`
}

func (q *Queries) CreateDefaultSkuSerial(ctx context.Context, arg CreateDefaultSkuSerialParams) (InventorySkuSerial, error) {
	row := q.db.QueryRow(ctx, createDefaultSkuSerial, arg.SerialNumber, arg.SkuID, arg.Status)
	var i InventorySkuSerial
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SkuID,
		&i.Status,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultStock = `-- name: CreateDefaultStock :one
INSERT INTO "inventory"."stock" ("ref_type", "ref_id")
VALUES ($1, $2)
RETURNING id, ref_type, ref_id, current_stock, sold, date_created
`

type CreateDefaultStockParams struct {
	RefType InventoryStockType `json:"ref_type"`
	RefID   int64              `json:"ref_id"`
}

func (q *Queries) CreateDefaultStock(ctx context.Context, arg CreateDefaultStockParams) (InventoryStock, error) {
	row := q.db.QueryRow(ctx, createDefaultStock, arg.RefType, arg.RefID)
	var i InventoryStock
	err := row.Scan(
		&i.ID,
		&i.RefType,
		&i.RefID,
		&i.CurrentStock,
		&i.Sold,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultStockHistory = `-- name: CreateDefaultStockHistory :one
INSERT INTO "inventory"."stock_history" ("stock_id", "change")
VALUES ($1, $2)
RETURNING id, stock_id, change, date_created
`

type CreateDefaultStockHistoryParams struct {
	StockID int64 `json:"stock_id"`
	Change  int64 `json:"change"`
}

func (q *Queries) CreateDefaultStockHistory(ctx context.Context, arg CreateDefaultStockHistoryParams) (InventoryStockHistory, error) {
	row := q.db.QueryRow(ctx, createDefaultStockHistory, arg.StockID, arg.Change)
	var i InventoryStockHistory
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.Change,
		&i.DateCreated,
	)
	return i, err
}

const createDefaultTag = `-- name: CreateDefaultTag :one
INSERT INTO "catalog"."tag" ("tag")
VALUES ($1)
RETURNING id, tag, description
`

func (q *Queries) CreateDefaultTag(ctx context.Context, tag string) (CatalogTag, error) {
	row := q.db.QueryRow(ctx, createDefaultTag, tag)
	var i CatalogTag
	err := row.Scan(&i.ID, &i.Tag, &i.Description)
	return i, err
}

const createDefaultVendor = `-- name: CreateDefaultVendor :one
INSERT INTO "account"."vendor" ("account_id")
VALUES ($1)
RETURNING id, account_id
`

func (q *Queries) CreateDefaultVendor(ctx context.Context, accountID int64) (AccountVendor, error) {
	row := q.db.QueryRow(ctx, createDefaultVendor, accountID)
	var i AccountVendor
	err := row.Scan(&i.ID, &i.AccountID)
	return i, err
}

const createDefaultVnpay = `-- name: CreateDefaultVnpay :one
INSERT INTO "payment"."vnpay" ("order_id", "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, order_id, "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef"
`

type CreateDefaultVnpayParams struct {
	OrderID              int64  `json:"order_id"`
	VnpAmount            string `json:"vnp_Amount"`
	VnpBankCode          string `json:"vnp_BankCode"`
	VnpCardType          string `json:"vnp_CardType"`
	VnpOrderInfo         string `json:"vnp_OrderInfo"`
	VnpPayDate           string `json:"vnp_PayDate"`
	VnpResponseCode      string `json:"vnp_ResponseCode"`
	VnpSecureHash        string `json:"vnp_SecureHash"`
	VnpTmnCode           string `json:"vnp_TmnCode"`
	VnpTransactionNo     string `json:"vnp_TransactionNo"`
	VnpTransactionStatus string `json:"vnp_TransactionStatus"`
	VnpTxnRef            string `json:"vnp_TxnRef"`
}

func (q *Queries) CreateDefaultVnpay(ctx context.Context, arg CreateDefaultVnpayParams) (PaymentVnpay, error) {
	row := q.db.QueryRow(ctx, createDefaultVnpay,
		arg.OrderID,
		arg.VnpAmount,
		arg.VnpBankCode,
		arg.VnpCardType,
		arg.VnpOrderInfo,
		arg.VnpPayDate,
		arg.VnpResponseCode,
		arg.VnpSecureHash,
		arg.VnpTmnCode,
		arg.VnpTransactionNo,
		arg.VnpTransactionStatus,
		arg.VnpTxnRef,
	)
	var i PaymentVnpay
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VnpAmount,
		&i.VnpBankCode,
		&i.VnpCardType,
		&i.VnpOrderInfo,
		&i.VnpPayDate,
		&i.VnpResponseCode,
		&i.VnpSecureHash,
		&i.VnpTmnCode,
		&i.VnpTransactionNo,
		&i.VnpTransactionStatus,
		&i.VnpTxnRef,
	)
	return i, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO "system"."event" ("account_id", "aggregate_id", "aggregate_type", "event_type", "payload", "version", "date_created")
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, account_id, aggregate_id, aggregate_type, event_type, payload, version, date_created
`

type CreateEventParams struct {
	AccountID     pgtype.Int8        `json:"account_id"`
	AggregateID   int64              `json:"aggregate_id"`
	AggregateType string             `json:"aggregate_type"`
	EventType     SystemEventType    `json:"event_type"`
	Payload       []byte             `json:"payload"`
	Version       int64              `json:"version"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (SystemEvent, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.AccountID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Payload,
		arg.Version,
		arg.DateCreated,
	)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.Payload,
		&i.Version,
		&i.DateCreated,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO "payment"."invoice" ("code", "type", "ref_type", "ref_id", "seller_account_id", "buyer_account_id", "status", "payment_method", "address", "phone", "subtotal", "total", "file_rs_id", "date_created", "hash", "prev_hash")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, code, type, ref_type, ref_id, seller_account_id, buyer_account_id, status, payment_method, address, phone, subtotal, total, file_rs_id, date_created, hash, prev_hash
`

type CreateInvoiceParams struct {
	Code            string                `json:"code"`
	Type            PaymentInvoiceType    `json:"type"`
	RefType         PaymentInvoiceRefType `json:"ref_type"`
	RefID           int64                 `json:"ref_id"`
	SellerAccountID pgtype.Int8           `json:"seller_account_id"`
	BuyerAccountID  int64                 `json:"buyer_account_id"`
	Status          SharedStatus          `json:"status"`
	PaymentMethod   PaymentPaymentMethod  `json:"payment_method"`
	Address         string                `json:"address"`
	Phone           string                `json:"phone"`
	Subtotal        int64                 `json:"subtotal"`
	Total           int64                 `json:"total"`
	FileRsID        string                `json:"file_rs_id"`
	DateCreated     pgtype.Timestamptz    `json:"date_created"`
	Hash            []byte                `json:"hash"`
	PrevHash        []byte                `json:"prev_hash"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (PaymentInvoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.Code,
		arg.Type,
		arg.RefType,
		arg.RefID,
		arg.SellerAccountID,
		arg.BuyerAccountID,
		arg.Status,
		arg.PaymentMethod,
		arg.Address,
		arg.Phone,
		arg.Subtotal,
		arg.Total,
		arg.FileRsID,
		arg.DateCreated,
		arg.Hash,
		arg.PrevHash,
	)
	var i PaymentInvoice
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.RefType,
		&i.RefID,
		&i.SellerAccountID,
		&i.BuyerAccountID,
		&i.Status,
		&i.PaymentMethod,
		&i.Address,
		&i.Phone,
		&i.Subtotal,
		&i.Total,
		&i.FileRsID,
		&i.DateCreated,
		&i.Hash,
		&i.PrevHash,
	)
	return i, err
}

const createInvoiceItem = `-- name: CreateInvoiceItem :one
INSERT INTO "payment"."invoice_item" ("invoice_id", "snapshot", "quantity", "unit_price", "subtotal", "total")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, invoice_id, snapshot, quantity, unit_price, subtotal, total
`

type CreateInvoiceItemParams struct {
	InvoiceID int64  `json:"invoice_id"`
	Snapshot  []byte `json:"snapshot"`
	Quantity  int64  `json:"quantity"`
	UnitPrice int64  `json:"unit_price"`
	Subtotal  int64  `json:"subtotal"`
	Total     int64  `json:"total"`
}

func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) (PaymentInvoiceItem, error) {
	row := q.db.QueryRow(ctx, createInvoiceItem,
		arg.InvoiceID,
		arg.Snapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
		arg.Total,
	)
	var i PaymentInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Snapshot,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Total,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO "payment"."order" ("code", "customer_id", "payment_method", "status", "address", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, code, customer_id, payment_method, status, address, date_created, date_updated
`

type CreateOrderParams struct {
	Code          string               `json:"code"`
	CustomerID    int64                `json:"customer_id"`
	PaymentMethod PaymentPaymentMethod `json:"payment_method"`
	Status        SharedStatus         `json:"status"`
	Address       string               `json:"address"`
	DateCreated   pgtype.Timestamptz   `json:"date_created"`
	DateUpdated   pgtype.Timestamptz   `json:"date_updated"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.Code,
		arg.CustomerID,
		arg.PaymentMethod,
		arg.Status,
		arg.Address,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CustomerID,
		&i.PaymentMethod,
		&i.Status,
		&i.Address,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO "payment"."order_item" ("code", "order_id", "sku_id", "quantity")
VALUES ($1, $2, $3, $4)
RETURNING id, code, order_id, sku_id, quantity
`

type CreateOrderItemParams struct {
	Code     string `json:"code"`
	OrderID  int64  `json:"order_id"`
	SkuID    int64  `json:"sku_id"`
	Quantity int64  `json:"quantity"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (PaymentOrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.Code,
		arg.OrderID,
		arg.SkuID,
		arg.Quantity,
	)
	var i PaymentOrderItem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderID,
		&i.SkuID,
		&i.Quantity,
	)
	return i, err
}

const createOrderItemSerial = `-- name: CreateOrderItemSerial :one
INSERT INTO "payment"."order_item_serial" ("order_item_id", "product_serial_id")
VALUES ($1, $2)
RETURNING id, order_item_id, product_serial_id
`

type CreateOrderItemSerialParams struct {
	OrderItemID     int64 `json:"order_item_id"`
	ProductSerialID int64 `json:"product_serial_id"`
}

func (q *Queries) CreateOrderItemSerial(ctx context.Context, arg CreateOrderItemSerialParams) (PaymentOrderItemSerial, error) {
	row := q.db.QueryRow(ctx, createOrderItemSerial, arg.OrderItemID, arg.ProductSerialID)
	var i PaymentOrderItemSerial
	err := row.Scan(&i.ID, &i.OrderItemID, &i.ProductSerialID)
	return i, err
}

const createProductSku = `-- name: CreateProductSku :one
INSERT INTO "catalog"."product_sku" ("code", "spu_id", "price", "can_combine", "date_created", "date_deleted")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, code, spu_id, price, can_combine, date_created, date_deleted
`

type CreateProductSkuParams struct {
	Code        string             `json:"code"`
	SpuID       int64              `json:"spu_id"`
	Price       int64              `json:"price"`
	CanCombine  bool               `json:"can_combine"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CreateProductSku(ctx context.Context, arg CreateProductSkuParams) (CatalogProductSku, error) {
	row := q.db.QueryRow(ctx, createProductSku,
		arg.Code,
		arg.SpuID,
		arg.Price,
		arg.CanCombine,
		arg.DateCreated,
		arg.DateDeleted,
	)
	var i CatalogProductSku
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SpuID,
		&i.Price,
		&i.CanCombine,
		&i.DateCreated,
		&i.DateDeleted,
	)
	return i, err
}

const createProductSkuAttribute = `-- name: CreateProductSkuAttribute :one
INSERT INTO "catalog"."product_sku_attribute" ("code", "sku_id", "name", "value", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, code, sku_id, name, value, date_created, date_updated
`

type CreateProductSkuAttributeParams struct {
	Code        string             `json:"code"`
	SkuID       int64              `json:"sku_id"`
	Name        string             `json:"name"`
	Value       string             `json:"value"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateProductSkuAttribute(ctx context.Context, arg CreateProductSkuAttributeParams) (CatalogProductSkuAttribute, error) {
	row := q.db.QueryRow(ctx, createProductSkuAttribute,
		arg.Code,
		arg.SkuID,
		arg.Name,
		arg.Value,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i CatalogProductSkuAttribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SkuID,
		&i.Name,
		&i.Value,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createProductSpu = `-- name: CreateProductSpu :one
INSERT INTO "catalog"."product_spu" ("code", "account_id", "category_id", "brand_id", "name", "description", "is_active", "date_manufactured", "date_created", "date_updated", "date_deleted")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, code, account_id, category_id, brand_id, name, description, is_active, date_manufactured, date_created, date_updated, date_deleted
`

type CreateProductSpuParams struct {
	Code             string             `json:"code"`
	AccountID        int64              `json:"account_id"`
	CategoryID       int64              `json:"category_id"`
	BrandID          int64              `json:"brand_id"`
	Name             string             `json:"name"`
	Description      string             `json:"description"`
	IsActive         bool               `json:"is_active"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) CreateProductSpu(ctx context.Context, arg CreateProductSpuParams) (CatalogProductSpu, error) {
	row := q.db.QueryRow(ctx, createProductSpu,
		arg.Code,
		arg.AccountID,
		arg.CategoryID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.DateManufactured,
		arg.DateCreated,
		arg.DateUpdated,
		arg.DateDeleted,
	)
	var i CatalogProductSpu
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.CategoryID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.DateManufactured,
		&i.DateCreated,
		&i.DateUpdated,
		&i.DateDeleted,
	)
	return i, err
}

const createProductSpuTag = `-- name: CreateProductSpuTag :one
INSERT INTO "catalog"."product_spu_tag" ("spu_id", "tag_id")
VALUES ($1, $2)
RETURNING id, spu_id, tag_id
`

type CreateProductSpuTagParams struct {
	SpuID int64 `json:"spu_id"`
	TagID int64 `json:"tag_id"`
}

func (q *Queries) CreateProductSpuTag(ctx context.Context, arg CreateProductSpuTagParams) (CatalogProductSpuTag, error) {
	row := q.db.QueryRow(ctx, createProductSpuTag, arg.SpuID, arg.TagID)
	var i CatalogProductSpuTag
	err := row.Scan(&i.ID, &i.SpuID, &i.TagID)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO "account"."profile" ("account_id", "gender", "name", "date_of_birth", "avatar_rs_id", "email_verified", "phone_verified", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, account_id, gender, name, date_of_birth, avatar_rs_id, email_verified, phone_verified, date_created, date_updated
`

type CreateProfileParams struct {
	AccountID     int64              `json:"account_id"`
	Gender        NullAccountGender  `json:"gender"`
	Name          pgtype.Text        `json:"name"`
	DateOfBirth   pgtype.Date        `json:"date_of_birth"`
	AvatarRsID    pgtype.Int8        `json:"avatar_rs_id"`
	EmailVerified bool               `json:"email_verified"`
	PhoneVerified bool               `json:"phone_verified"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (AccountProfile, error) {
	row := q.db.QueryRow(ctx, createProfile,
		arg.AccountID,
		arg.Gender,
		arg.Name,
		arg.DateOfBirth,
		arg.AvatarRsID,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountProfile
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Gender,
		&i.Name,
		&i.DateOfBirth,
		&i.AvatarRsID,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createPromotion = `-- name: CreatePromotion :one
INSERT INTO "promotion"."promotion" ("code", "type", "is_active", "date_started", "date_ended", "date_created")
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, code, type, is_active, date_started, date_ended, date_created
`

type CreatePromotionParams struct {
	Code        string                 `json:"code"`
	Type        PromotionPromotionType `json:"type"`
	IsActive    bool                   `json:"is_active"`
	DateStarted pgtype.Timestamptz     `json:"date_started"`
	DateEnded   pgtype.Timestamptz     `json:"date_ended"`
	DateCreated pgtype.Timestamptz     `json:"date_created"`
}

func (q *Queries) CreatePromotion(ctx context.Context, arg CreatePromotionParams) (PromotionPromotion, error) {
	row := q.db.QueryRow(ctx, createPromotion,
		arg.Code,
		arg.Type,
		arg.IsActive,
		arg.DateStarted,
		arg.DateEnded,
		arg.DateCreated,
	)
	var i PromotionPromotion
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.IsActive,
		&i.DateStarted,
		&i.DateEnded,
		&i.DateCreated,
	)
	return i, err
}

const createPromotionRedemption = `-- name: CreatePromotionRedemption :one
INSERT INTO "promotion"."promotion_redemption" ("promotion_id", "version", "ref_type", "ref_id", "date_created")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, promotion_id, version, ref_type, ref_id, date_created
`

type CreatePromotionRedemptionParams struct {
	PromotionID int64                     `json:"promotion_id"`
	Version     int64                     `json:"version"`
	RefType     PromotionPromotionRefType `json:"ref_type"`
	RefID       int64                     `json:"ref_id"`
	DateCreated pgtype.Timestamptz        `json:"date_created"`
}

func (q *Queries) CreatePromotionRedemption(ctx context.Context, arg CreatePromotionRedemptionParams) (PromotionPromotionRedemption, error) {
	row := q.db.QueryRow(ctx, createPromotionRedemption,
		arg.PromotionID,
		arg.Version,
		arg.RefType,
		arg.RefID,
		arg.DateCreated,
	)
	var i PromotionPromotionRedemption
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.Version,
		&i.RefType,
		&i.RefID,
		&i.DateCreated,
	)
	return i, err
}

const createPromotionVoucher = `-- name: CreatePromotionVoucher :one
INSERT INTO "promotion"."promotion_voucher" ("promotion_id", "min_spend", "max_discount", "discount_percent", "discount_price")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, promotion_id, min_spend, max_discount, discount_percent, discount_price
`

type CreatePromotionVoucherParams struct {
	PromotionID     int64       `json:"promotion_id"`
	MinSpend        int64       `json:"min_spend"`
	MaxDiscount     int64       `json:"max_discount"`
	DiscountPercent pgtype.Int4 `json:"discount_percent"`
	DiscountPrice   pgtype.Int8 `json:"discount_price"`
}

func (q *Queries) CreatePromotionVoucher(ctx context.Context, arg CreatePromotionVoucherParams) (PromotionPromotionVoucher, error) {
	row := q.db.QueryRow(ctx, createPromotionVoucher,
		arg.PromotionID,
		arg.MinSpend,
		arg.MaxDiscount,
		arg.DiscountPercent,
		arg.DiscountPrice,
	)
	var i PromotionPromotionVoucher
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.MinSpend,
		&i.MaxDiscount,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO "payment"."refund" ("code", "order_item_id", "reviewed_by_id", "method", "status", "reason", "address", "date_created")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, code, order_item_id, reviewed_by_id, method, status, reason, address, date_created
`

type CreateRefundParams struct {
	Code         string              `json:"code"`
	OrderItemID  int64               `json:"order_item_id"`
	ReviewedByID pgtype.Int8         `json:"reviewed_by_id"`
	Method       PaymentRefundMethod `json:"method"`
	Status       SharedStatus        `json:"status"`
	Reason       string              `json:"reason"`
	Address      pgtype.Text         `json:"address"`
	DateCreated  pgtype.Timestamptz  `json:"date_created"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (PaymentRefund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.Code,
		arg.OrderItemID,
		arg.ReviewedByID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.DateCreated,
	)
	var i PaymentRefund
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderItemID,
		&i.ReviewedByID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.DateCreated,
	)
	return i, err
}

const createRefundDispute = `-- name: CreateRefundDispute :one
INSERT INTO "payment"."refund_dispute" ("code", "refund_id", "vendor_id", "reason", "status", "date_created", "date_updated")
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, code, refund_id, vendor_id, reason, status, date_created, date_updated
`

type CreateRefundDisputeParams struct {
	Code        string             `json:"code"`
	RefundID    int64              `json:"refund_id"`
	VendorID    int64              `json:"vendor_id"`
	Reason      string             `json:"reason"`
	Status      SharedStatus       `json:"status"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) CreateRefundDispute(ctx context.Context, arg CreateRefundDisputeParams) (PaymentRefundDispute, error) {
	row := q.db.QueryRow(ctx, createRefundDispute,
		arg.Code,
		arg.RefundID,
		arg.VendorID,
		arg.Reason,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i PaymentRefundDispute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.RefundID,
		&i.VendorID,
		&i.Reason,
		&i.Status,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const createResource = `-- name: CreateResource :one
INSERT INTO "shared"."resource" ("mime_type", "owner_id", "owner_type", "url", "order")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, mime_type, owner_id, owner_type, url, "order"
`

type CreateResourceParams struct {
	MimeType  string             `json:"mime_type"`
	OwnerID   int64              `json:"owner_id"`
	OwnerType SharedResourceType `json:"owner_type"`
	Url       string             `json:"url"`
	Order     int32              `json:"order"`
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (SharedResource, error) {
	row := q.db.QueryRow(ctx, createResource,
		arg.MimeType,
		arg.OwnerID,
		arg.OwnerType,
		arg.Url,
		arg.Order,
	)
	var i SharedResource
	err := row.Scan(
		&i.ID,
		&i.MimeType,
		&i.OwnerID,
		&i.OwnerType,
		&i.Url,
		&i.Order,
	)
	return i, err
}

const createSearchSync = `-- name: CreateSearchSync :one
INSERT INTO "system"."search_sync" ("name", "last_synced")
VALUES ($1, $2)
RETURNING id, name, last_synced
`

type CreateSearchSyncParams struct {
	Name       string             `json:"name"`
	LastSynced pgtype.Timestamptz `json:"last_synced"`
}

func (q *Queries) CreateSearchSync(ctx context.Context, arg CreateSearchSyncParams) (SystemSearchSync, error) {
	row := q.db.QueryRow(ctx, createSearchSync, arg.Name, arg.LastSynced)
	var i SystemSearchSync
	err := row.Scan(&i.ID, &i.Name, &i.LastSynced)
	return i, err
}

const createSkuSerial = `-- name: CreateSkuSerial :one
INSERT INTO "inventory"."sku_serial" ("serial_number", "sku_id", "status", "date_created")
VALUES ($1, $2, $3, $4)
RETURNING id, serial_number, sku_id, status, date_created
`

type CreateSkuSerialParams struct {
	SerialNumber string                 `json:"serial_number"`
	SkuID        int64                  `json:"sku_id"`
	Status       InventoryProductStatus `json:"status"`
	DateCreated  pgtype.Timestamptz     `json:"date_created"`
}

func (q *Queries) CreateSkuSerial(ctx context.Context, arg CreateSkuSerialParams) (InventorySkuSerial, error) {
	row := q.db.QueryRow(ctx, createSkuSerial,
		arg.SerialNumber,
		arg.SkuID,
		arg.Status,
		arg.DateCreated,
	)
	var i InventorySkuSerial
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SkuID,
		&i.Status,
		&i.DateCreated,
	)
	return i, err
}

const createStock = `-- name: CreateStock :one
INSERT INTO "inventory"."stock" ("ref_type", "ref_id", "current_stock", "sold", "date_created")
VALUES ($1, $2, $3, $4, $5)
RETURNING id, ref_type, ref_id, current_stock, sold, date_created
`

type CreateStockParams struct {
	RefType      InventoryStockType `json:"ref_type"`
	RefID        int64              `json:"ref_id"`
	CurrentStock int64              `json:"current_stock"`
	Sold         int64              `json:"sold"`
	DateCreated  pgtype.Timestamptz `json:"date_created"`
}

func (q *Queries) CreateStock(ctx context.Context, arg CreateStockParams) (InventoryStock, error) {
	row := q.db.QueryRow(ctx, createStock,
		arg.RefType,
		arg.RefID,
		arg.CurrentStock,
		arg.Sold,
		arg.DateCreated,
	)
	var i InventoryStock
	err := row.Scan(
		&i.ID,
		&i.RefType,
		&i.RefID,
		&i.CurrentStock,
		&i.Sold,
		&i.DateCreated,
	)
	return i, err
}

const createStockHistory = `-- name: CreateStockHistory :one
INSERT INTO "inventory"."stock_history" ("stock_id", "change", "date_created")
VALUES ($1, $2, $3)
RETURNING id, stock_id, change, date_created
`

type CreateStockHistoryParams struct {
	StockID     int64              `json:"stock_id"`
	Change      int64              `json:"change"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

func (q *Queries) CreateStockHistory(ctx context.Context, arg CreateStockHistoryParams) (InventoryStockHistory, error) {
	row := q.db.QueryRow(ctx, createStockHistory, arg.StockID, arg.Change, arg.DateCreated)
	var i InventoryStockHistory
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.Change,
		&i.DateCreated,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO "catalog"."tag" ("tag", "description")
VALUES ($1, $2)
RETURNING id, tag, description
`

type CreateTagParams struct {
	Tag         string `json:"tag"`
	Description string `json:"description"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (CatalogTag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.Tag, arg.Description)
	var i CatalogTag
	err := row.Scan(&i.ID, &i.Tag, &i.Description)
	return i, err
}

const createVendor = `-- name: CreateVendor :one
INSERT INTO "account"."vendor" ("account_id")
VALUES ($1)
RETURNING id, account_id
`

func (q *Queries) CreateVendor(ctx context.Context, accountID int64) (AccountVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, accountID)
	var i AccountVendor
	err := row.Scan(&i.ID, &i.AccountID)
	return i, err
}

const createVnpay = `-- name: CreateVnpay :one
INSERT INTO "payment"."vnpay" ("order_id", "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, order_id, "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef"
`

type CreateVnpayParams struct {
	OrderID              int64  `json:"order_id"`
	VnpAmount            string `json:"vnp_Amount"`
	VnpBankCode          string `json:"vnp_BankCode"`
	VnpCardType          string `json:"vnp_CardType"`
	VnpOrderInfo         string `json:"vnp_OrderInfo"`
	VnpPayDate           string `json:"vnp_PayDate"`
	VnpResponseCode      string `json:"vnp_ResponseCode"`
	VnpSecureHash        string `json:"vnp_SecureHash"`
	VnpTmnCode           string `json:"vnp_TmnCode"`
	VnpTransactionNo     string `json:"vnp_TransactionNo"`
	VnpTransactionStatus string `json:"vnp_TransactionStatus"`
	VnpTxnRef            string `json:"vnp_TxnRef"`
}

func (q *Queries) CreateVnpay(ctx context.Context, arg CreateVnpayParams) (PaymentVnpay, error) {
	row := q.db.QueryRow(ctx, createVnpay,
		arg.OrderID,
		arg.VnpAmount,
		arg.VnpBankCode,
		arg.VnpCardType,
		arg.VnpOrderInfo,
		arg.VnpPayDate,
		arg.VnpResponseCode,
		arg.VnpSecureHash,
		arg.VnpTmnCode,
		arg.VnpTransactionNo,
		arg.VnpTransactionStatus,
		arg.VnpTxnRef,
	)
	var i PaymentVnpay
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VnpAmount,
		&i.VnpBankCode,
		&i.VnpCardType,
		&i.VnpOrderInfo,
		&i.VnpPayDate,
		&i.VnpResponseCode,
		&i.VnpSecureHash,
		&i.VnpTmnCode,
		&i.VnpTransactionNo,
		&i.VnpTransactionStatus,
		&i.VnpTxnRef,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM "account"."account"
WHERE ("id" = $1) OR ("code" = $2) OR ("phone" = $3) OR ("email" = $4) OR ("username" = $5)
`

type DeleteAccountParams struct {
	ID       int64       `json:"id"`
	Code     string      `json:"code"`
	Phone    pgtype.Text `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Username pgtype.Text `json:"username"`
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) error {
	_, err := q.db.Exec(ctx, deleteAccount,
		arg.ID,
		arg.Code,
		arg.Phone,
		arg.Email,
		arg.Username,
	)
	return err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM "account"."address"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteAddressParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteAddress(ctx context.Context, arg DeleteAddressParams) error {
	_, err := q.db.Exec(ctx, deleteAddress, arg.ID, arg.Code)
	return err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM "catalog"."brand"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteBrandParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteBrand(ctx context.Context, arg DeleteBrandParams) error {
	_, err := q.db.Exec(ctx, deleteBrand, arg.ID, arg.Code)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM "account"."cart_item"
WHERE ("id" = $1) OR ("cart_id" = $2 AND "sku_id" = $3)
`

type DeleteCartItemParams struct {
	ID     int64 `json:"id"`
	CartID int64 `json:"cart_id"`
	SkuID  int64 `json:"sku_id"`
}

func (q *Queries) DeleteCartItem(ctx context.Context, arg DeleteCartItemParams) error {
	_, err := q.db.Exec(ctx, deleteCartItem, arg.ID, arg.CartID, arg.SkuID)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM "catalog"."category"
WHERE ("id" = $1) OR ("name" = $2)
`

type DeleteCategoryParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.Exec(ctx, deleteCategory, arg.ID, arg.Name)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM "catalog"."comment"
WHERE ("id" = $1) OR ("code" = $2) OR ("account_id" = $3 AND "ref_type" = $4 AND "ref_id" = $5)
`

type DeleteCommentParams struct {
	ID        int64                  `json:"id"`
	Code      string                 `json:"code"`
	AccountID int64                  `json:"account_id"`
	RefType   CatalogCommentDestType `json:"ref_type"`
	RefID     int64                  `json:"ref_id"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
	)
	return err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM "account"."customer"
WHERE ("id" = $1) OR ("account_id" = $2)
`

type DeleteCustomerParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteCustomer(ctx context.Context, arg DeleteCustomerParams) error {
	_, err := q.db.Exec(ctx, deleteCustomer, arg.ID, arg.AccountID)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM "system"."event"
WHERE ("id" = $1)
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM "payment"."invoice"
WHERE ("id" = $1) OR ("code" = $2) OR ("hash" = $3)
`

type DeleteInvoiceParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
	Hash []byte `json:"hash"`
}

func (q *Queries) DeleteInvoice(ctx context.Context, arg DeleteInvoiceParams) error {
	_, err := q.db.Exec(ctx, deleteInvoice, arg.ID, arg.Code, arg.Hash)
	return err
}

const deleteInvoiceItem = `-- name: DeleteInvoiceItem :exec
DELETE FROM "payment"."invoice_item"
WHERE ("id" = $1)
`

func (q *Queries) DeleteInvoiceItem(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteInvoiceItem, id)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM "payment"."order"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteOrderParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteOrder(ctx context.Context, arg DeleteOrderParams) error {
	_, err := q.db.Exec(ctx, deleteOrder, arg.ID, arg.Code)
	return err
}

const deleteOrderItem = `-- name: DeleteOrderItem :exec
DELETE FROM "payment"."order_item"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteOrderItemParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteOrderItem(ctx context.Context, arg DeleteOrderItemParams) error {
	_, err := q.db.Exec(ctx, deleteOrderItem, arg.ID, arg.Code)
	return err
}

const deleteOrderItemSerial = `-- name: DeleteOrderItemSerial :exec
DELETE FROM "payment"."order_item_serial"
WHERE ("id" = $1) OR ("order_item_id" = $2 AND "product_serial_id" = $3)
`

type DeleteOrderItemSerialParams struct {
	ID              int64 `json:"id"`
	OrderItemID     int64 `json:"order_item_id"`
	ProductSerialID int64 `json:"product_serial_id"`
}

func (q *Queries) DeleteOrderItemSerial(ctx context.Context, arg DeleteOrderItemSerialParams) error {
	_, err := q.db.Exec(ctx, deleteOrderItemSerial, arg.ID, arg.OrderItemID, arg.ProductSerialID)
	return err
}

const deleteProductSku = `-- name: DeleteProductSku :exec
DELETE FROM "catalog"."product_sku"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteProductSkuParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteProductSku(ctx context.Context, arg DeleteProductSkuParams) error {
	_, err := q.db.Exec(ctx, deleteProductSku, arg.ID, arg.Code)
	return err
}

const deleteProductSkuAttribute = `-- name: DeleteProductSkuAttribute :exec
DELETE FROM "catalog"."product_sku_attribute"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteProductSkuAttributeParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteProductSkuAttribute(ctx context.Context, arg DeleteProductSkuAttributeParams) error {
	_, err := q.db.Exec(ctx, deleteProductSkuAttribute, arg.ID, arg.Code)
	return err
}

const deleteProductSpu = `-- name: DeleteProductSpu :exec
DELETE FROM "catalog"."product_spu"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteProductSpuParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteProductSpu(ctx context.Context, arg DeleteProductSpuParams) error {
	_, err := q.db.Exec(ctx, deleteProductSpu, arg.ID, arg.Code)
	return err
}

const deleteProductSpuTag = `-- name: DeleteProductSpuTag :exec
DELETE FROM "catalog"."product_spu_tag"
WHERE ("id" = $1) OR ("spu_id" = $2 AND "tag_id" = $3)
`

type DeleteProductSpuTagParams struct {
	ID    int64 `json:"id"`
	SpuID int64 `json:"spu_id"`
	TagID int64 `json:"tag_id"`
}

func (q *Queries) DeleteProductSpuTag(ctx context.Context, arg DeleteProductSpuTagParams) error {
	_, err := q.db.Exec(ctx, deleteProductSpuTag, arg.ID, arg.SpuID, arg.TagID)
	return err
}

const deleteProfile = `-- name: DeleteProfile :exec
DELETE FROM "account"."profile"
WHERE ("id" = $1) OR ("account_id" = $2) OR ("avatar_rs_id" = $3)
`

type DeleteProfileParams struct {
	ID         int64       `json:"id"`
	AccountID  int64       `json:"account_id"`
	AvatarRsID pgtype.Int8 `json:"avatar_rs_id"`
}

func (q *Queries) DeleteProfile(ctx context.Context, arg DeleteProfileParams) error {
	_, err := q.db.Exec(ctx, deleteProfile, arg.ID, arg.AccountID, arg.AvatarRsID)
	return err
}

const deletePromotion = `-- name: DeletePromotion :exec
DELETE FROM "promotion"."promotion"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeletePromotionParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeletePromotion(ctx context.Context, arg DeletePromotionParams) error {
	_, err := q.db.Exec(ctx, deletePromotion, arg.ID, arg.Code)
	return err
}

const deletePromotionRedemption = `-- name: DeletePromotionRedemption :exec
DELETE FROM "promotion"."promotion_redemption"
WHERE ("id" = $1)
`

func (q *Queries) DeletePromotionRedemption(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePromotionRedemption, id)
	return err
}

const deletePromotionVoucher = `-- name: DeletePromotionVoucher :exec
DELETE FROM "promotion"."promotion_voucher"
WHERE ("id" = $1) OR ("promotion_id" = $2)
`

type DeletePromotionVoucherParams struct {
	ID          int64 `json:"id"`
	PromotionID int64 `json:"promotion_id"`
}

func (q *Queries) DeletePromotionVoucher(ctx context.Context, arg DeletePromotionVoucherParams) error {
	_, err := q.db.Exec(ctx, deletePromotionVoucher, arg.ID, arg.PromotionID)
	return err
}

const deleteRefund = `-- name: DeleteRefund :exec
DELETE FROM "payment"."refund"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteRefundParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteRefund(ctx context.Context, arg DeleteRefundParams) error {
	_, err := q.db.Exec(ctx, deleteRefund, arg.ID, arg.Code)
	return err
}

const deleteRefundDispute = `-- name: DeleteRefundDispute :exec
DELETE FROM "payment"."refund_dispute"
WHERE ("id" = $1) OR ("code" = $2)
`

type DeleteRefundDisputeParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

func (q *Queries) DeleteRefundDispute(ctx context.Context, arg DeleteRefundDisputeParams) error {
	_, err := q.db.Exec(ctx, deleteRefundDispute, arg.ID, arg.Code)
	return err
}

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM "shared"."resource"
WHERE ("id" = $1)
`

func (q *Queries) DeleteResource(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteResource, id)
	return err
}

const deleteSearchSync = `-- name: DeleteSearchSync :exec
DELETE FROM "system"."search_sync"
WHERE ("id" = $1)
`

func (q *Queries) DeleteSearchSync(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSearchSync, id)
	return err
}

const deleteSkuSerial = `-- name: DeleteSkuSerial :exec
DELETE FROM "inventory"."sku_serial"
WHERE ("id" = $1) OR ("serial_number" = $2)
`

type DeleteSkuSerialParams struct {
	ID           int64  `json:"id"`
	SerialNumber string `json:"serial_number"`
}

func (q *Queries) DeleteSkuSerial(ctx context.Context, arg DeleteSkuSerialParams) error {
	_, err := q.db.Exec(ctx, deleteSkuSerial, arg.ID, arg.SerialNumber)
	return err
}

const deleteStock = `-- name: DeleteStock :exec
DELETE FROM "inventory"."stock"
WHERE ("id" = $1) OR ("ref_id" = $2 AND "ref_type" = $3)
`

type DeleteStockParams struct {
	ID      int64              `json:"id"`
	RefID   int64              `json:"ref_id"`
	RefType InventoryStockType `json:"ref_type"`
}

func (q *Queries) DeleteStock(ctx context.Context, arg DeleteStockParams) error {
	_, err := q.db.Exec(ctx, deleteStock, arg.ID, arg.RefID, arg.RefType)
	return err
}

const deleteStockHistory = `-- name: DeleteStockHistory :exec
DELETE FROM "inventory"."stock_history"
WHERE ("id" = $1)
`

func (q *Queries) DeleteStockHistory(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteStockHistory, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM "catalog"."tag"
WHERE ("id" = $1) OR ("tag" = $2)
`

type DeleteTagParams struct {
	ID  int64  `json:"id"`
	Tag string `json:"tag"`
}

func (q *Queries) DeleteTag(ctx context.Context, arg DeleteTagParams) error {
	_, err := q.db.Exec(ctx, deleteTag, arg.ID, arg.Tag)
	return err
}

const deleteVendor = `-- name: DeleteVendor :exec
DELETE FROM "account"."vendor"
WHERE ("id" = $1) OR ("account_id" = $2)
`

type DeleteVendorParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteVendor(ctx context.Context, arg DeleteVendorParams) error {
	_, err := q.db.Exec(ctx, deleteVendor, arg.ID, arg.AccountID)
	return err
}

const deleteVnpay = `-- name: DeleteVnpay :exec
DELETE FROM "payment"."vnpay"
WHERE ("id" = $1) OR ("order_id" = $2)
`

type DeleteVnpayParams struct {
	ID      int64 `json:"id"`
	OrderID int64 `json:"order_id"`
}

func (q *Queries) DeleteVnpay(ctx context.Context, arg DeleteVnpayParams) error {
	_, err := q.db.Exec(ctx, deleteVnpay, arg.ID, arg.OrderID)
	return err
}

const getAccount = `-- name: GetAccount :one





SELECT id, code, type, status, phone, email, username, password, date_created, date_updated
FROM "account"."account"
WHERE ("id" = $1) OR ("code" = $2) OR ("phone" = $3) OR ("email" = $4) OR ("username" = $5)
`

type GetAccountParams struct {
	ID       int64       `json:"id"`
	Code     string      `json:"code"`
	Phone    pgtype.Text `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Username pgtype.Text `json:"username"`
}

// Code generated by tool/main.go. DO NOT EDIT.
// This file contains all queries for the database schema.
// ========================================
// Queries for table: account.account
// ========================================
func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (AccountAccount, error) {
	row := q.db.QueryRow(ctx, getAccount,
		arg.ID,
		arg.Code,
		arg.Phone,
		arg.Email,
		arg.Username,
	)
	var i AccountAccount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Phone,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getAddress = `-- name: GetAddress :one



SELECT id, code, account_id, type, full_name, phone, phone_verified, address_line, city, state_province, country, date_created, date_updated
FROM "account"."address"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetAddressParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: account.address
// ========================================
func (q *Queries) GetAddress(ctx context.Context, arg GetAddressParams) (AccountAddress, error) {
	row := q.db.QueryRow(ctx, getAddress, arg.ID, arg.Code)
	var i AccountAddress
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.Type,
		&i.FullName,
		&i.Phone,
		&i.PhoneVerified,
		&i.AddressLine,
		&i.City,
		&i.StateProvince,
		&i.Country,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getBrand = `-- name: GetBrand :one



SELECT id, code, name, description
FROM "catalog"."brand"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetBrandParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: catalog.brand
// ========================================
func (q *Queries) GetBrand(ctx context.Context, arg GetBrandParams) (CatalogBrand, error) {
	row := q.db.QueryRow(ctx, getBrand, arg.ID, arg.Code)
	var i CatalogBrand
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const getCartItem = `-- name: GetCartItem :one



SELECT id, cart_id, sku_id, quantity, date_created, date_updated
FROM "account"."cart_item"
WHERE ("id" = $1) OR ("cart_id" = $2 AND "sku_id" = $3)
`

type GetCartItemParams struct {
	ID     int64 `json:"id"`
	CartID int64 `json:"cart_id"`
	SkuID  int64 `json:"sku_id"`
}

// ========================================
// Queries for table: account.cart_item
// ========================================
func (q *Queries) GetCartItem(ctx context.Context, arg GetCartItemParams) (AccountCartItem, error) {
	row := q.db.QueryRow(ctx, getCartItem, arg.ID, arg.CartID, arg.SkuID)
	var i AccountCartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.SkuID,
		&i.Quantity,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one



SELECT id, name, description, parent_id
FROM "catalog"."category"
WHERE ("id" = $1) OR ("name" = $2)
`

type GetCategoryParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

// ========================================
// Queries for table: catalog.category
// ========================================
func (q *Queries) GetCategory(ctx context.Context, arg GetCategoryParams) (CatalogCategory, error) {
	row := q.db.QueryRow(ctx, getCategory, arg.ID, arg.Name)
	var i CatalogCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
	)
	return i, err
}

const getComment = `-- name: GetComment :one



SELECT id, code, account_id, ref_type, ref_id, body, upvote, downvote, score, date_created, date_updated
FROM "catalog"."comment"
WHERE ("id" = $1) OR ("code" = $2) OR ("account_id" = $3 AND "ref_type" = $4 AND "ref_id" = $5)
`

type GetCommentParams struct {
	ID        int64                  `json:"id"`
	Code      string                 `json:"code"`
	AccountID int64                  `json:"account_id"`
	RefType   CatalogCommentDestType `json:"ref_type"`
	RefID     int64                  `json:"ref_id"`
}

// ========================================
// Queries for table: catalog.comment
// ========================================
func (q *Queries) GetComment(ctx context.Context, arg GetCommentParams) (CatalogComment, error) {
	row := q.db.QueryRow(ctx, getComment,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
	)
	var i CatalogComment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.RefType,
		&i.RefID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one



SELECT id, account_id, default_address_id, date_created, date_updated
FROM "account"."customer"
WHERE ("id" = $1) OR ("account_id" = $2)
`

type GetCustomerParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
}

// ========================================
// Queries for table: account.customer
// ========================================
func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (AccountCustomer, error) {
	row := q.db.QueryRow(ctx, getCustomer, arg.ID, arg.AccountID)
	var i AccountCustomer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.DefaultAddressID,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one



SELECT id, account_id, aggregate_id, aggregate_type, event_type, payload, version, date_created
FROM "system"."event"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: system.event
// ========================================
func (q *Queries) GetEvent(ctx context.Context, id int64) (SystemEvent, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.Payload,
		&i.Version,
		&i.DateCreated,
	)
	return i, err
}

const getInvoice = `-- name: GetInvoice :one



SELECT id, code, type, ref_type, ref_id, seller_account_id, buyer_account_id, status, payment_method, address, phone, subtotal, total, file_rs_id, date_created, hash, prev_hash
FROM "payment"."invoice"
WHERE ("id" = $1) OR ("code" = $2) OR ("hash" = $3)
`

type GetInvoiceParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
	Hash []byte `json:"hash"`
}

// ========================================
// Queries for table: payment.invoice
// ========================================
func (q *Queries) GetInvoice(ctx context.Context, arg GetInvoiceParams) (PaymentInvoice, error) {
	row := q.db.QueryRow(ctx, getInvoice, arg.ID, arg.Code, arg.Hash)
	var i PaymentInvoice
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.RefType,
		&i.RefID,
		&i.SellerAccountID,
		&i.BuyerAccountID,
		&i.Status,
		&i.PaymentMethod,
		&i.Address,
		&i.Phone,
		&i.Subtotal,
		&i.Total,
		&i.FileRsID,
		&i.DateCreated,
		&i.Hash,
		&i.PrevHash,
	)
	return i, err
}

const getInvoiceItem = `-- name: GetInvoiceItem :one



SELECT id, invoice_id, snapshot, quantity, unit_price, subtotal, total
FROM "payment"."invoice_item"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: payment.invoice_item
// ========================================
func (q *Queries) GetInvoiceItem(ctx context.Context, id int64) (PaymentInvoiceItem, error) {
	row := q.db.QueryRow(ctx, getInvoiceItem, id)
	var i PaymentInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Snapshot,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Total,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one



SELECT id, code, customer_id, payment_method, status, address, date_created, date_updated
FROM "payment"."order"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetOrderParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: payment.order
// ========================================
func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getOrder, arg.ID, arg.Code)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CustomerID,
		&i.PaymentMethod,
		&i.Status,
		&i.Address,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getOrderItem = `-- name: GetOrderItem :one



SELECT id, code, order_id, sku_id, quantity
FROM "payment"."order_item"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetOrderItemParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: payment.order_item
// ========================================
func (q *Queries) GetOrderItem(ctx context.Context, arg GetOrderItemParams) (PaymentOrderItem, error) {
	row := q.db.QueryRow(ctx, getOrderItem, arg.ID, arg.Code)
	var i PaymentOrderItem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderID,
		&i.SkuID,
		&i.Quantity,
	)
	return i, err
}

const getOrderItemSerial = `-- name: GetOrderItemSerial :one



SELECT id, order_item_id, product_serial_id
FROM "payment"."order_item_serial"
WHERE ("id" = $1) OR ("order_item_id" = $2 AND "product_serial_id" = $3)
`

type GetOrderItemSerialParams struct {
	ID              int64 `json:"id"`
	OrderItemID     int64 `json:"order_item_id"`
	ProductSerialID int64 `json:"product_serial_id"`
}

// ========================================
// Queries for table: payment.order_item_serial
// ========================================
func (q *Queries) GetOrderItemSerial(ctx context.Context, arg GetOrderItemSerialParams) (PaymentOrderItemSerial, error) {
	row := q.db.QueryRow(ctx, getOrderItemSerial, arg.ID, arg.OrderItemID, arg.ProductSerialID)
	var i PaymentOrderItemSerial
	err := row.Scan(&i.ID, &i.OrderItemID, &i.ProductSerialID)
	return i, err
}

const getProductSku = `-- name: GetProductSku :one



SELECT id, code, spu_id, price, can_combine, date_created, date_deleted
FROM "catalog"."product_sku"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetProductSkuParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: catalog.product_sku
// ========================================
func (q *Queries) GetProductSku(ctx context.Context, arg GetProductSkuParams) (CatalogProductSku, error) {
	row := q.db.QueryRow(ctx, getProductSku, arg.ID, arg.Code)
	var i CatalogProductSku
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SpuID,
		&i.Price,
		&i.CanCombine,
		&i.DateCreated,
		&i.DateDeleted,
	)
	return i, err
}

const getProductSkuAttribute = `-- name: GetProductSkuAttribute :one



SELECT id, code, sku_id, name, value, date_created, date_updated
FROM "catalog"."product_sku_attribute"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetProductSkuAttributeParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: catalog.product_sku_attribute
// ========================================
func (q *Queries) GetProductSkuAttribute(ctx context.Context, arg GetProductSkuAttributeParams) (CatalogProductSkuAttribute, error) {
	row := q.db.QueryRow(ctx, getProductSkuAttribute, arg.ID, arg.Code)
	var i CatalogProductSkuAttribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SkuID,
		&i.Name,
		&i.Value,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getProductSpu = `-- name: GetProductSpu :one



SELECT id, code, account_id, category_id, brand_id, name, description, is_active, date_manufactured, date_created, date_updated, date_deleted
FROM "catalog"."product_spu"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetProductSpuParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: catalog.product_spu
// ========================================
func (q *Queries) GetProductSpu(ctx context.Context, arg GetProductSpuParams) (CatalogProductSpu, error) {
	row := q.db.QueryRow(ctx, getProductSpu, arg.ID, arg.Code)
	var i CatalogProductSpu
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.CategoryID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.DateManufactured,
		&i.DateCreated,
		&i.DateUpdated,
		&i.DateDeleted,
	)
	return i, err
}

const getProductSpuTag = `-- name: GetProductSpuTag :one



SELECT id, spu_id, tag_id
FROM "catalog"."product_spu_tag"
WHERE ("id" = $1) OR ("spu_id" = $2 AND "tag_id" = $3)
`

type GetProductSpuTagParams struct {
	ID    int64 `json:"id"`
	SpuID int64 `json:"spu_id"`
	TagID int64 `json:"tag_id"`
}

// ========================================
// Queries for table: catalog.product_spu_tag
// ========================================
func (q *Queries) GetProductSpuTag(ctx context.Context, arg GetProductSpuTagParams) (CatalogProductSpuTag, error) {
	row := q.db.QueryRow(ctx, getProductSpuTag, arg.ID, arg.SpuID, arg.TagID)
	var i CatalogProductSpuTag
	err := row.Scan(&i.ID, &i.SpuID, &i.TagID)
	return i, err
}

const getProfile = `-- name: GetProfile :one



SELECT id, account_id, gender, name, date_of_birth, avatar_rs_id, email_verified, phone_verified, date_created, date_updated
FROM "account"."profile"
WHERE ("id" = $1) OR ("account_id" = $2) OR ("avatar_rs_id" = $3)
`

type GetProfileParams struct {
	ID         int64       `json:"id"`
	AccountID  int64       `json:"account_id"`
	AvatarRsID pgtype.Int8 `json:"avatar_rs_id"`
}

// ========================================
// Queries for table: account.profile
// ========================================
func (q *Queries) GetProfile(ctx context.Context, arg GetProfileParams) (AccountProfile, error) {
	row := q.db.QueryRow(ctx, getProfile, arg.ID, arg.AccountID, arg.AvatarRsID)
	var i AccountProfile
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Gender,
		&i.Name,
		&i.DateOfBirth,
		&i.AvatarRsID,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getPromotion = `-- name: GetPromotion :one



SELECT id, code, type, is_active, date_started, date_ended, date_created
FROM "promotion"."promotion"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetPromotionParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: promotion.promotion
// ========================================
func (q *Queries) GetPromotion(ctx context.Context, arg GetPromotionParams) (PromotionPromotion, error) {
	row := q.db.QueryRow(ctx, getPromotion, arg.ID, arg.Code)
	var i PromotionPromotion
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.IsActive,
		&i.DateStarted,
		&i.DateEnded,
		&i.DateCreated,
	)
	return i, err
}

const getPromotionRedemption = `-- name: GetPromotionRedemption :one



SELECT id, promotion_id, version, ref_type, ref_id, date_created
FROM "promotion"."promotion_redemption"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: promotion.promotion_redemption
// ========================================
func (q *Queries) GetPromotionRedemption(ctx context.Context, id int64) (PromotionPromotionRedemption, error) {
	row := q.db.QueryRow(ctx, getPromotionRedemption, id)
	var i PromotionPromotionRedemption
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.Version,
		&i.RefType,
		&i.RefID,
		&i.DateCreated,
	)
	return i, err
}

const getPromotionVoucher = `-- name: GetPromotionVoucher :one



SELECT id, promotion_id, min_spend, max_discount, discount_percent, discount_price
FROM "promotion"."promotion_voucher"
WHERE ("id" = $1) OR ("promotion_id" = $2)
`

type GetPromotionVoucherParams struct {
	ID          int64 `json:"id"`
	PromotionID int64 `json:"promotion_id"`
}

// ========================================
// Queries for table: promotion.promotion_voucher
// ========================================
func (q *Queries) GetPromotionVoucher(ctx context.Context, arg GetPromotionVoucherParams) (PromotionPromotionVoucher, error) {
	row := q.db.QueryRow(ctx, getPromotionVoucher, arg.ID, arg.PromotionID)
	var i PromotionPromotionVoucher
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.MinSpend,
		&i.MaxDiscount,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const getRefund = `-- name: GetRefund :one



SELECT id, code, order_item_id, reviewed_by_id, method, status, reason, address, date_created
FROM "payment"."refund"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetRefundParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: payment.refund
// ========================================
func (q *Queries) GetRefund(ctx context.Context, arg GetRefundParams) (PaymentRefund, error) {
	row := q.db.QueryRow(ctx, getRefund, arg.ID, arg.Code)
	var i PaymentRefund
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderItemID,
		&i.ReviewedByID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.DateCreated,
	)
	return i, err
}

const getRefundDispute = `-- name: GetRefundDispute :one



SELECT id, code, refund_id, vendor_id, reason, status, date_created, date_updated
FROM "payment"."refund_dispute"
WHERE ("id" = $1) OR ("code" = $2)
`

type GetRefundDisputeParams struct {
	ID   int64  `json:"id"`
	Code string `json:"code"`
}

// ========================================
// Queries for table: payment.refund_dispute
// ========================================
func (q *Queries) GetRefundDispute(ctx context.Context, arg GetRefundDisputeParams) (PaymentRefundDispute, error) {
	row := q.db.QueryRow(ctx, getRefundDispute, arg.ID, arg.Code)
	var i PaymentRefundDispute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.RefundID,
		&i.VendorID,
		&i.Reason,
		&i.Status,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const getResource = `-- name: GetResource :one



SELECT id, mime_type, owner_id, owner_type, url, "order"
FROM "shared"."resource"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: shared.resource
// ========================================
func (q *Queries) GetResource(ctx context.Context, id int64) (SharedResource, error) {
	row := q.db.QueryRow(ctx, getResource, id)
	var i SharedResource
	err := row.Scan(
		&i.ID,
		&i.MimeType,
		&i.OwnerID,
		&i.OwnerType,
		&i.Url,
		&i.Order,
	)
	return i, err
}

const getSearchSync = `-- name: GetSearchSync :one



SELECT id, name, last_synced
FROM "system"."search_sync"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: system.search_sync
// ========================================
func (q *Queries) GetSearchSync(ctx context.Context, id int64) (SystemSearchSync, error) {
	row := q.db.QueryRow(ctx, getSearchSync, id)
	var i SystemSearchSync
	err := row.Scan(&i.ID, &i.Name, &i.LastSynced)
	return i, err
}

const getSkuSerial = `-- name: GetSkuSerial :one



SELECT id, serial_number, sku_id, status, date_created
FROM "inventory"."sku_serial"
WHERE ("id" = $1) OR ("serial_number" = $2)
`

type GetSkuSerialParams struct {
	ID           int64  `json:"id"`
	SerialNumber string `json:"serial_number"`
}

// ========================================
// Queries for table: inventory.sku_serial
// ========================================
func (q *Queries) GetSkuSerial(ctx context.Context, arg GetSkuSerialParams) (InventorySkuSerial, error) {
	row := q.db.QueryRow(ctx, getSkuSerial, arg.ID, arg.SerialNumber)
	var i InventorySkuSerial
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SkuID,
		&i.Status,
		&i.DateCreated,
	)
	return i, err
}

const getStock = `-- name: GetStock :one



SELECT id, ref_type, ref_id, current_stock, sold, date_created
FROM "inventory"."stock"
WHERE ("id" = $1) OR ("ref_id" = $2 AND "ref_type" = $3)
`

type GetStockParams struct {
	ID      int64              `json:"id"`
	RefID   int64              `json:"ref_id"`
	RefType InventoryStockType `json:"ref_type"`
}

// ========================================
// Queries for table: inventory.stock
// ========================================
func (q *Queries) GetStock(ctx context.Context, arg GetStockParams) (InventoryStock, error) {
	row := q.db.QueryRow(ctx, getStock, arg.ID, arg.RefID, arg.RefType)
	var i InventoryStock
	err := row.Scan(
		&i.ID,
		&i.RefType,
		&i.RefID,
		&i.CurrentStock,
		&i.Sold,
		&i.DateCreated,
	)
	return i, err
}

const getStockHistory = `-- name: GetStockHistory :one



SELECT id, stock_id, change, date_created
FROM "inventory"."stock_history"
WHERE ("id" = $1)
`

// ========================================
// Queries for table: inventory.stock_history
// ========================================
func (q *Queries) GetStockHistory(ctx context.Context, id int64) (InventoryStockHistory, error) {
	row := q.db.QueryRow(ctx, getStockHistory, id)
	var i InventoryStockHistory
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.Change,
		&i.DateCreated,
	)
	return i, err
}

const getTag = `-- name: GetTag :one



SELECT id, tag, description
FROM "catalog"."tag"
WHERE ("id" = $1) OR ("tag" = $2)
`

type GetTagParams struct {
	ID  int64  `json:"id"`
	Tag string `json:"tag"`
}

// ========================================
// Queries for table: catalog.tag
// ========================================
func (q *Queries) GetTag(ctx context.Context, arg GetTagParams) (CatalogTag, error) {
	row := q.db.QueryRow(ctx, getTag, arg.ID, arg.Tag)
	var i CatalogTag
	err := row.Scan(&i.ID, &i.Tag, &i.Description)
	return i, err
}

const getVendor = `-- name: GetVendor :one



SELECT id, account_id
FROM "account"."vendor"
WHERE ("id" = $1) OR ("account_id" = $2)
`

type GetVendorParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
}

// ========================================
// Queries for table: account.vendor
// ========================================
func (q *Queries) GetVendor(ctx context.Context, arg GetVendorParams) (AccountVendor, error) {
	row := q.db.QueryRow(ctx, getVendor, arg.ID, arg.AccountID)
	var i AccountVendor
	err := row.Scan(&i.ID, &i.AccountID)
	return i, err
}

const getVnpay = `-- name: GetVnpay :one



SELECT id, order_id, "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef"
FROM "payment"."vnpay"
WHERE ("id" = $1) OR ("order_id" = $2)
`

type GetVnpayParams struct {
	ID      int64 `json:"id"`
	OrderID int64 `json:"order_id"`
}

// ========================================
// Queries for table: payment.vnpay
// ========================================
func (q *Queries) GetVnpay(ctx context.Context, arg GetVnpayParams) (PaymentVnpay, error) {
	row := q.db.QueryRow(ctx, getVnpay, arg.ID, arg.OrderID)
	var i PaymentVnpay
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VnpAmount,
		&i.VnpBankCode,
		&i.VnpCardType,
		&i.VnpOrderInfo,
		&i.VnpPayDate,
		&i.VnpResponseCode,
		&i.VnpSecureHash,
		&i.VnpTmnCode,
		&i.VnpTransactionNo,
		&i.VnpTransactionStatus,
		&i.VnpTxnRef,
	)
	return i, err
}

const listAccount = `-- name: ListAccount :many
SELECT id, code, type, status, phone, email, username, password, date_created, date_updated
FROM "account"."account"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("status" = $4 OR $4 IS NULL) AND
    ("phone" = $5 OR $5 IS NULL) AND
    ("email" = $6 OR $6 IS NULL) AND
    ("username" = $7 OR $7 IS NULL) AND
    ("password" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $12
OFFSET $11
`

type ListAccountParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	Type        NullAccountType    `json:"type"`
	Status      NullAccountStatus  `json:"status"`
	Phone       pgtype.Text        `json:"phone"`
	Email       pgtype.Text        `json:"email"`
	Username    pgtype.Text        `json:"username"`
	Password    pgtype.Text        `json:"password"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListAccount(ctx context.Context, arg ListAccountParams) ([]AccountAccount, error) {
	rows, err := q.db.Query(ctx, listAccount,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.Phone,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountAccount{}
	for rows.Next() {
		var i AccountAccount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.Status,
			&i.Phone,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddress = `-- name: ListAddress :many
SELECT id, code, account_id, type, full_name, phone, phone_verified, address_line, city, state_province, country, date_created, date_updated
FROM "account"."address"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("type" = $4 OR $4 IS NULL) AND
    ("full_name" = $5 OR $5 IS NULL) AND
    ("phone" = $6 OR $6 IS NULL) AND
    ("phone_verified" = $7 OR $7 IS NULL) AND
    ("address_line" = $8 OR $8 IS NULL) AND
    ("city" = $9 OR $9 IS NULL) AND
    ("state_province" = $10 OR $10 IS NULL) AND
    ("country" = $11 OR $11 IS NULL) AND
    ("date_created" = $12 OR $12 IS NULL) AND
    ("date_updated" = $13 OR $13 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $15
OFFSET $14
`

type ListAddressParams struct {
	ID            pgtype.Int8            `json:"id"`
	Code          pgtype.Text            `json:"code"`
	AccountID     pgtype.Int8            `json:"account_id"`
	Type          NullAccountAddressType `json:"type"`
	FullName      pgtype.Text            `json:"full_name"`
	Phone         pgtype.Text            `json:"phone"`
	PhoneVerified pgtype.Bool            `json:"phone_verified"`
	AddressLine   pgtype.Text            `json:"address_line"`
	City          pgtype.Text            `json:"city"`
	StateProvince pgtype.Text            `json:"state_province"`
	Country       pgtype.Text            `json:"country"`
	DateCreated   pgtype.Timestamptz     `json:"date_created"`
	DateUpdated   pgtype.Timestamptz     `json:"date_updated"`
	Offset        int32                  `json:"offset"`
	Limit         int32                  `json:"limit"`
}

func (q *Queries) ListAddress(ctx context.Context, arg ListAddressParams) ([]AccountAddress, error) {
	rows, err := q.db.Query(ctx, listAddress,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.Type,
		arg.FullName,
		arg.Phone,
		arg.PhoneVerified,
		arg.AddressLine,
		arg.City,
		arg.StateProvince,
		arg.Country,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountAddress{}
	for rows.Next() {
		var i AccountAddress
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.AccountID,
			&i.Type,
			&i.FullName,
			&i.Phone,
			&i.PhoneVerified,
			&i.AddressLine,
			&i.City,
			&i.StateProvince,
			&i.Country,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrand = `-- name: ListBrand :many
SELECT id, code, name, description
FROM "catalog"."brand"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL)
)
ORDER BY "id"
LIMIT $4
OFFSET $3
`

type ListBrandParams struct {
	ID     pgtype.Int8 `json:"id"`
	Code   pgtype.Text `json:"code"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListBrand(ctx context.Context, arg ListBrandParams) ([]CatalogBrand, error) {
	rows, err := q.db.Query(ctx, listBrand,
		arg.ID,
		arg.Code,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogBrand{}
	for rows.Next() {
		var i CatalogBrand
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCartItem = `-- name: ListCartItem :many
SELECT id, cart_id, sku_id, quantity, date_created, date_updated
FROM "account"."cart_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("cart_id" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("quantity" = $4 OR $4 IS NULL) AND
    ("date_created" = $5 OR $5 IS NULL) AND
    ("date_updated" = $6 OR $6 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $8
OFFSET $7
`

type ListCartItemParams struct {
	ID          pgtype.Int8        `json:"id"`
	CartID      pgtype.Int8        `json:"cart_id"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Quantity    pgtype.Int8        `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListCartItem(ctx context.Context, arg ListCartItemParams) ([]AccountCartItem, error) {
	rows, err := q.db.Query(ctx, listCartItem,
		arg.ID,
		arg.CartID,
		arg.SkuID,
		arg.Quantity,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountCartItem{}
	for rows.Next() {
		var i AccountCartItem
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.SkuID,
			&i.Quantity,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategory = `-- name: ListCategory :many
SELECT id, name, description, parent_id
FROM "catalog"."category"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("name" = $2 OR $2 IS NULL) AND
    ("parent_id" = $3 OR $3 IS NULL)
)
ORDER BY "id"
LIMIT $5
OFFSET $4
`

type ListCategoryParams struct {
	ID       pgtype.Int8 `json:"id"`
	Name     pgtype.Text `json:"name"`
	ParentID pgtype.Int8 `json:"parent_id"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListCategory(ctx context.Context, arg ListCategoryParams) ([]CatalogCategory, error) {
	rows, err := q.db.Query(ctx, listCategory,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogCategory{}
	for rows.Next() {
		var i CatalogCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ParentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComment = `-- name: ListComment :many
SELECT id, code, account_id, ref_type, ref_id, body, upvote, downvote, score, date_created, date_updated
FROM "catalog"."comment"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("upvote" = $6 OR $6 IS NULL) AND
    ("downvote" = $7 OR $7 IS NULL) AND
    ("score" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $12
OFFSET $11
`

type ListCommentParams struct {
	ID          pgtype.Int8                `json:"id"`
	Code        pgtype.Text                `json:"code"`
	AccountID   pgtype.Int8                `json:"account_id"`
	RefType     NullCatalogCommentDestType `json:"ref_type"`
	RefID       pgtype.Int8                `json:"ref_id"`
	Upvote      pgtype.Int8                `json:"upvote"`
	Downvote    pgtype.Int8                `json:"downvote"`
	Score       pgtype.Int4                `json:"score"`
	DateCreated pgtype.Timestamptz         `json:"date_created"`
	DateUpdated pgtype.Timestamptz         `json:"date_updated"`
	Offset      int32                      `json:"offset"`
	Limit       int32                      `json:"limit"`
}

func (q *Queries) ListComment(ctx context.Context, arg ListCommentParams) ([]CatalogComment, error) {
	rows, err := q.db.Query(ctx, listComment,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogComment{}
	for rows.Next() {
		var i CatalogComment
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.AccountID,
			&i.RefType,
			&i.RefID,
			&i.Body,
			&i.Upvote,
			&i.Downvote,
			&i.Score,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomer = `-- name: ListCustomer :many
SELECT id, account_id, default_address_id, date_created, date_updated
FROM "account"."customer"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("default_address_id" = $3 OR $3 IS NULL) AND
    ("date_created" = $4 OR $4 IS NULL) AND
    ("date_updated" = $5 OR $5 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $7
OFFSET $6
`

type ListCustomerParams struct {
	ID               pgtype.Int8        `json:"id"`
	AccountID        pgtype.Int8        `json:"account_id"`
	DefaultAddressID pgtype.Int8        `json:"default_address_id"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	Offset           int32              `json:"offset"`
	Limit            int32              `json:"limit"`
}

func (q *Queries) ListCustomer(ctx context.Context, arg ListCustomerParams) ([]AccountCustomer, error) {
	rows, err := q.db.Query(ctx, listCustomer,
		arg.ID,
		arg.AccountID,
		arg.DefaultAddressID,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountCustomer{}
	for rows.Next() {
		var i AccountCustomer
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.DefaultAddressID,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvent = `-- name: ListEvent :many
SELECT id, account_id, aggregate_id, aggregate_type, event_type, payload, version, date_created
FROM "system"."event"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("aggregate_id" = $3 OR $3 IS NULL) AND
    ("aggregate_type" = $4 OR $4 IS NULL) AND
    ("event_type" = $5 OR $5 IS NULL) AND
    ("payload" = $6 OR $6 IS NULL) AND
    ("version" = $7 OR $7 IS NULL) AND
    ("date_created" = $8 OR $8 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $10
OFFSET $9
`

type ListEventParams struct {
	ID            pgtype.Int8         `json:"id"`
	AccountID     pgtype.Int8         `json:"account_id"`
	AggregateID   pgtype.Int8         `json:"aggregate_id"`
	AggregateType pgtype.Text         `json:"aggregate_type"`
	EventType     NullSystemEventType `json:"event_type"`
	Payload       []byte              `json:"payload"`
	Version       pgtype.Int8         `json:"version"`
	DateCreated   pgtype.Timestamptz  `json:"date_created"`
	Offset        int32               `json:"offset"`
	Limit         int32               `json:"limit"`
}

func (q *Queries) ListEvent(ctx context.Context, arg ListEventParams) ([]SystemEvent, error) {
	rows, err := q.db.Query(ctx, listEvent,
		arg.ID,
		arg.AccountID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Payload,
		arg.Version,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemEvent{}
	for rows.Next() {
		var i SystemEvent
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.Payload,
			&i.Version,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoice = `-- name: ListInvoice :many
SELECT id, code, type, ref_type, ref_id, seller_account_id, buyer_account_id, status, payment_method, address, phone, subtotal, total, file_rs_id, date_created, hash, prev_hash
FROM "payment"."invoice"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("seller_account_id" = $6 OR $6 IS NULL) AND
    ("buyer_account_id" = $7 OR $7 IS NULL) AND
    ("status" = $8 OR $8 IS NULL) AND
    ("payment_method" = $9 OR $9 IS NULL) AND
    ("subtotal" = $10 OR $10 IS NULL) AND
    ("total" = $11 OR $11 IS NULL) AND
    ("date_created" = $12 OR $12 IS NULL) AND
    ("hash" = $13 OR $13 IS NULL) AND
    ("prev_hash" = $14 OR $14 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $16
OFFSET $15
`

type ListInvoiceParams struct {
	ID              pgtype.Int8               `json:"id"`
	Code            pgtype.Text               `json:"code"`
	Type            NullPaymentInvoiceType    `json:"type"`
	RefType         NullPaymentInvoiceRefType `json:"ref_type"`
	RefID           pgtype.Int8               `json:"ref_id"`
	SellerAccountID pgtype.Int8               `json:"seller_account_id"`
	BuyerAccountID  pgtype.Int8               `json:"buyer_account_id"`
	Status          NullSharedStatus          `json:"status"`
	PaymentMethod   NullPaymentPaymentMethod  `json:"payment_method"`
	Subtotal        pgtype.Int8               `json:"subtotal"`
	Total           pgtype.Int8               `json:"total"`
	DateCreated     pgtype.Timestamptz        `json:"date_created"`
	Hash            []byte                    `json:"hash"`
	PrevHash        []byte                    `json:"prev_hash"`
	Offset          int32                     `json:"offset"`
	Limit           int32                     `json:"limit"`
}

func (q *Queries) ListInvoice(ctx context.Context, arg ListInvoiceParams) ([]PaymentInvoice, error) {
	rows, err := q.db.Query(ctx, listInvoice,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.RefType,
		arg.RefID,
		arg.SellerAccountID,
		arg.BuyerAccountID,
		arg.Status,
		arg.PaymentMethod,
		arg.Subtotal,
		arg.Total,
		arg.DateCreated,
		arg.Hash,
		arg.PrevHash,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentInvoice{}
	for rows.Next() {
		var i PaymentInvoice
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.RefType,
			&i.RefID,
			&i.SellerAccountID,
			&i.BuyerAccountID,
			&i.Status,
			&i.PaymentMethod,
			&i.Address,
			&i.Phone,
			&i.Subtotal,
			&i.Total,
			&i.FileRsID,
			&i.DateCreated,
			&i.Hash,
			&i.PrevHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoiceItem = `-- name: ListInvoiceItem :many
SELECT id, invoice_id, snapshot, quantity, unit_price, subtotal, total
FROM "payment"."invoice_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("invoice_id" = $2 OR $2 IS NULL) AND
    ("snapshot" = $3 OR $3 IS NULL) AND
    ("quantity" = $4 OR $4 IS NULL) AND
    ("unit_price" = $5 OR $5 IS NULL) AND
    ("subtotal" = $6 OR $6 IS NULL) AND
    ("total" = $7 OR $7 IS NULL)
)
ORDER BY "id"
LIMIT $9
OFFSET $8
`

type ListInvoiceItemParams struct {
	ID        pgtype.Int8 `json:"id"`
	InvoiceID pgtype.Int8 `json:"invoice_id"`
	Snapshot  []byte      `json:"snapshot"`
	Quantity  pgtype.Int8 `json:"quantity"`
	UnitPrice pgtype.Int8 `json:"unit_price"`
	Subtotal  pgtype.Int8 `json:"subtotal"`
	Total     pgtype.Int8 `json:"total"`
	Offset    int32       `json:"offset"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) ListInvoiceItem(ctx context.Context, arg ListInvoiceItemParams) ([]PaymentInvoiceItem, error) {
	rows, err := q.db.Query(ctx, listInvoiceItem,
		arg.ID,
		arg.InvoiceID,
		arg.Snapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
		arg.Total,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentInvoiceItem{}
	for rows.Next() {
		var i PaymentInvoiceItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Snapshot,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrder = `-- name: ListOrder :many
SELECT id, code, customer_id, payment_method, status, address, date_created, date_updated
FROM "payment"."order"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("customer_id" = $3 OR $3 IS NULL) AND
    ("payment_method" = $4 OR $4 IS NULL) AND
    ("status" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListOrderParams struct {
	ID            pgtype.Int8              `json:"id"`
	Code          pgtype.Text              `json:"code"`
	CustomerID    pgtype.Int8              `json:"customer_id"`
	PaymentMethod NullPaymentPaymentMethod `json:"payment_method"`
	Status        NullSharedStatus         `json:"status"`
	DateCreated   pgtype.Timestamptz       `json:"date_created"`
	DateUpdated   pgtype.Timestamptz       `json:"date_updated"`
	Offset        int32                    `json:"offset"`
	Limit         int32                    `json:"limit"`
}

func (q *Queries) ListOrder(ctx context.Context, arg ListOrderParams) ([]PaymentOrder, error) {
	rows, err := q.db.Query(ctx, listOrder,
		arg.ID,
		arg.Code,
		arg.CustomerID,
		arg.PaymentMethod,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrder{}
	for rows.Next() {
		var i PaymentOrder
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.CustomerID,
			&i.PaymentMethod,
			&i.Status,
			&i.Address,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItem = `-- name: ListOrderItem :many
SELECT id, code, order_id, sku_id, quantity
FROM "payment"."order_item"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("order_id" = $3 OR $3 IS NULL) AND
    ("sku_id" = $4 OR $4 IS NULL) AND
    ("quantity" = $5 OR $5 IS NULL)
)
ORDER BY "id"
LIMIT $7
OFFSET $6
`

type ListOrderItemParams struct {
	ID       pgtype.Int8 `json:"id"`
	Code     pgtype.Text `json:"code"`
	OrderID  pgtype.Int8 `json:"order_id"`
	SkuID    pgtype.Int8 `json:"sku_id"`
	Quantity pgtype.Int8 `json:"quantity"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListOrderItem(ctx context.Context, arg ListOrderItemParams) ([]PaymentOrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItem,
		arg.ID,
		arg.Code,
		arg.OrderID,
		arg.SkuID,
		arg.Quantity,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrderItem{}
	for rows.Next() {
		var i PaymentOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.OrderID,
			&i.SkuID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItemSerial = `-- name: ListOrderItemSerial :many
SELECT id, order_item_id, product_serial_id
FROM "payment"."order_item_serial"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("order_item_id" = $2 OR $2 IS NULL) AND
    ("product_serial_id" = $3 OR $3 IS NULL)
)
ORDER BY "id"
LIMIT $5
OFFSET $4
`

type ListOrderItemSerialParams struct {
	ID              pgtype.Int8 `json:"id"`
	OrderItemID     pgtype.Int8 `json:"order_item_id"`
	ProductSerialID pgtype.Int8 `json:"product_serial_id"`
	Offset          int32       `json:"offset"`
	Limit           int32       `json:"limit"`
}

func (q *Queries) ListOrderItemSerial(ctx context.Context, arg ListOrderItemSerialParams) ([]PaymentOrderItemSerial, error) {
	rows, err := q.db.Query(ctx, listOrderItemSerial,
		arg.ID,
		arg.OrderItemID,
		arg.ProductSerialID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentOrderItemSerial{}
	for rows.Next() {
		var i PaymentOrderItemSerial
		if err := rows.Scan(&i.ID, &i.OrderItemID, &i.ProductSerialID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductSku = `-- name: ListProductSku :many
SELECT id, code, spu_id, price, can_combine, date_created, date_deleted
FROM "catalog"."product_sku"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("spu_id" = $3 OR $3 IS NULL) AND
    ("price" = $4 OR $4 IS NULL) AND
    ("can_combine" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_deleted" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListProductSkuParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	SpuID       pgtype.Int8        `json:"spu_id"`
	Price       pgtype.Int8        `json:"price"`
	CanCombine  pgtype.Bool        `json:"can_combine"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListProductSku(ctx context.Context, arg ListProductSkuParams) ([]CatalogProductSku, error) {
	rows, err := q.db.Query(ctx, listProductSku,
		arg.ID,
		arg.Code,
		arg.SpuID,
		arg.Price,
		arg.CanCombine,
		arg.DateCreated,
		arg.DateDeleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogProductSku{}
	for rows.Next() {
		var i CatalogProductSku
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SpuID,
			&i.Price,
			&i.CanCombine,
			&i.DateCreated,
			&i.DateDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductSkuAttribute = `-- name: ListProductSkuAttribute :many
SELECT id, code, sku_id, name, value, date_created, date_updated
FROM "catalog"."product_sku_attribute"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("name" = $4 OR $4 IS NULL) AND
    ("value" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListProductSkuAttributeParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Name        pgtype.Text        `json:"name"`
	Value       pgtype.Text        `json:"value"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListProductSkuAttribute(ctx context.Context, arg ListProductSkuAttributeParams) ([]CatalogProductSkuAttribute, error) {
	rows, err := q.db.Query(ctx, listProductSkuAttribute,
		arg.ID,
		arg.Code,
		arg.SkuID,
		arg.Name,
		arg.Value,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogProductSkuAttribute{}
	for rows.Next() {
		var i CatalogProductSkuAttribute
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SkuID,
			&i.Name,
			&i.Value,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductSpu = `-- name: ListProductSpu :many
SELECT id, code, account_id, category_id, brand_id, name, description, is_active, date_manufactured, date_created, date_updated, date_deleted
FROM "catalog"."product_spu"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("account_id" = $3 OR $3 IS NULL) AND
    ("category_id" = $4 OR $4 IS NULL) AND
    ("brand_id" = $5 OR $5 IS NULL) AND
    ("is_active" = $6 OR $6 IS NULL) AND
    ("date_manufactured" = $7 OR $7 IS NULL) AND
    ("date_created" = $8 OR $8 IS NULL) AND
    ("date_updated" = $9 OR $9 IS NULL) AND
    ("date_deleted" = $10 OR $10 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $12
OFFSET $11
`

type ListProductSpuParams struct {
	ID               pgtype.Int8        `json:"id"`
	Code             pgtype.Text        `json:"code"`
	AccountID        pgtype.Int8        `json:"account_id"`
	CategoryID       pgtype.Int8        `json:"category_id"`
	BrandID          pgtype.Int8        `json:"brand_id"`
	IsActive         pgtype.Bool        `json:"is_active"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
	Offset           int32              `json:"offset"`
	Limit            int32              `json:"limit"`
}

func (q *Queries) ListProductSpu(ctx context.Context, arg ListProductSpuParams) ([]CatalogProductSpu, error) {
	rows, err := q.db.Query(ctx, listProductSpu,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.CategoryID,
		arg.BrandID,
		arg.IsActive,
		arg.DateManufactured,
		arg.DateCreated,
		arg.DateUpdated,
		arg.DateDeleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogProductSpu{}
	for rows.Next() {
		var i CatalogProductSpu
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.AccountID,
			&i.CategoryID,
			&i.BrandID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.DateManufactured,
			&i.DateCreated,
			&i.DateUpdated,
			&i.DateDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductSpuTag = `-- name: ListProductSpuTag :many
SELECT id, spu_id, tag_id
FROM "catalog"."product_spu_tag"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("spu_id" = $2 OR $2 IS NULL) AND
    ("tag_id" = $3 OR $3 IS NULL)
)
ORDER BY "id"
LIMIT $5
OFFSET $4
`

type ListProductSpuTagParams struct {
	ID     pgtype.Int8 `json:"id"`
	SpuID  pgtype.Int8 `json:"spu_id"`
	TagID  pgtype.Int8 `json:"tag_id"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListProductSpuTag(ctx context.Context, arg ListProductSpuTagParams) ([]CatalogProductSpuTag, error) {
	rows, err := q.db.Query(ctx, listProductSpuTag,
		arg.ID,
		arg.SpuID,
		arg.TagID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogProductSpuTag{}
	for rows.Next() {
		var i CatalogProductSpuTag
		if err := rows.Scan(&i.ID, &i.SpuID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfile = `-- name: ListProfile :many
SELECT id, account_id, gender, name, date_of_birth, avatar_rs_id, email_verified, phone_verified, date_created, date_updated
FROM "account"."profile"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL) AND
    ("gender" = $3 OR $3 IS NULL) AND
    ("name" = $4 OR $4 IS NULL) AND
    ("date_of_birth" = $5 OR $5 IS NULL) AND
    ("avatar_rs_id" = $6 OR $6 IS NULL) AND
    ("email_verified" = $7 OR $7 IS NULL) AND
    ("phone_verified" = $8 OR $8 IS NULL) AND
    ("date_created" = $9 OR $9 IS NULL) AND
    ("date_updated" = $10 OR $10 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $12
OFFSET $11
`

type ListProfileParams struct {
	ID            pgtype.Int8        `json:"id"`
	AccountID     pgtype.Int8        `json:"account_id"`
	Gender        NullAccountGender  `json:"gender"`
	Name          pgtype.Text        `json:"name"`
	DateOfBirth   pgtype.Date        `json:"date_of_birth"`
	AvatarRsID    pgtype.Int8        `json:"avatar_rs_id"`
	EmailVerified pgtype.Bool        `json:"email_verified"`
	PhoneVerified pgtype.Bool        `json:"phone_verified"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	DateUpdated   pgtype.Timestamptz `json:"date_updated"`
	Offset        int32              `json:"offset"`
	Limit         int32              `json:"limit"`
}

func (q *Queries) ListProfile(ctx context.Context, arg ListProfileParams) ([]AccountProfile, error) {
	rows, err := q.db.Query(ctx, listProfile,
		arg.ID,
		arg.AccountID,
		arg.Gender,
		arg.Name,
		arg.DateOfBirth,
		arg.AvatarRsID,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountProfile{}
	for rows.Next() {
		var i AccountProfile
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Gender,
			&i.Name,
			&i.DateOfBirth,
			&i.AvatarRsID,
			&i.EmailVerified,
			&i.PhoneVerified,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromotion = `-- name: ListPromotion :many
SELECT id, code, type, is_active, date_started, date_ended, date_created
FROM "promotion"."promotion"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("type" = $3 OR $3 IS NULL) AND
    ("is_active" = $4 OR $4 IS NULL) AND
    ("date_started" = $5 OR $5 IS NULL) AND
    ("date_ended" = $6 OR $6 IS NULL) AND
    ("date_created" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListPromotionParams struct {
	ID          pgtype.Int8                `json:"id"`
	Code        pgtype.Text                `json:"code"`
	Type        NullPromotionPromotionType `json:"type"`
	IsActive    pgtype.Bool                `json:"is_active"`
	DateStarted pgtype.Timestamptz         `json:"date_started"`
	DateEnded   pgtype.Timestamptz         `json:"date_ended"`
	DateCreated pgtype.Timestamptz         `json:"date_created"`
	Offset      int32                      `json:"offset"`
	Limit       int32                      `json:"limit"`
}

func (q *Queries) ListPromotion(ctx context.Context, arg ListPromotionParams) ([]PromotionPromotion, error) {
	rows, err := q.db.Query(ctx, listPromotion,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.IsActive,
		arg.DateStarted,
		arg.DateEnded,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromotionPromotion{}
	for rows.Next() {
		var i PromotionPromotion
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.IsActive,
			&i.DateStarted,
			&i.DateEnded,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromotionRedemption = `-- name: ListPromotionRedemption :many
SELECT id, promotion_id, version, ref_type, ref_id, date_created
FROM "promotion"."promotion_redemption"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("promotion_id" = $2 OR $2 IS NULL) AND
    ("version" = $3 OR $3 IS NULL) AND
    ("ref_type" = $4 OR $4 IS NULL) AND
    ("ref_id" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $8
OFFSET $7
`

type ListPromotionRedemptionParams struct {
	ID          pgtype.Int8                   `json:"id"`
	PromotionID pgtype.Int8                   `json:"promotion_id"`
	Version     pgtype.Int8                   `json:"version"`
	RefType     NullPromotionPromotionRefType `json:"ref_type"`
	RefID       pgtype.Int8                   `json:"ref_id"`
	DateCreated pgtype.Timestamptz            `json:"date_created"`
	Offset      int32                         `json:"offset"`
	Limit       int32                         `json:"limit"`
}

func (q *Queries) ListPromotionRedemption(ctx context.Context, arg ListPromotionRedemptionParams) ([]PromotionPromotionRedemption, error) {
	rows, err := q.db.Query(ctx, listPromotionRedemption,
		arg.ID,
		arg.PromotionID,
		arg.Version,
		arg.RefType,
		arg.RefID,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromotionPromotionRedemption{}
	for rows.Next() {
		var i PromotionPromotionRedemption
		if err := rows.Scan(
			&i.ID,
			&i.PromotionID,
			&i.Version,
			&i.RefType,
			&i.RefID,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromotionVoucher = `-- name: ListPromotionVoucher :many
SELECT id, promotion_id, min_spend, max_discount, discount_percent, discount_price
FROM "promotion"."promotion_voucher"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("promotion_id" = $2 OR $2 IS NULL) AND
    ("min_spend" = $3 OR $3 IS NULL) AND
    ("max_discount" = $4 OR $4 IS NULL) AND
    ("discount_percent" = $5 OR $5 IS NULL) AND
    ("discount_price" = $6 OR $6 IS NULL)
)
ORDER BY "id"
LIMIT $8
OFFSET $7
`

type ListPromotionVoucherParams struct {
	ID              pgtype.Int8 `json:"id"`
	PromotionID     pgtype.Int8 `json:"promotion_id"`
	MinSpend        pgtype.Int8 `json:"min_spend"`
	MaxDiscount     pgtype.Int8 `json:"max_discount"`
	DiscountPercent pgtype.Int4 `json:"discount_percent"`
	DiscountPrice   pgtype.Int8 `json:"discount_price"`
	Offset          int32       `json:"offset"`
	Limit           int32       `json:"limit"`
}

func (q *Queries) ListPromotionVoucher(ctx context.Context, arg ListPromotionVoucherParams) ([]PromotionPromotionVoucher, error) {
	rows, err := q.db.Query(ctx, listPromotionVoucher,
		arg.ID,
		arg.PromotionID,
		arg.MinSpend,
		arg.MaxDiscount,
		arg.DiscountPercent,
		arg.DiscountPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PromotionPromotionVoucher{}
	for rows.Next() {
		var i PromotionPromotionVoucher
		if err := rows.Scan(
			&i.ID,
			&i.PromotionID,
			&i.MinSpend,
			&i.MaxDiscount,
			&i.DiscountPercent,
			&i.DiscountPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefund = `-- name: ListRefund :many
SELECT id, code, order_item_id, reviewed_by_id, method, status, reason, address, date_created
FROM "payment"."refund"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("order_item_id" = $3 OR $3 IS NULL) AND
    ("reviewed_by_id" = $4 OR $4 IS NULL) AND
    ("method" = $5 OR $5 IS NULL) AND
    ("status" = $6 OR $6 IS NULL) AND
    ("date_created" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListRefundParams struct {
	ID           pgtype.Int8             `json:"id"`
	Code         pgtype.Text             `json:"code"`
	OrderItemID  pgtype.Int8             `json:"order_item_id"`
	ReviewedByID pgtype.Int8             `json:"reviewed_by_id"`
	Method       NullPaymentRefundMethod `json:"method"`
	Status       NullSharedStatus        `json:"status"`
	DateCreated  pgtype.Timestamptz      `json:"date_created"`
	Offset       int32                   `json:"offset"`
	Limit        int32                   `json:"limit"`
}

func (q *Queries) ListRefund(ctx context.Context, arg ListRefundParams) ([]PaymentRefund, error) {
	rows, err := q.db.Query(ctx, listRefund,
		arg.ID,
		arg.Code,
		arg.OrderItemID,
		arg.ReviewedByID,
		arg.Method,
		arg.Status,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentRefund{}
	for rows.Next() {
		var i PaymentRefund
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.OrderItemID,
			&i.ReviewedByID,
			&i.Method,
			&i.Status,
			&i.Reason,
			&i.Address,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundDispute = `-- name: ListRefundDispute :many
SELECT id, code, refund_id, vendor_id, reason, status, date_created, date_updated
FROM "payment"."refund_dispute"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("code" = $2 OR $2 IS NULL) AND
    ("refund_id" = $3 OR $3 IS NULL) AND
    ("vendor_id" = $4 OR $4 IS NULL) AND
    ("status" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL) AND
    ("date_updated" = $7 OR $7 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $9
OFFSET $8
`

type ListRefundDisputeParams struct {
	ID          pgtype.Int8        `json:"id"`
	Code        pgtype.Text        `json:"code"`
	RefundID    pgtype.Int8        `json:"refund_id"`
	VendorID    pgtype.Int8        `json:"vendor_id"`
	Status      NullSharedStatus   `json:"status"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListRefundDispute(ctx context.Context, arg ListRefundDisputeParams) ([]PaymentRefundDispute, error) {
	rows, err := q.db.Query(ctx, listRefundDispute,
		arg.ID,
		arg.Code,
		arg.RefundID,
		arg.VendorID,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentRefundDispute{}
	for rows.Next() {
		var i PaymentRefundDispute
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.RefundID,
			&i.VendorID,
			&i.Reason,
			&i.Status,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResource = `-- name: ListResource :many
SELECT id, mime_type, owner_id, owner_type, url, "order"
FROM "shared"."resource"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("owner_id" = $2 OR $2 IS NULL) AND
    ("owner_type" = $3 OR $3 IS NULL) AND
    ("order" = $4 OR $4 IS NULL)
)
ORDER BY "id"
LIMIT $6
OFFSET $5
`

type ListResourceParams struct {
	ID        pgtype.Int8            `json:"id"`
	OwnerID   pgtype.Int8            `json:"owner_id"`
	OwnerType NullSharedResourceType `json:"owner_type"`
	Order     pgtype.Int4            `json:"order"`
	Offset    int32                  `json:"offset"`
	Limit     int32                  `json:"limit"`
}

func (q *Queries) ListResource(ctx context.Context, arg ListResourceParams) ([]SharedResource, error) {
	rows, err := q.db.Query(ctx, listResource,
		arg.ID,
		arg.OwnerID,
		arg.OwnerType,
		arg.Order,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedResource{}
	for rows.Next() {
		var i SharedResource
		if err := rows.Scan(
			&i.ID,
			&i.MimeType,
			&i.OwnerID,
			&i.OwnerType,
			&i.Url,
			&i.Order,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSearchSync = `-- name: ListSearchSync :many
SELECT id, name, last_synced
FROM "system"."search_sync"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("name" = $2 OR $2 IS NULL) AND
    ("last_synced" = $3 OR $3 IS NULL)
)
ORDER BY "id"
LIMIT $5
OFFSET $4
`

type ListSearchSyncParams struct {
	ID         pgtype.Int8        `json:"id"`
	Name       pgtype.Text        `json:"name"`
	LastSynced pgtype.Timestamptz `json:"last_synced"`
	Offset     int32              `json:"offset"`
	Limit      int32              `json:"limit"`
}

func (q *Queries) ListSearchSync(ctx context.Context, arg ListSearchSyncParams) ([]SystemSearchSync, error) {
	rows, err := q.db.Query(ctx, listSearchSync,
		arg.ID,
		arg.Name,
		arg.LastSynced,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemSearchSync{}
	for rows.Next() {
		var i SystemSearchSync
		if err := rows.Scan(&i.ID, &i.Name, &i.LastSynced); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkuSerial = `-- name: ListSkuSerial :many
SELECT id, serial_number, sku_id, status, date_created
FROM "inventory"."sku_serial"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("serial_number" = $2 OR $2 IS NULL) AND
    ("sku_id" = $3 OR $3 IS NULL) AND
    ("status" = $4 OR $4 IS NULL) AND
    ("date_created" = $5 OR $5 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $7
OFFSET $6
`

type ListSkuSerialParams struct {
	ID           pgtype.Int8                `json:"id"`
	SerialNumber pgtype.Text                `json:"serial_number"`
	SkuID        pgtype.Int8                `json:"sku_id"`
	Status       NullInventoryProductStatus `json:"status"`
	DateCreated  pgtype.Timestamptz         `json:"date_created"`
	Offset       int32                      `json:"offset"`
	Limit        int32                      `json:"limit"`
}

func (q *Queries) ListSkuSerial(ctx context.Context, arg ListSkuSerialParams) ([]InventorySkuSerial, error) {
	rows, err := q.db.Query(ctx, listSkuSerial,
		arg.ID,
		arg.SerialNumber,
		arg.SkuID,
		arg.Status,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventorySkuSerial{}
	for rows.Next() {
		var i InventorySkuSerial
		if err := rows.Scan(
			&i.ID,
			&i.SerialNumber,
			&i.SkuID,
			&i.Status,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStock = `-- name: ListStock :many
SELECT id, ref_type, ref_id, current_stock, sold, date_created
FROM "inventory"."stock"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("ref_type" = $2 OR $2 IS NULL) AND
    ("ref_id" = $3 OR $3 IS NULL) AND
    ("current_stock" = $4 OR $4 IS NULL) AND
    ("sold" = $5 OR $5 IS NULL) AND
    ("date_created" = $6 OR $6 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $8
OFFSET $7
`

type ListStockParams struct {
	ID           pgtype.Int8            `json:"id"`
	RefType      NullInventoryStockType `json:"ref_type"`
	RefID        pgtype.Int8            `json:"ref_id"`
	CurrentStock pgtype.Int8            `json:"current_stock"`
	Sold         pgtype.Int8            `json:"sold"`
	DateCreated  pgtype.Timestamptz     `json:"date_created"`
	Offset       int32                  `json:"offset"`
	Limit        int32                  `json:"limit"`
}

func (q *Queries) ListStock(ctx context.Context, arg ListStockParams) ([]InventoryStock, error) {
	rows, err := q.db.Query(ctx, listStock,
		arg.ID,
		arg.RefType,
		arg.RefID,
		arg.CurrentStock,
		arg.Sold,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryStock{}
	for rows.Next() {
		var i InventoryStock
		if err := rows.Scan(
			&i.ID,
			&i.RefType,
			&i.RefID,
			&i.CurrentStock,
			&i.Sold,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockHistory = `-- name: ListStockHistory :many
SELECT id, stock_id, change, date_created
FROM "inventory"."stock_history"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("stock_id" = $2 OR $2 IS NULL) AND
    ("change" = $3 OR $3 IS NULL) AND
    ("date_created" = $4 OR $4 IS NULL)
)
ORDER BY "date_created" DESC
LIMIT $6
OFFSET $5
`

type ListStockHistoryParams struct {
	ID          pgtype.Int8        `json:"id"`
	StockID     pgtype.Int8        `json:"stock_id"`
	Change      pgtype.Int8        `json:"change"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	Offset      int32              `json:"offset"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListStockHistory(ctx context.Context, arg ListStockHistoryParams) ([]InventoryStockHistory, error) {
	rows, err := q.db.Query(ctx, listStockHistory,
		arg.ID,
		arg.StockID,
		arg.Change,
		arg.DateCreated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryStockHistory{}
	for rows.Next() {
		var i InventoryStockHistory
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.Change,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTag = `-- name: ListTag :many
SELECT id, tag, description
FROM "catalog"."tag"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("tag" = $2 OR $2 IS NULL)
)
ORDER BY "id"
LIMIT $4
OFFSET $3
`

type ListTagParams struct {
	ID     pgtype.Int8 `json:"id"`
	Tag    pgtype.Text `json:"tag"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListTag(ctx context.Context, arg ListTagParams) ([]CatalogTag, error) {
	rows, err := q.db.Query(ctx, listTag,
		arg.ID,
		arg.Tag,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogTag{}
	for rows.Next() {
		var i CatalogTag
		if err := rows.Scan(&i.ID, &i.Tag, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVendor = `-- name: ListVendor :many
SELECT id, account_id
FROM "account"."vendor"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("account_id" = $2 OR $2 IS NULL)
)
ORDER BY "id"
LIMIT $4
OFFSET $3
`

type ListVendorParams struct {
	ID        pgtype.Int8 `json:"id"`
	AccountID pgtype.Int8 `json:"account_id"`
	Offset    int32       `json:"offset"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) ListVendor(ctx context.Context, arg ListVendorParams) ([]AccountVendor, error) {
	rows, err := q.db.Query(ctx, listVendor,
		arg.ID,
		arg.AccountID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountVendor{}
	for rows.Next() {
		var i AccountVendor
		if err := rows.Scan(&i.ID, &i.AccountID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVnpay = `-- name: ListVnpay :many
SELECT id, order_id, "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef"
FROM "payment"."vnpay"
WHERE (
    ("id" = $1 OR $1 IS NULL) AND
    ("order_id" = $2 OR $2 IS NULL)
)
ORDER BY "id"
LIMIT $4
OFFSET $3
`

type ListVnpayParams struct {
	ID      pgtype.Int8 `json:"id"`
	OrderID pgtype.Int8 `json:"order_id"`
	Offset  int32       `json:"offset"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) ListVnpay(ctx context.Context, arg ListVnpayParams) ([]PaymentVnpay, error) {
	rows, err := q.db.Query(ctx, listVnpay,
		arg.ID,
		arg.OrderID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentVnpay{}
	for rows.Next() {
		var i PaymentVnpay
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VnpAmount,
			&i.VnpBankCode,
			&i.VnpCardType,
			&i.VnpOrderInfo,
			&i.VnpPayDate,
			&i.VnpResponseCode,
			&i.VnpSecureHash,
			&i.VnpTmnCode,
			&i.VnpTransactionNo,
			&i.VnpTransactionStatus,
			&i.VnpTxnRef,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE "account"."account"
SET "code" = COALESCE($2, "code"),
    "type" = COALESCE($3, "type"),
    "status" = COALESCE($4, "status"),
    "phone" = CASE WHEN $5::bool = TRUE THEN NULL ELSE COALESCE($6, "phone") END,
    "email" = CASE WHEN $7::bool = TRUE THEN NULL ELSE COALESCE($8, "email") END,
    "username" = CASE WHEN $9::bool = TRUE THEN NULL ELSE COALESCE($10, "username") END,
    "password" = CASE WHEN $11::bool = TRUE THEN NULL ELSE COALESCE($12, "password") END,
    "date_created" = COALESCE($13, "date_created"),
    "date_updated" = COALESCE($14, "date_updated")
WHERE "id" = $1
RETURNING id, code, type, status, phone, email, username, password, date_created, date_updated
`

type UpdateAccountParams struct {
	ID           int64              `json:"id"`
	Code         pgtype.Text        `json:"code"`
	Type         NullAccountType    `json:"type"`
	Status       NullAccountStatus  `json:"status"`
	NullPhone    bool               `json:"null_phone"`
	Phone        pgtype.Text        `json:"phone"`
	NullEmail    bool               `json:"null_email"`
	Email        pgtype.Text        `json:"email"`
	NullUsername bool               `json:"null_username"`
	Username     pgtype.Text        `json:"username"`
	NullPassword bool               `json:"null_password"`
	Password     pgtype.Text        `json:"password"`
	DateCreated  pgtype.Timestamptz `json:"date_created"`
	DateUpdated  pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (AccountAccount, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.NullPhone,
		arg.Phone,
		arg.NullEmail,
		arg.Email,
		arg.NullUsername,
		arg.Username,
		arg.NullPassword,
		arg.Password,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountAccount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Phone,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE "account"."address"
SET "code" = COALESCE($2, "code"),
    "account_id" = COALESCE($3, "account_id"),
    "type" = COALESCE($4, "type"),
    "full_name" = COALESCE($5, "full_name"),
    "phone" = COALESCE($6, "phone"),
    "phone_verified" = COALESCE($7, "phone_verified"),
    "address_line" = COALESCE($8, "address_line"),
    "city" = COALESCE($9, "city"),
    "state_province" = COALESCE($10, "state_province"),
    "country" = COALESCE($11, "country"),
    "date_created" = COALESCE($12, "date_created"),
    "date_updated" = COALESCE($13, "date_updated")
WHERE "id" = $1
RETURNING id, code, account_id, type, full_name, phone, phone_verified, address_line, city, state_province, country, date_created, date_updated
`

type UpdateAddressParams struct {
	ID            int64                  `json:"id"`
	Code          pgtype.Text            `json:"code"`
	AccountID     pgtype.Int8            `json:"account_id"`
	Type          NullAccountAddressType `json:"type"`
	FullName      pgtype.Text            `json:"full_name"`
	Phone         pgtype.Text            `json:"phone"`
	PhoneVerified pgtype.Bool            `json:"phone_verified"`
	AddressLine   pgtype.Text            `json:"address_line"`
	City          pgtype.Text            `json:"city"`
	StateProvince pgtype.Text            `json:"state_province"`
	Country       pgtype.Text            `json:"country"`
	DateCreated   pgtype.Timestamptz     `json:"date_created"`
	DateUpdated   pgtype.Timestamptz     `json:"date_updated"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (AccountAddress, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.Type,
		arg.FullName,
		arg.Phone,
		arg.PhoneVerified,
		arg.AddressLine,
		arg.City,
		arg.StateProvince,
		arg.Country,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountAddress
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.Type,
		&i.FullName,
		&i.Phone,
		&i.PhoneVerified,
		&i.AddressLine,
		&i.City,
		&i.StateProvince,
		&i.Country,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateBrand = `-- name: UpdateBrand :one
UPDATE "catalog"."brand"
SET "code" = COALESCE($2, "code"),
    "name" = COALESCE($3, "name"),
    "description" = COALESCE($4, "description")
WHERE "id" = $1
RETURNING id, code, name, description
`

type UpdateBrandParams struct {
	ID          int64       `json:"id"`
	Code        pgtype.Text `json:"code"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (CatalogBrand, error) {
	row := q.db.QueryRow(ctx, updateBrand,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Description,
	)
	var i CatalogBrand
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const updateCartItem = `-- name: UpdateCartItem :one
UPDATE "account"."cart_item"
SET "cart_id" = COALESCE($2, "cart_id"),
    "sku_id" = COALESCE($3, "sku_id"),
    "quantity" = COALESCE($4, "quantity"),
    "date_created" = COALESCE($5, "date_created"),
    "date_updated" = COALESCE($6, "date_updated")
WHERE "id" = $1
RETURNING id, cart_id, sku_id, quantity, date_created, date_updated
`

type UpdateCartItemParams struct {
	ID          int64              `json:"id"`
	CartID      pgtype.Int8        `json:"cart_id"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Quantity    pgtype.Int8        `json:"quantity"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateCartItem(ctx context.Context, arg UpdateCartItemParams) (AccountCartItem, error) {
	row := q.db.QueryRow(ctx, updateCartItem,
		arg.ID,
		arg.CartID,
		arg.SkuID,
		arg.Quantity,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountCartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.SkuID,
		&i.Quantity,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE "catalog"."category"
SET "name" = COALESCE($2, "name"),
    "description" = COALESCE($3, "description"),
    "parent_id" = CASE WHEN $4::bool = TRUE THEN NULL ELSE COALESCE($5, "parent_id") END
WHERE "id" = $1
RETURNING id, name, description, parent_id
`

type UpdateCategoryParams struct {
	ID           int64       `json:"id"`
	Name         pgtype.Text `json:"name"`
	Description  pgtype.Text `json:"description"`
	NullParentID bool        `json:"null_parent_id"`
	ParentID     pgtype.Int8 `json:"parent_id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (CatalogCategory, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.NullParentID,
		arg.ParentID,
	)
	var i CatalogCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
	)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE "catalog"."comment"
SET "code" = COALESCE($2, "code"),
    "account_id" = COALESCE($3, "account_id"),
    "ref_type" = COALESCE($4, "ref_type"),
    "ref_id" = COALESCE($5, "ref_id"),
    "body" = COALESCE($6, "body"),
    "upvote" = COALESCE($7, "upvote"),
    "downvote" = COALESCE($8, "downvote"),
    "score" = COALESCE($9, "score"),
    "date_created" = COALESCE($10, "date_created"),
    "date_updated" = COALESCE($11, "date_updated")
WHERE "id" = $1
RETURNING id, code, account_id, ref_type, ref_id, body, upvote, downvote, score, date_created, date_updated
`

type UpdateCommentParams struct {
	ID          int64                      `json:"id"`
	Code        pgtype.Text                `json:"code"`
	AccountID   pgtype.Int8                `json:"account_id"`
	RefType     NullCatalogCommentDestType `json:"ref_type"`
	RefID       pgtype.Int8                `json:"ref_id"`
	Body        pgtype.Text                `json:"body"`
	Upvote      pgtype.Int8                `json:"upvote"`
	Downvote    pgtype.Int8                `json:"downvote"`
	Score       pgtype.Int4                `json:"score"`
	DateCreated pgtype.Timestamptz         `json:"date_created"`
	DateUpdated pgtype.Timestamptz         `json:"date_updated"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (CatalogComment, error) {
	row := q.db.QueryRow(ctx, updateComment,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.RefType,
		arg.RefID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i CatalogComment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.RefType,
		&i.RefID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE "account"."customer"
SET "account_id" = COALESCE($2, "account_id"),
    "default_address_id" = CASE WHEN $3::bool = TRUE THEN NULL ELSE COALESCE($4, "default_address_id") END,
    "date_created" = COALESCE($5, "date_created"),
    "date_updated" = COALESCE($6, "date_updated")
WHERE "id" = $1
RETURNING id, account_id, default_address_id, date_created, date_updated
`

type UpdateCustomerParams struct {
	ID                   int64              `json:"id"`
	AccountID            pgtype.Int8        `json:"account_id"`
	NullDefaultAddressID bool               `json:"null_default_address_id"`
	DefaultAddressID     pgtype.Int8        `json:"default_address_id"`
	DateCreated          pgtype.Timestamptz `json:"date_created"`
	DateUpdated          pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (AccountCustomer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.ID,
		arg.AccountID,
		arg.NullDefaultAddressID,
		arg.DefaultAddressID,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountCustomer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.DefaultAddressID,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE "system"."event"
SET "account_id" = CASE WHEN $2::bool = TRUE THEN NULL ELSE COALESCE($3, "account_id") END,
    "aggregate_id" = COALESCE($4, "aggregate_id"),
    "aggregate_type" = COALESCE($5, "aggregate_type"),
    "event_type" = COALESCE($6, "event_type"),
    "payload" = COALESCE($7, "payload"),
    "version" = COALESCE($8, "version"),
    "date_created" = COALESCE($9, "date_created")
WHERE "id" = $1
RETURNING id, account_id, aggregate_id, aggregate_type, event_type, payload, version, date_created
`

type UpdateEventParams struct {
	ID            int64               `json:"id"`
	NullAccountID bool                `json:"null_account_id"`
	AccountID     pgtype.Int8         `json:"account_id"`
	AggregateID   pgtype.Int8         `json:"aggregate_id"`
	AggregateType pgtype.Text         `json:"aggregate_type"`
	EventType     NullSystemEventType `json:"event_type"`
	Payload       []byte              `json:"payload"`
	Version       pgtype.Int8         `json:"version"`
	DateCreated   pgtype.Timestamptz  `json:"date_created"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (SystemEvent, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.ID,
		arg.NullAccountID,
		arg.AccountID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Payload,
		arg.Version,
		arg.DateCreated,
	)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.Payload,
		&i.Version,
		&i.DateCreated,
	)
	return i, err
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE "payment"."invoice"
SET "code" = COALESCE($2, "code"),
    "type" = COALESCE($3, "type"),
    "ref_type" = COALESCE($4, "ref_type"),
    "ref_id" = COALESCE($5, "ref_id"),
    "seller_account_id" = CASE WHEN $6::bool = TRUE THEN NULL ELSE COALESCE($7, "seller_account_id") END,
    "buyer_account_id" = COALESCE($8, "buyer_account_id"),
    "status" = COALESCE($9, "status"),
    "payment_method" = COALESCE($10, "payment_method"),
    "address" = COALESCE($11, "address"),
    "phone" = COALESCE($12, "phone"),
    "subtotal" = COALESCE($13, "subtotal"),
    "total" = COALESCE($14, "total"),
    "file_rs_id" = COALESCE($15, "file_rs_id"),
    "date_created" = COALESCE($16, "date_created"),
    "hash" = COALESCE($17, "hash"),
    "prev_hash" = CASE WHEN $18::bool = TRUE THEN NULL ELSE COALESCE($19, "prev_hash") END
WHERE "id" = $1
RETURNING id, code, type, ref_type, ref_id, seller_account_id, buyer_account_id, status, payment_method, address, phone, subtotal, total, file_rs_id, date_created, hash, prev_hash
`

type UpdateInvoiceParams struct {
	ID                  int64                     `json:"id"`
	Code                pgtype.Text               `json:"code"`
	Type                NullPaymentInvoiceType    `json:"type"`
	RefType             NullPaymentInvoiceRefType `json:"ref_type"`
	RefID               pgtype.Int8               `json:"ref_id"`
	NullSellerAccountID bool                      `json:"null_seller_account_id"`
	SellerAccountID     pgtype.Int8               `json:"seller_account_id"`
	BuyerAccountID      pgtype.Int8               `json:"buyer_account_id"`
	Status              NullSharedStatus          `json:"status"`
	PaymentMethod       NullPaymentPaymentMethod  `json:"payment_method"`
	Address             pgtype.Text               `json:"address"`
	Phone               pgtype.Text               `json:"phone"`
	Subtotal            pgtype.Int8               `json:"subtotal"`
	Total               pgtype.Int8               `json:"total"`
	FileRsID            pgtype.Text               `json:"file_rs_id"`
	DateCreated         pgtype.Timestamptz        `json:"date_created"`
	Hash                []byte                    `json:"hash"`
	NullPrevHash        bool                      `json:"null_prev_hash"`
	PrevHash            []byte                    `json:"prev_hash"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (PaymentInvoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.RefType,
		arg.RefID,
		arg.NullSellerAccountID,
		arg.SellerAccountID,
		arg.BuyerAccountID,
		arg.Status,
		arg.PaymentMethod,
		arg.Address,
		arg.Phone,
		arg.Subtotal,
		arg.Total,
		arg.FileRsID,
		arg.DateCreated,
		arg.Hash,
		arg.NullPrevHash,
		arg.PrevHash,
	)
	var i PaymentInvoice
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.RefType,
		&i.RefID,
		&i.SellerAccountID,
		&i.BuyerAccountID,
		&i.Status,
		&i.PaymentMethod,
		&i.Address,
		&i.Phone,
		&i.Subtotal,
		&i.Total,
		&i.FileRsID,
		&i.DateCreated,
		&i.Hash,
		&i.PrevHash,
	)
	return i, err
}

const updateInvoiceItem = `-- name: UpdateInvoiceItem :one
UPDATE "payment"."invoice_item"
SET "invoice_id" = COALESCE($2, "invoice_id"),
    "snapshot" = COALESCE($3, "snapshot"),
    "quantity" = COALESCE($4, "quantity"),
    "unit_price" = COALESCE($5, "unit_price"),
    "subtotal" = COALESCE($6, "subtotal"),
    "total" = COALESCE($7, "total")
WHERE "id" = $1
RETURNING id, invoice_id, snapshot, quantity, unit_price, subtotal, total
`

type UpdateInvoiceItemParams struct {
	ID        int64       `json:"id"`
	InvoiceID pgtype.Int8 `json:"invoice_id"`
	Snapshot  []byte      `json:"snapshot"`
	Quantity  pgtype.Int8 `json:"quantity"`
	UnitPrice pgtype.Int8 `json:"unit_price"`
	Subtotal  pgtype.Int8 `json:"subtotal"`
	Total     pgtype.Int8 `json:"total"`
}

func (q *Queries) UpdateInvoiceItem(ctx context.Context, arg UpdateInvoiceItemParams) (PaymentInvoiceItem, error) {
	row := q.db.QueryRow(ctx, updateInvoiceItem,
		arg.ID,
		arg.InvoiceID,
		arg.Snapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
		arg.Total,
	)
	var i PaymentInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Snapshot,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.Total,
	)
	return i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE "payment"."order"
SET "code" = COALESCE($2, "code"),
    "customer_id" = COALESCE($3, "customer_id"),
    "payment_method" = COALESCE($4, "payment_method"),
    "status" = COALESCE($5, "status"),
    "address" = COALESCE($6, "address"),
    "date_created" = COALESCE($7, "date_created"),
    "date_updated" = COALESCE($8, "date_updated")
WHERE "id" = $1
RETURNING id, code, customer_id, payment_method, status, address, date_created, date_updated
`

type UpdateOrderParams struct {
	ID            int64                    `json:"id"`
	Code          pgtype.Text              `json:"code"`
	CustomerID    pgtype.Int8              `json:"customer_id"`
	PaymentMethod NullPaymentPaymentMethod `json:"payment_method"`
	Status        NullSharedStatus         `json:"status"`
	Address       pgtype.Text              `json:"address"`
	DateCreated   pgtype.Timestamptz       `json:"date_created"`
	DateUpdated   pgtype.Timestamptz       `json:"date_updated"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.ID,
		arg.Code,
		arg.CustomerID,
		arg.PaymentMethod,
		arg.Status,
		arg.Address,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CustomerID,
		&i.PaymentMethod,
		&i.Status,
		&i.Address,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE "payment"."order_item"
SET "code" = COALESCE($2, "code"),
    "order_id" = COALESCE($3, "order_id"),
    "sku_id" = COALESCE($4, "sku_id"),
    "quantity" = COALESCE($5, "quantity")
WHERE "id" = $1
RETURNING id, code, order_id, sku_id, quantity
`

type UpdateOrderItemParams struct {
	ID       int64       `json:"id"`
	Code     pgtype.Text `json:"code"`
	OrderID  pgtype.Int8 `json:"order_id"`
	SkuID    pgtype.Int8 `json:"sku_id"`
	Quantity pgtype.Int8 `json:"quantity"`
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (PaymentOrderItem, error) {
	row := q.db.QueryRow(ctx, updateOrderItem,
		arg.ID,
		arg.Code,
		arg.OrderID,
		arg.SkuID,
		arg.Quantity,
	)
	var i PaymentOrderItem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderID,
		&i.SkuID,
		&i.Quantity,
	)
	return i, err
}

const updateOrderItemSerial = `-- name: UpdateOrderItemSerial :one
UPDATE "payment"."order_item_serial"
SET "order_item_id" = COALESCE($2, "order_item_id"),
    "product_serial_id" = COALESCE($3, "product_serial_id")
WHERE "id" = $1
RETURNING id, order_item_id, product_serial_id
`

type UpdateOrderItemSerialParams struct {
	ID              int64       `json:"id"`
	OrderItemID     pgtype.Int8 `json:"order_item_id"`
	ProductSerialID pgtype.Int8 `json:"product_serial_id"`
}

func (q *Queries) UpdateOrderItemSerial(ctx context.Context, arg UpdateOrderItemSerialParams) (PaymentOrderItemSerial, error) {
	row := q.db.QueryRow(ctx, updateOrderItemSerial, arg.ID, arg.OrderItemID, arg.ProductSerialID)
	var i PaymentOrderItemSerial
	err := row.Scan(&i.ID, &i.OrderItemID, &i.ProductSerialID)
	return i, err
}

const updateProductSku = `-- name: UpdateProductSku :one
UPDATE "catalog"."product_sku"
SET "code" = COALESCE($2, "code"),
    "spu_id" = COALESCE($3, "spu_id"),
    "price" = COALESCE($4, "price"),
    "can_combine" = COALESCE($5, "can_combine"),
    "date_created" = COALESCE($6, "date_created"),
    "date_deleted" = CASE WHEN $7::bool = TRUE THEN NULL ELSE COALESCE($8, "date_deleted") END
WHERE "id" = $1
RETURNING id, code, spu_id, price, can_combine, date_created, date_deleted
`

type UpdateProductSkuParams struct {
	ID              int64              `json:"id"`
	Code            pgtype.Text        `json:"code"`
	SpuID           pgtype.Int8        `json:"spu_id"`
	Price           pgtype.Int8        `json:"price"`
	CanCombine      pgtype.Bool        `json:"can_combine"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
	NullDateDeleted bool               `json:"null_date_deleted"`
	DateDeleted     pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) UpdateProductSku(ctx context.Context, arg UpdateProductSkuParams) (CatalogProductSku, error) {
	row := q.db.QueryRow(ctx, updateProductSku,
		arg.ID,
		arg.Code,
		arg.SpuID,
		arg.Price,
		arg.CanCombine,
		arg.DateCreated,
		arg.NullDateDeleted,
		arg.DateDeleted,
	)
	var i CatalogProductSku
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SpuID,
		&i.Price,
		&i.CanCombine,
		&i.DateCreated,
		&i.DateDeleted,
	)
	return i, err
}

const updateProductSkuAttribute = `-- name: UpdateProductSkuAttribute :one
UPDATE "catalog"."product_sku_attribute"
SET "code" = COALESCE($2, "code"),
    "sku_id" = COALESCE($3, "sku_id"),
    "name" = COALESCE($4, "name"),
    "value" = COALESCE($5, "value"),
    "date_created" = COALESCE($6, "date_created"),
    "date_updated" = COALESCE($7, "date_updated")
WHERE "id" = $1
RETURNING id, code, sku_id, name, value, date_created, date_updated
`

type UpdateProductSkuAttributeParams struct {
	ID          int64              `json:"id"`
	Code        pgtype.Text        `json:"code"`
	SkuID       pgtype.Int8        `json:"sku_id"`
	Name        pgtype.Text        `json:"name"`
	Value       pgtype.Text        `json:"value"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateProductSkuAttribute(ctx context.Context, arg UpdateProductSkuAttributeParams) (CatalogProductSkuAttribute, error) {
	row := q.db.QueryRow(ctx, updateProductSkuAttribute,
		arg.ID,
		arg.Code,
		arg.SkuID,
		arg.Name,
		arg.Value,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i CatalogProductSkuAttribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SkuID,
		&i.Name,
		&i.Value,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateProductSpu = `-- name: UpdateProductSpu :one
UPDATE "catalog"."product_spu"
SET "code" = COALESCE($2, "code"),
    "account_id" = COALESCE($3, "account_id"),
    "category_id" = COALESCE($4, "category_id"),
    "brand_id" = COALESCE($5, "brand_id"),
    "name" = COALESCE($6, "name"),
    "description" = COALESCE($7, "description"),
    "is_active" = COALESCE($8, "is_active"),
    "date_manufactured" = COALESCE($9, "date_manufactured"),
    "date_created" = COALESCE($10, "date_created"),
    "date_updated" = COALESCE($11, "date_updated"),
    "date_deleted" = CASE WHEN $12::bool = TRUE THEN NULL ELSE COALESCE($13, "date_deleted") END
WHERE "id" = $1
RETURNING id, code, account_id, category_id, brand_id, name, description, is_active, date_manufactured, date_created, date_updated, date_deleted
`

type UpdateProductSpuParams struct {
	ID               int64              `json:"id"`
	Code             pgtype.Text        `json:"code"`
	AccountID        pgtype.Int8        `json:"account_id"`
	CategoryID       pgtype.Int8        `json:"category_id"`
	BrandID          pgtype.Int8        `json:"brand_id"`
	Name             pgtype.Text        `json:"name"`
	Description      pgtype.Text        `json:"description"`
	IsActive         pgtype.Bool        `json:"is_active"`
	DateManufactured pgtype.Timestamptz `json:"date_manufactured"`
	DateCreated      pgtype.Timestamptz `json:"date_created"`
	DateUpdated      pgtype.Timestamptz `json:"date_updated"`
	NullDateDeleted  bool               `json:"null_date_deleted"`
	DateDeleted      pgtype.Timestamptz `json:"date_deleted"`
}

func (q *Queries) UpdateProductSpu(ctx context.Context, arg UpdateProductSpuParams) (CatalogProductSpu, error) {
	row := q.db.QueryRow(ctx, updateProductSpu,
		arg.ID,
		arg.Code,
		arg.AccountID,
		arg.CategoryID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.DateManufactured,
		arg.DateCreated,
		arg.DateUpdated,
		arg.NullDateDeleted,
		arg.DateDeleted,
	)
	var i CatalogProductSpu
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.AccountID,
		&i.CategoryID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.DateManufactured,
		&i.DateCreated,
		&i.DateUpdated,
		&i.DateDeleted,
	)
	return i, err
}

const updateProductSpuTag = `-- name: UpdateProductSpuTag :one
UPDATE "catalog"."product_spu_tag"
SET "spu_id" = COALESCE($2, "spu_id"),
    "tag_id" = COALESCE($3, "tag_id")
WHERE "id" = $1
RETURNING id, spu_id, tag_id
`

type UpdateProductSpuTagParams struct {
	ID    int64       `json:"id"`
	SpuID pgtype.Int8 `json:"spu_id"`
	TagID pgtype.Int8 `json:"tag_id"`
}

func (q *Queries) UpdateProductSpuTag(ctx context.Context, arg UpdateProductSpuTagParams) (CatalogProductSpuTag, error) {
	row := q.db.QueryRow(ctx, updateProductSpuTag, arg.ID, arg.SpuID, arg.TagID)
	var i CatalogProductSpuTag
	err := row.Scan(&i.ID, &i.SpuID, &i.TagID)
	return i, err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE "account"."profile"
SET "account_id" = COALESCE($2, "account_id"),
    "gender" = CASE WHEN $3::bool = TRUE THEN NULL ELSE COALESCE($4, "gender") END,
    "name" = CASE WHEN $5::bool = TRUE THEN NULL ELSE COALESCE($6, "name") END,
    "date_of_birth" = CASE WHEN $7::bool = TRUE THEN NULL ELSE COALESCE($8, "date_of_birth") END,
    "avatar_rs_id" = CASE WHEN $9::bool = TRUE THEN NULL ELSE COALESCE($10, "avatar_rs_id") END,
    "email_verified" = COALESCE($11, "email_verified"),
    "phone_verified" = COALESCE($12, "phone_verified"),
    "date_created" = COALESCE($13, "date_created"),
    "date_updated" = COALESCE($14, "date_updated")
WHERE "id" = $1
RETURNING id, account_id, gender, name, date_of_birth, avatar_rs_id, email_verified, phone_verified, date_created, date_updated
`

type UpdateProfileParams struct {
	ID              int64              `json:"id"`
	AccountID       pgtype.Int8        `json:"account_id"`
	NullGender      bool               `json:"null_gender"`
	Gender          NullAccountGender  `json:"gender"`
	NullName        bool               `json:"null_name"`
	Name            pgtype.Text        `json:"name"`
	NullDateOfBirth bool               `json:"null_date_of_birth"`
	DateOfBirth     pgtype.Date        `json:"date_of_birth"`
	NullAvatarRsID  bool               `json:"null_avatar_rs_id"`
	AvatarRsID      pgtype.Int8        `json:"avatar_rs_id"`
	EmailVerified   pgtype.Bool        `json:"email_verified"`
	PhoneVerified   pgtype.Bool        `json:"phone_verified"`
	DateCreated     pgtype.Timestamptz `json:"date_created"`
	DateUpdated     pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (AccountProfile, error) {
	row := q.db.QueryRow(ctx, updateProfile,
		arg.ID,
		arg.AccountID,
		arg.NullGender,
		arg.Gender,
		arg.NullName,
		arg.Name,
		arg.NullDateOfBirth,
		arg.DateOfBirth,
		arg.NullAvatarRsID,
		arg.AvatarRsID,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i AccountProfile
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Gender,
		&i.Name,
		&i.DateOfBirth,
		&i.AvatarRsID,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updatePromotion = `-- name: UpdatePromotion :one
UPDATE "promotion"."promotion"
SET "code" = COALESCE($2, "code"),
    "type" = COALESCE($3, "type"),
    "is_active" = COALESCE($4, "is_active"),
    "date_started" = COALESCE($5, "date_started"),
    "date_ended" = CASE WHEN $6::bool = TRUE THEN NULL ELSE COALESCE($7, "date_ended") END,
    "date_created" = COALESCE($8, "date_created")
WHERE "id" = $1
RETURNING id, code, type, is_active, date_started, date_ended, date_created
`

type UpdatePromotionParams struct {
	ID            int64                      `json:"id"`
	Code          pgtype.Text                `json:"code"`
	Type          NullPromotionPromotionType `json:"type"`
	IsActive      pgtype.Bool                `json:"is_active"`
	DateStarted   pgtype.Timestamptz         `json:"date_started"`
	NullDateEnded bool                       `json:"null_date_ended"`
	DateEnded     pgtype.Timestamptz         `json:"date_ended"`
	DateCreated   pgtype.Timestamptz         `json:"date_created"`
}

func (q *Queries) UpdatePromotion(ctx context.Context, arg UpdatePromotionParams) (PromotionPromotion, error) {
	row := q.db.QueryRow(ctx, updatePromotion,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.IsActive,
		arg.DateStarted,
		arg.NullDateEnded,
		arg.DateEnded,
		arg.DateCreated,
	)
	var i PromotionPromotion
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.IsActive,
		&i.DateStarted,
		&i.DateEnded,
		&i.DateCreated,
	)
	return i, err
}

const updatePromotionRedemption = `-- name: UpdatePromotionRedemption :one
UPDATE "promotion"."promotion_redemption"
SET "promotion_id" = COALESCE($2, "promotion_id"),
    "version" = COALESCE($3, "version"),
    "ref_type" = COALESCE($4, "ref_type"),
    "ref_id" = COALESCE($5, "ref_id"),
    "date_created" = COALESCE($6, "date_created")
WHERE "id" = $1
RETURNING id, promotion_id, version, ref_type, ref_id, date_created
`

type UpdatePromotionRedemptionParams struct {
	ID          int64                         `json:"id"`
	PromotionID pgtype.Int8                   `json:"promotion_id"`
	Version     pgtype.Int8                   `json:"version"`
	RefType     NullPromotionPromotionRefType `json:"ref_type"`
	RefID       pgtype.Int8                   `json:"ref_id"`
	DateCreated pgtype.Timestamptz            `json:"date_created"`
}

func (q *Queries) UpdatePromotionRedemption(ctx context.Context, arg UpdatePromotionRedemptionParams) (PromotionPromotionRedemption, error) {
	row := q.db.QueryRow(ctx, updatePromotionRedemption,
		arg.ID,
		arg.PromotionID,
		arg.Version,
		arg.RefType,
		arg.RefID,
		arg.DateCreated,
	)
	var i PromotionPromotionRedemption
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.Version,
		&i.RefType,
		&i.RefID,
		&i.DateCreated,
	)
	return i, err
}

const updatePromotionVoucher = `-- name: UpdatePromotionVoucher :one
UPDATE "promotion"."promotion_voucher"
SET "promotion_id" = COALESCE($2, "promotion_id"),
    "min_spend" = COALESCE($3, "min_spend"),
    "max_discount" = COALESCE($4, "max_discount"),
    "discount_percent" = CASE WHEN $5::bool = TRUE THEN NULL ELSE COALESCE($6, "discount_percent") END,
    "discount_price" = CASE WHEN $7::bool = TRUE THEN NULL ELSE COALESCE($8, "discount_price") END
WHERE "id" = $1
RETURNING id, promotion_id, min_spend, max_discount, discount_percent, discount_price
`

type UpdatePromotionVoucherParams struct {
	ID                  int64       `json:"id"`
	PromotionID         pgtype.Int8 `json:"promotion_id"`
	MinSpend            pgtype.Int8 `json:"min_spend"`
	MaxDiscount         pgtype.Int8 `json:"max_discount"`
	NullDiscountPercent bool        `json:"null_discount_percent"`
	DiscountPercent     pgtype.Int4 `json:"discount_percent"`
	NullDiscountPrice   bool        `json:"null_discount_price"`
	DiscountPrice       pgtype.Int8 `json:"discount_price"`
}

func (q *Queries) UpdatePromotionVoucher(ctx context.Context, arg UpdatePromotionVoucherParams) (PromotionPromotionVoucher, error) {
	row := q.db.QueryRow(ctx, updatePromotionVoucher,
		arg.ID,
		arg.PromotionID,
		arg.MinSpend,
		arg.MaxDiscount,
		arg.NullDiscountPercent,
		arg.DiscountPercent,
		arg.NullDiscountPrice,
		arg.DiscountPrice,
	)
	var i PromotionPromotionVoucher
	err := row.Scan(
		&i.ID,
		&i.PromotionID,
		&i.MinSpend,
		&i.MaxDiscount,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const updateRefund = `-- name: UpdateRefund :one
UPDATE "payment"."refund"
SET "code" = COALESCE($2, "code"),
    "order_item_id" = COALESCE($3, "order_item_id"),
    "reviewed_by_id" = CASE WHEN $4::bool = TRUE THEN NULL ELSE COALESCE($5, "reviewed_by_id") END,
    "method" = COALESCE($6, "method"),
    "status" = COALESCE($7, "status"),
    "reason" = COALESCE($8, "reason"),
    "address" = CASE WHEN $9::bool = TRUE THEN NULL ELSE COALESCE($10, "address") END,
    "date_created" = COALESCE($11, "date_created")
WHERE "id" = $1
RETURNING id, code, order_item_id, reviewed_by_id, method, status, reason, address, date_created
`

type UpdateRefundParams struct {
	ID               int64                   `json:"id"`
	Code             pgtype.Text             `json:"code"`
	OrderItemID      pgtype.Int8             `json:"order_item_id"`
	NullReviewedByID bool                    `json:"null_reviewed_by_id"`
	ReviewedByID     pgtype.Int8             `json:"reviewed_by_id"`
	Method           NullPaymentRefundMethod `json:"method"`
	Status           NullSharedStatus        `json:"status"`
	Reason           pgtype.Text             `json:"reason"`
	NullAddress      bool                    `json:"null_address"`
	Address          pgtype.Text             `json:"address"`
	DateCreated      pgtype.Timestamptz      `json:"date_created"`
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) (PaymentRefund, error) {
	row := q.db.QueryRow(ctx, updateRefund,
		arg.ID,
		arg.Code,
		arg.OrderItemID,
		arg.NullReviewedByID,
		arg.ReviewedByID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.NullAddress,
		arg.Address,
		arg.DateCreated,
	)
	var i PaymentRefund
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.OrderItemID,
		&i.ReviewedByID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.DateCreated,
	)
	return i, err
}

const updateRefundDispute = `-- name: UpdateRefundDispute :one
UPDATE "payment"."refund_dispute"
SET "code" = COALESCE($2, "code"),
    "refund_id" = COALESCE($3, "refund_id"),
    "vendor_id" = COALESCE($4, "vendor_id"),
    "reason" = COALESCE($5, "reason"),
    "status" = COALESCE($6, "status"),
    "date_created" = COALESCE($7, "date_created"),
    "date_updated" = COALESCE($8, "date_updated")
WHERE "id" = $1
RETURNING id, code, refund_id, vendor_id, reason, status, date_created, date_updated
`

type UpdateRefundDisputeParams struct {
	ID          int64              `json:"id"`
	Code        pgtype.Text        `json:"code"`
	RefundID    pgtype.Int8        `json:"refund_id"`
	VendorID    pgtype.Int8        `json:"vendor_id"`
	Reason      pgtype.Text        `json:"reason"`
	Status      NullSharedStatus   `json:"status"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateUpdated pgtype.Timestamptz `json:"date_updated"`
}

func (q *Queries) UpdateRefundDispute(ctx context.Context, arg UpdateRefundDisputeParams) (PaymentRefundDispute, error) {
	row := q.db.QueryRow(ctx, updateRefundDispute,
		arg.ID,
		arg.Code,
		arg.RefundID,
		arg.VendorID,
		arg.Reason,
		arg.Status,
		arg.DateCreated,
		arg.DateUpdated,
	)
	var i PaymentRefundDispute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.RefundID,
		&i.VendorID,
		&i.Reason,
		&i.Status,
		&i.DateCreated,
		&i.DateUpdated,
	)
	return i, err
}

const updateResource = `-- name: UpdateResource :one
UPDATE "shared"."resource"
SET "mime_type" = COALESCE($2, "mime_type"),
    "owner_id" = COALESCE($3, "owner_id"),
    "owner_type" = COALESCE($4, "owner_type"),
    "url" = COALESCE($5, "url"),
    "order" = COALESCE($6, "order")
WHERE "id" = $1
RETURNING id, mime_type, owner_id, owner_type, url, "order"
`

type UpdateResourceParams struct {
	ID        int64                  `json:"id"`
	MimeType  pgtype.Text            `json:"mime_type"`
	OwnerID   pgtype.Int8            `json:"owner_id"`
	OwnerType NullSharedResourceType `json:"owner_type"`
	Url       pgtype.Text            `json:"url"`
	Order     pgtype.Int4            `json:"order"`
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) (SharedResource, error) {
	row := q.db.QueryRow(ctx, updateResource,
		arg.ID,
		arg.MimeType,
		arg.OwnerID,
		arg.OwnerType,
		arg.Url,
		arg.Order,
	)
	var i SharedResource
	err := row.Scan(
		&i.ID,
		&i.MimeType,
		&i.OwnerID,
		&i.OwnerType,
		&i.Url,
		&i.Order,
	)
	return i, err
}

const updateSearchSync = `-- name: UpdateSearchSync :one
UPDATE "system"."search_sync"
SET "name" = COALESCE($2, "name"),
    "last_synced" = COALESCE($3, "last_synced")
WHERE "id" = $1
RETURNING id, name, last_synced
`

type UpdateSearchSyncParams struct {
	ID         int64              `json:"id"`
	Name       pgtype.Text        `json:"name"`
	LastSynced pgtype.Timestamptz `json:"last_synced"`
}

func (q *Queries) UpdateSearchSync(ctx context.Context, arg UpdateSearchSyncParams) (SystemSearchSync, error) {
	row := q.db.QueryRow(ctx, updateSearchSync, arg.ID, arg.Name, arg.LastSynced)
	var i SystemSearchSync
	err := row.Scan(&i.ID, &i.Name, &i.LastSynced)
	return i, err
}

const updateSkuSerial = `-- name: UpdateSkuSerial :one
UPDATE "inventory"."sku_serial"
SET "serial_number" = COALESCE($2, "serial_number"),
    "sku_id" = COALESCE($3, "sku_id"),
    "status" = COALESCE($4, "status"),
    "date_created" = COALESCE($5, "date_created")
WHERE "id" = $1
RETURNING id, serial_number, sku_id, status, date_created
`

type UpdateSkuSerialParams struct {
	ID           int64                      `json:"id"`
	SerialNumber pgtype.Text                `json:"serial_number"`
	SkuID        pgtype.Int8                `json:"sku_id"`
	Status       NullInventoryProductStatus `json:"status"`
	DateCreated  pgtype.Timestamptz         `json:"date_created"`
}

func (q *Queries) UpdateSkuSerial(ctx context.Context, arg UpdateSkuSerialParams) (InventorySkuSerial, error) {
	row := q.db.QueryRow(ctx, updateSkuSerial,
		arg.ID,
		arg.SerialNumber,
		arg.SkuID,
		arg.Status,
		arg.DateCreated,
	)
	var i InventorySkuSerial
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SkuID,
		&i.Status,
		&i.DateCreated,
	)
	return i, err
}

const updateStock = `-- name: UpdateStock :one
UPDATE "inventory"."stock"
SET "ref_type" = COALESCE($2, "ref_type"),
    "ref_id" = COALESCE($3, "ref_id"),
    "current_stock" = COALESCE($4, "current_stock"),
    "sold" = COALESCE($5, "sold"),
    "date_created" = COALESCE($6, "date_created")
WHERE "id" = $1
RETURNING id, ref_type, ref_id, current_stock, sold, date_created
`

type UpdateStockParams struct {
	ID           int64                  `json:"id"`
	RefType      NullInventoryStockType `json:"ref_type"`
	RefID        pgtype.Int8            `json:"ref_id"`
	CurrentStock pgtype.Int8            `json:"current_stock"`
	Sold         pgtype.Int8            `json:"sold"`
	DateCreated  pgtype.Timestamptz     `json:"date_created"`
}

func (q *Queries) UpdateStock(ctx context.Context, arg UpdateStockParams) (InventoryStock, error) {
	row := q.db.QueryRow(ctx, updateStock,
		arg.ID,
		arg.RefType,
		arg.RefID,
		arg.CurrentStock,
		arg.Sold,
		arg.DateCreated,
	)
	var i InventoryStock
	err := row.Scan(
		&i.ID,
		&i.RefType,
		&i.RefID,
		&i.CurrentStock,
		&i.Sold,
		&i.DateCreated,
	)
	return i, err
}

const updateStockHistory = `-- name: UpdateStockHistory :one
UPDATE "inventory"."stock_history"
SET "stock_id" = COALESCE($2, "stock_id"),
    "change" = COALESCE($3, "change"),
    "date_created" = COALESCE($4, "date_created")
WHERE "id" = $1
RETURNING id, stock_id, change, date_created
`

type UpdateStockHistoryParams struct {
	ID          int64              `json:"id"`
	StockID     pgtype.Int8        `json:"stock_id"`
	Change      pgtype.Int8        `json:"change"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
}

func (q *Queries) UpdateStockHistory(ctx context.Context, arg UpdateStockHistoryParams) (InventoryStockHistory, error) {
	row := q.db.QueryRow(ctx, updateStockHistory,
		arg.ID,
		arg.StockID,
		arg.Change,
		arg.DateCreated,
	)
	var i InventoryStockHistory
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.Change,
		&i.DateCreated,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE "catalog"."tag"
SET "tag" = COALESCE($2, "tag"),
    "description" = COALESCE($3, "description")
WHERE "id" = $1
RETURNING id, tag, description
`

type UpdateTagParams struct {
	ID          int64       `json:"id"`
	Tag         pgtype.Text `json:"tag"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (CatalogTag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.ID, arg.Tag, arg.Description)
	var i CatalogTag
	err := row.Scan(&i.ID, &i.Tag, &i.Description)
	return i, err
}

const updateVendor = `-- name: UpdateVendor :one
UPDATE "account"."vendor"
SET "account_id" = COALESCE($2, "account_id")
WHERE "id" = $1
RETURNING id, account_id
`

type UpdateVendorParams struct {
	ID        int64       `json:"id"`
	AccountID pgtype.Int8 `json:"account_id"`
}

func (q *Queries) UpdateVendor(ctx context.Context, arg UpdateVendorParams) (AccountVendor, error) {
	row := q.db.QueryRow(ctx, updateVendor, arg.ID, arg.AccountID)
	var i AccountVendor
	err := row.Scan(&i.ID, &i.AccountID)
	return i, err
}

const updateVnpay = `-- name: UpdateVnpay :one
UPDATE "payment"."vnpay"
SET "order_id" = COALESCE($2, "order_id"),
    "vnp_Amount" = COALESCE($3, "vnp_Amount"),
    "vnp_BankCode" = COALESCE($4, "vnp_BankCode"),
    "vnp_CardType" = COALESCE($5, "vnp_CardType"),
    "vnp_OrderInfo" = COALESCE($6, "vnp_OrderInfo"),
    "vnp_PayDate" = COALESCE($7, "vnp_PayDate"),
    "vnp_ResponseCode" = COALESCE($8, "vnp_ResponseCode"),
    "vnp_SecureHash" = COALESCE($9, "vnp_SecureHash"),
    "vnp_TmnCode" = COALESCE($10, "vnp_TmnCode"),
    "vnp_TransactionNo" = COALESCE($11, "vnp_TransactionNo"),
    "vnp_TransactionStatus" = COALESCE($12, "vnp_TransactionStatus"),
    "vnp_TxnRef" = COALESCE($13, "vnp_TxnRef")
WHERE "id" = $1
RETURNING id, order_id, "vnp_Amount", "vnp_BankCode", "vnp_CardType", "vnp_OrderInfo", "vnp_PayDate", "vnp_ResponseCode", "vnp_SecureHash", "vnp_TmnCode", "vnp_TransactionNo", "vnp_TransactionStatus", "vnp_TxnRef"
`

type UpdateVnpayParams struct {
	ID                   int64       `json:"id"`
	OrderID              pgtype.Int8 `json:"order_id"`
	VnpAmount            pgtype.Text `json:"vnp_Amount"`
	VnpBankCode          pgtype.Text `json:"vnp_BankCode"`
	VnpCardType          pgtype.Text `json:"vnp_CardType"`
	VnpOrderInfo         pgtype.Text `json:"vnp_OrderInfo"`
	VnpPayDate           pgtype.Text `json:"vnp_PayDate"`
	VnpResponseCode      pgtype.Text `json:"vnp_ResponseCode"`
	VnpSecureHash        pgtype.Text `json:"vnp_SecureHash"`
	VnpTmnCode           pgtype.Text `json:"vnp_TmnCode"`
	VnpTransactionNo     pgtype.Text `json:"vnp_TransactionNo"`
	VnpTransactionStatus pgtype.Text `json:"vnp_TransactionStatus"`
	VnpTxnRef            pgtype.Text `json:"vnp_TxnRef"`
}

func (q *Queries) UpdateVnpay(ctx context.Context, arg UpdateVnpayParams) (PaymentVnpay, error) {
	row := q.db.QueryRow(ctx, updateVnpay,
		arg.ID,
		arg.OrderID,
		arg.VnpAmount,
		arg.VnpBankCode,
		arg.VnpCardType,
		arg.VnpOrderInfo,
		arg.VnpPayDate,
		arg.VnpResponseCode,
		arg.VnpSecureHash,
		arg.VnpTmnCode,
		arg.VnpTransactionNo,
		arg.VnpTransactionStatus,
		arg.VnpTxnRef,
	)
	var i PaymentVnpay
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VnpAmount,
		&i.VnpBankCode,
		&i.VnpCardType,
		&i.VnpOrderInfo,
		&i.VnpPayDate,
		&i.VnpResponseCode,
		&i.VnpSecureHash,
		&i.VnpTmnCode,
		&i.VnpTransactionNo,
		&i.VnpTransactionStatus,
		&i.VnpTxnRef,
	)
	return i, err
}
