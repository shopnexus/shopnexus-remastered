// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(p.id)
FROM payment.base p
WHERE (
        (p.user_id = $1 OR $1 IS NULL) AND
        (p.method = $2 OR $2 IS NULL) AND
        (p.status = $3 OR $3 IS NULL) AND
        (p.address ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
        (p.total >= $5 OR $5 IS NULL) AND
        (p.total <= $6 OR $6 IS NULL) AND
        (p.date_created >= $7 OR $7 IS NULL) AND
        (p.date_created <= $8 OR $8 IS NULL)
        )
`

type CountPaymentsParams struct {
	UserID          pgtype.Int8              `json:"user_id"`
	Method          NullPaymentPaymentMethod `json:"method"`
	Status          NullPaymentStatus        `json:"status"`
	Address         pgtype.Text              `json:"address"`
	TotalFrom       pgtype.Int8              `json:"total_from"`
	TotalTo         pgtype.Int8              `json:"total_to"`
	DateCreatedFrom pgtype.Timestamptz       `json:"date_created_from"`
	DateCreatedTo   pgtype.Timestamptz       `json:"date_created_to"`
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.TotalFrom,
		arg.TotalTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payment.base (user_id,
                          method,
                          status,
                          address,
                          total)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, method, status, address, total, date_created
`

type CreatePaymentParams struct {
	UserID  int64                `json:"user_id"`
	Method  PaymentPaymentMethod `json:"method"`
	Status  PaymentStatus        `json:"status"`
	Address string               `json:"address"`
	Total   int64                `json:"total"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.Total,
	)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Method,
		&i.Status,
		&i.Address,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

type CreatePaymentProductSerialsParams struct {
	ProductOnPaymentID int64  `json:"product_on_payment_id"`
	ProductSerialID    string `json:"product_serial_id"`
}

type CreatePaymentProductsParams struct {
	PaymentID  int64 `json:"payment_id"`
	ProductID  int64 `json:"product_id"`
	Quantity   int64 `json:"quantity"`
	Price      int64 `json:"price"`
	TotalPrice int64 `json:"total_price"`
}

const createPaymentVnpay = `-- name: CreatePaymentVnpay :exec
INSERT INTO payment.vnpay (id,
                           "vnp_Amount",
                           "vnp_BankCode",
                           "vnp_CardType",
                           "vnp_OrderInfo",
                           "vnp_PayDate",
                           "vnp_ResponseCode",
                           "vnp_SecureHash",
                           "vnp_TmnCode",
                           "vnp_TransactionNo",
                           "vnp_TransactionStatus",
                           "vnp_TxnRef")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreatePaymentVnpayParams struct {
	ID                   int64  `json:"id"`
	VnpAmount            string `json:"vnp_Amount"`
	VnpBankCode          string `json:"vnp_BankCode"`
	VnpCardType          string `json:"vnp_CardType"`
	VnpOrderInfo         string `json:"vnp_OrderInfo"`
	VnpPayDate           string `json:"vnp_PayDate"`
	VnpResponseCode      string `json:"vnp_ResponseCode"`
	VnpSecureHash        string `json:"vnp_SecureHash"`
	VnpTmnCode           string `json:"vnp_TmnCode"`
	VnpTransactionNo     string `json:"vnp_TransactionNo"`
	VnpTransactionStatus string `json:"vnp_TransactionStatus"`
	VnpTxnRef            string `json:"vnp_TxnRef"`
}

func (q *Queries) CreatePaymentVnpay(ctx context.Context, arg CreatePaymentVnpayParams) error {
	_, err := q.db.Exec(ctx, createPaymentVnpay,
		arg.ID,
		arg.VnpAmount,
		arg.VnpBankCode,
		arg.VnpCardType,
		arg.VnpOrderInfo,
		arg.VnpPayDate,
		arg.VnpResponseCode,
		arg.VnpSecureHash,
		arg.VnpTmnCode,
		arg.VnpTransactionNo,
		arg.VnpTransactionStatus,
		arg.VnpTxnRef,
	)
	return err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE
FROM payment.base
WHERE (
        id = $1 AND
        (user_id = $2 OR $2 IS NULL)
        )
`

type DeletePaymentParams struct {
	ID     int64       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

func (q *Queries) DeletePayment(ctx context.Context, arg DeletePaymentParams) error {
	_, err := q.db.Exec(ctx, deletePayment, arg.ID, arg.UserID)
	return err
}

const existsPayment = `-- name: ExistsPayment :one
SELECT EXISTS (SELECT 1
               FROM payment.base p
               WHERE (
                       p.id = $1 AND
                       (p.user_id = $2 OR $2 IS NULL) AND
                       (p.status = $3 OR $3 IS NULL)
                       )) AS exists
`

type ExistsPaymentParams struct {
	ID     int64             `json:"id"`
	UserID pgtype.Int8       `json:"user_id"`
	Status NullPaymentStatus `json:"status"`
}

func (q *Queries) ExistsPayment(ctx context.Context, arg ExistsPaymentParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsPayment, arg.ID, arg.UserID, arg.Status)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getPayment = `-- name: GetPayment :one
SELECT p.id, p.user_id, p.method, p.status, p.address, p.total, p.date_created
FROM payment.base p
WHERE (
        p.id = $1 AND
        (p.user_id = $2 OR $2 IS NULL)
        )
`

type GetPaymentParams struct {
	ID     int64       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

func (q *Queries) GetPayment(ctx context.Context, arg GetPaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, getPayment, arg.ID, arg.UserID)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Method,
		&i.Status,
		&i.Address,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

const getPaymentProductSerials = `-- name: GetPaymentProductSerials :many
SELECT ps.serial_id, ps.product_id, ps.is_sold, ps.is_active, ps.date_created
FROM payment.product_serial_on_product_on_payment psopop
       INNER JOIN product.serial ps ON ps.serial_id = psopop.product_serial_id
WHERE psopop.product_on_payment_id = $1
`

func (q *Queries) GetPaymentProductSerials(ctx context.Context, productOnPaymentID int64) ([]ProductSerial, error) {
	rows, err := q.db.Query(ctx, getPaymentProductSerials, productOnPaymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductSerial{}
	for rows.Next() {
		var i ProductSerial
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductID,
			&i.IsSold,
			&i.IsActive,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentProducts = `-- name: GetPaymentProducts :many
SELECT pop.id, pop.payment_id, pop.product_id, pop.quantity, pop.price, pop.total_price
FROM payment.product_on_payment pop
WHERE pop.payment_id = $1
`

func (q *Queries) GetPaymentProducts(ctx context.Context, paymentID int64) ([]PaymentProductOnPayment, error) {
	rows, err := q.db.Query(ctx, getPaymentProducts, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentProductOnPayment{}
	for rows.Next() {
		var i PaymentProductOnPayment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT p.id, p.user_id, p.method, p.status, p.address, p.total, p.date_created
FROM payment.base p
WHERE (
        (p.user_id = $1 OR $1 IS NULL) AND
        (p.method = $2 OR $2 IS NULL) AND
        (p.status = $3 OR $3 IS NULL) AND
        (p.address ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
        (p.total >= $5 OR $5 IS NULL) AND
        (p.total <= $6 OR $6 IS NULL) AND
        (p.date_created >= $7 OR $7 IS NULL) AND
        (p.date_created <= $8 OR $8 IS NULL)
        )
ORDER BY p.date_created DESC LIMIT $10
OFFSET $9
`

type ListPaymentsParams struct {
	UserID          pgtype.Int8              `json:"user_id"`
	Method          NullPaymentPaymentMethod `json:"method"`
	Status          NullPaymentStatus        `json:"status"`
	Address         pgtype.Text              `json:"address"`
	TotalFrom       pgtype.Int8              `json:"total_from"`
	TotalTo         pgtype.Int8              `json:"total_to"`
	DateCreatedFrom pgtype.Timestamptz       `json:"date_created_from"`
	DateCreatedTo   pgtype.Timestamptz       `json:"date_created_to"`
	Offset          int32                    `json:"offset"`
	Limit           int32                    `json:"limit"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]PaymentBase, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.TotalFrom,
		arg.TotalTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentBase{}
	for rows.Next() {
		var i PaymentBase
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Method,
			&i.Status,
			&i.Address,
			&i.Total,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :exec
UPDATE payment.base
SET method  = COALESCE($2, method),
    status  = COALESCE($3, status),
    address = COALESCE($4, address),
    total   = COALESCE($5, total)
WHERE (
        id = $1 AND
        (user_id = $6 OR $6 IS NULL)
        )
`

type UpdatePaymentParams struct {
	ID      int64                    `json:"id"`
	Method  NullPaymentPaymentMethod `json:"method"`
	Status  NullPaymentStatus        `json:"status"`
	Address pgtype.Text              `json:"address"`
	Total   pgtype.Int8              `json:"total"`
	UserID  pgtype.Int8              `json:"user_id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) error {
	_, err := q.db.Exec(ctx, updatePayment,
		arg.ID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.Total,
		arg.UserID,
	)
	return err
}

const updatePaymentVnpay = `-- name: UpdatePaymentVnpay :exec
UPDATE payment.vnpay
SET "vnp_Amount"            = COALESCE($2, "vnp_Amount"),
    "vnp_BankCode"          = COALESCE($3, "vnp_BankCode"),
    "vnp_CardType"          = COALESCE($4, "vnp_CardType"),
    "vnp_OrderInfo"         = COALESCE($5, "vnp_OrderInfo"),
    "vnp_PayDate"           = COALESCE($6, "vnp_PayDate"),
    "vnp_ResponseCode"      = COALESCE($7, "vnp_ResponseCode"),
    "vnp_SecureHash"        = COALESCE($8, "vnp_SecureHash"),
    "vnp_TmnCode"           = COALESCE($9, "vnp_TmnCode"),
    "vnp_TransactionNo"     = COALESCE($10, "vnp_TransactionNo"),
    "vnp_TransactionStatus" = COALESCE($11, "vnp_TransactionStatus"),
    "vnp_TxnRef"            = COALESCE($12, "vnp_TxnRef")
WHERE id = $1
`

type UpdatePaymentVnpayParams struct {
	ID                   int64       `json:"id"`
	VnpAmount            pgtype.Text `json:"vnp_Amount"`
	VnpBankCode          pgtype.Text `json:"vnp_BankCode"`
	VnpCardType          pgtype.Text `json:"vnp_CardType"`
	VnpOrderInfo         pgtype.Text `json:"vnp_OrderInfo"`
	VnpPayDate           pgtype.Text `json:"vnp_PayDate"`
	VnpResponseCode      pgtype.Text `json:"vnp_ResponseCode"`
	VnpSecureHash        pgtype.Text `json:"vnp_SecureHash"`
	VnpTmnCode           pgtype.Text `json:"vnp_TmnCode"`
	VnpTransactionNo     pgtype.Text `json:"vnp_TransactionNo"`
	VnpTransactionStatus pgtype.Text `json:"vnp_TransactionStatus"`
	VnpTxnRef            pgtype.Text `json:"vnp_TxnRef"`
}

func (q *Queries) UpdatePaymentVnpay(ctx context.Context, arg UpdatePaymentVnpayParams) error {
	_, err := q.db.Exec(ctx, updatePaymentVnpay,
		arg.ID,
		arg.VnpAmount,
		arg.VnpBankCode,
		arg.VnpCardType,
		arg.VnpOrderInfo,
		arg.VnpPayDate,
		arg.VnpResponseCode,
		arg.VnpSecureHash,
		arg.VnpTmnCode,
		arg.VnpTransactionNo,
		arg.VnpTransactionStatus,
		arg.VnpTxnRef,
	)
	return err
}
