// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: refund.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const canRefund = `-- name: CanRefund :one
SELECT EXISTS (SELECT 1
               FROM payment.product_on_payment pop
                        INNER JOIN payment.base p ON pop.payment_id = p.id
                        LEFT JOIN payment.refund r ON pop.id = r.product_on_payment_id
               WHERE (
                         pop.id = $1 AND
                         p.status = 'SUCCESS' AND -- Refund only available for successful payment
                         (r.id IS NULL OR r.status = 'FAILED' OR r.status = 'CANCELED') AND -- Refund must not exist or is failed/canceled (not pending/success)
                         (p.user_id = $2 OR $2 IS NULL) -- Refund must belong to the user
                         )) AS can_refund
`

type CanRefundParams struct {
	ID     int64       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

func (q *Queries) CanRefund(ctx context.Context, arg CanRefundParams) (bool, error) {
	row := q.db.QueryRow(ctx, canRefund, arg.ID, arg.UserID)
	var can_refund bool
	err := row.Scan(&can_refund)
	return can_refund, err
}

const countRefunds = `-- name: CountRefunds :one
SELECT COUNT(r.id)
FROM payment.refund r
         INNER JOIN payment.product_on_payment pop ON r.product_on_payment_id = pop.id
         INNER JOIN payment.base p ON pop.payment_id = p.id
WHERE (
          (p.user_id = $1 OR $1 IS NULL) AND
          (r.product_on_payment_id = $2 OR
           $2 IS NULL) AND
          (r.method = $3 OR $3 IS NULL) AND
          (r.status = $4 OR $4 IS NULL) AND
          (r.reason ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
          (r.address ILIKE '%' || $6 || '%' OR $6 IS NULL) AND
          (r.amount >= $7 OR $7 IS NULL) AND
          (r.amount <= $8 OR $8 IS NULL) AND
          (r.date_created >= $9 OR $9 IS NULL) AND
          (r.date_created <= $10 OR $10 IS NULL)
          )
`

type CountRefundsParams struct {
	UserID             pgtype.Int8             `json:"user_id"`
	ProductOnPaymentID pgtype.Int8             `json:"product_on_payment_id"`
	Method             NullPaymentRefundMethod `json:"method"`
	Status             NullPaymentStatus       `json:"status"`
	Reason             pgtype.Text             `json:"reason"`
	Address            pgtype.Text             `json:"address"`
	AmountFrom         pgtype.Int8             `json:"amount_from"`
	AmountTo           pgtype.Int8             `json:"amount_to"`
	DateCreatedFrom    pgtype.Timestamptz      `json:"date_created_from"`
	DateCreatedTo      pgtype.Timestamptz      `json:"date_created_to"`
}

func (q *Queries) CountRefunds(ctx context.Context, arg CountRefundsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefunds,
		arg.UserID,
		arg.ProductOnPaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.AmountFrom,
		arg.AmountTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO payment.refund (product_on_payment_id,
                            method,
                            status,
                            reason,
                            address,
                            approved_by_id,
                            amount)
VALUES ($1, $2, $3, $4, $5, $7, $6) RETURNING id, product_on_payment_id, method, status, reason, address, amount, approved_by_id, date_created
`

type CreateRefundParams struct {
	ProductOnPaymentID int64               `json:"product_on_payment_id"`
	Method             PaymentRefundMethod `json:"method"`
	Status             PaymentStatus       `json:"status"`
	Reason             string              `json:"reason"`
	Address            string              `json:"address"`
	Amount             int64               `json:"amount"`
	ApprovedByID       pgtype.Int8         `json:"approved_by_id"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (PaymentRefund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.ProductOnPaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.Amount,
		arg.ApprovedByID,
	)
	var i PaymentRefund
	err := row.Scan(
		&i.ID,
		&i.ProductOnPaymentID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.Amount,
		&i.ApprovedByID,
		&i.DateCreated,
	)
	return i, err
}

const deleteRefund = `-- name: DeleteRefund :exec
DELETE
FROM payment.refund r
WHERE r.id = $1
  AND EXISTS ( -- Check if the refund belongs to the user
    SELECT 1
    FROM payment.product_on_payment pop
             JOIN payment.base p ON pop.payment_id = p.id
    WHERE r.product_on_payment_id = pop.id
      AND (p.user_id = $2 OR $2 IS NULL))
`

type DeleteRefundParams struct {
	ID     int64       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

func (q *Queries) DeleteRefund(ctx context.Context, arg DeleteRefundParams) error {
	_, err := q.db.Exec(ctx, deleteRefund, arg.ID, arg.UserID)
	return err
}

const existsRefund = `-- name: ExistsRefund :one
SELECT EXISTS (SELECT 1
               FROM payment.refund r
                        INNER JOIN payment.product_on_payment pop ON r.product_on_payment_id = pop.id
                        INNER JOIN payment.base p ON pop.payment_id = p.id
               WHERE (
                         (r.product_on_payment_id = $1) AND
                         (r.status = 'PENDING' OR r.status = 'SUCCESS') AND
                         (p.user_id = $2)
                         )) AS exists
`

type ExistsRefundParams struct {
	ProductOnPaymentID int64 `json:"product_on_payment_id"`
	UserID             int64 `json:"user_id"`
}

func (q *Queries) ExistsRefund(ctx context.Context, arg ExistsRefundParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsRefund, arg.ProductOnPaymentID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getRefund = `-- name: GetRefund :one
WITH filtered_refund AS (SELECT r.id, r.product_on_payment_id, r.method, r.status, r.reason, r.address, r.amount, r.approved_by_id, r.date_created
                         FROM payment.refund r
                                  INNER JOIN payment.product_on_payment pop ON r.product_on_payment_id = pop.id
                                  INNER JOIN payment.base p ON pop.payment_id = p.id
                         WHERE (
                                   r.id = $1 AND
                                   (p.user_id = $2 OR $2 IS NULL)
                                   )),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id = $1
                              AND res.type = 'REFUND'
                            GROUP BY res.owner_id)
SELECT r.id, r.product_on_payment_id, r.method, r.status, r.reason, r.address, r.amount, r.approved_by_id, r.date_created,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_refund r
         LEFT JOIN filtered_resources res ON res.owner_id = r.id
`

type GetRefundParams struct {
	ID     int64       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

type GetRefundRow struct {
	ID                 int64               `json:"id"`
	ProductOnPaymentID int64               `json:"product_on_payment_id"`
	Method             PaymentRefundMethod `json:"method"`
	Status             PaymentStatus       `json:"status"`
	Reason             string              `json:"reason"`
	Address            string              `json:"address"`
	Amount             int64               `json:"amount"`
	ApprovedByID       pgtype.Int8         `json:"approved_by_id"`
	DateCreated        pgtype.Timestamptz  `json:"date_created"`
	Resources          []string            `json:"resources"`
}

func (q *Queries) GetRefund(ctx context.Context, arg GetRefundParams) (GetRefundRow, error) {
	row := q.db.QueryRow(ctx, getRefund, arg.ID, arg.UserID)
	var i GetRefundRow
	err := row.Scan(
		&i.ID,
		&i.ProductOnPaymentID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.Amount,
		&i.ApprovedByID,
		&i.DateCreated,
		&i.Resources,
	)
	return i, err
}

const listRefunds = `-- name: ListRefunds :many
WITH filtered_refund AS (SELECT r.id, r.product_on_payment_id, r.method, r.status, r.reason, r.address, r.amount, r.approved_by_id, r.date_created
                         FROM payment.refund r
                                  INNER JOIN payment.product_on_payment pop ON r.product_on_payment_id = pop.id
                                  INNER JOIN payment.base p ON pop.payment_id = p.id
                         WHERE (
                                   (p.user_id = $3 OR $3 IS NULL) AND
                                   (r.product_on_payment_id = $4 OR
                                    $4 IS NULL) AND
                                   (r.method = $5 OR $5 IS NULL) AND
                                   (r.status = $6 OR $6 IS NULL) AND
                                   (r.reason ILIKE '%' || $7 || '%' OR $7 IS NULL) AND
                                   (r.address ILIKE '%' || $8 || '%' OR $8 IS NULL) AND
                                   (r.amount >= $9 OR $9 IS NULL) AND
                                   (r.amount <= $10 OR $10 IS NULL) AND
                                   (r.date_created >= $11 OR
                                    $11 IS NULL) AND
                                   (r.date_created <= $12 OR
                                    $12 IS NULL)
                                   )),
     filtered_resources AS (SELECT res.owner_id,
                                   array_agg(res.url ORDER BY res.order ASC) AS resources
                            FROM product.resource res
                            WHERE res.owner_id IN (SELECT id FROM filtered_refund)
                              AND res.type = 'REFUND'
                            GROUP BY res.owner_id)
SELECT r.id, r.product_on_payment_id, r.method, r.status, r.reason, r.address, r.amount, r.approved_by_id, r.date_created,
       COALESCE(res.resources, '{}') ::text[] AS resources
FROM filtered_refund r
         LEFT JOIN filtered_resources res ON res.owner_id = r.id
ORDER BY r.date_created DESC LIMIT $2
OFFSET $1
`

type ListRefundsParams struct {
	Offset             int32                   `json:"offset"`
	Limit              int32                   `json:"limit"`
	UserID             pgtype.Int8             `json:"user_id"`
	ProductOnPaymentID pgtype.Int8             `json:"product_on_payment_id"`
	Method             NullPaymentRefundMethod `json:"method"`
	Status             NullPaymentStatus       `json:"status"`
	Reason             pgtype.Text             `json:"reason"`
	Address            pgtype.Text             `json:"address"`
	AmountFrom         pgtype.Int8             `json:"amount_from"`
	AmountTo           pgtype.Int8             `json:"amount_to"`
	DateCreatedFrom    pgtype.Timestamptz      `json:"date_created_from"`
	DateCreatedTo      pgtype.Timestamptz      `json:"date_created_to"`
}

type ListRefundsRow struct {
	ID                 int64               `json:"id"`
	ProductOnPaymentID int64               `json:"product_on_payment_id"`
	Method             PaymentRefundMethod `json:"method"`
	Status             PaymentStatus       `json:"status"`
	Reason             string              `json:"reason"`
	Address            string              `json:"address"`
	Amount             int64               `json:"amount"`
	ApprovedByID       pgtype.Int8         `json:"approved_by_id"`
	DateCreated        pgtype.Timestamptz  `json:"date_created"`
	Resources          []string            `json:"resources"`
}

func (q *Queries) ListRefunds(ctx context.Context, arg ListRefundsParams) ([]ListRefundsRow, error) {
	rows, err := q.db.Query(ctx, listRefunds,
		arg.Offset,
		arg.Limit,
		arg.UserID,
		arg.ProductOnPaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.AmountFrom,
		arg.AmountTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRefundsRow{}
	for rows.Next() {
		var i ListRefundsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductOnPaymentID,
			&i.Method,
			&i.Status,
			&i.Reason,
			&i.Address,
			&i.Amount,
			&i.ApprovedByID,
			&i.DateCreated,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefund = `-- name: UpdateRefund :exec
UPDATE payment.refund r
SET method      = COALESCE($2, method),
    status      = COALESCE($3, status),
    reason      = COALESCE($4, reason),
    address     = COALESCE($5, address),
    amount      = COALESCE($6, amount),
    approved_by_id = COALESCE($7, approved_by_id) FROM payment.refund
INNER JOIN payment.product_on_payment pop
ON r.product_on_payment_id = pop.id
    INNER JOIN payment.base p ON pop.payment_id = p.id
WHERE (
    r.id = $1
    )
`

type UpdateRefundParams struct {
	ID           int64                   `json:"id"`
	Method       NullPaymentRefundMethod `json:"method"`
	Status       NullPaymentStatus       `json:"status"`
	Reason       pgtype.Text             `json:"reason"`
	Address      pgtype.Text             `json:"address"`
	Amount       pgtype.Int8             `json:"amount"`
	ApprovedByID pgtype.Int8             `json:"approved_by_id"`
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) error {
	_, err := q.db.Exec(ctx, updateRefund,
		arg.ID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.Amount,
		arg.ApprovedByID,
	)
	return err
}
