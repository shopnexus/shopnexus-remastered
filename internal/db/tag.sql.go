// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tag.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTags = `-- name: AddTags :exec
INSERT INTO product.tag_on_product_model (product_model_id, tag)
SELECT $1,
       unnest($2::text[]) ON CONFLICT DO NOTHING
`

type AddTagsParams struct {
	ProductModelID int64    `json:"product_model_id"`
	Tags           []string `json:"tags"`
}

func (q *Queries) AddTags(ctx context.Context, arg AddTagsParams) error {
	_, err := q.db.Exec(ctx, addTags, arg.ProductModelID, arg.Tags)
	return err
}

const countProductModelsOnTag = `-- name: CountProductModelsOnTag :one
SELECT COUNT(product_model_id)
FROM product.tag_on_product_model
WHERE tag = $1
`

func (q *Queries) CountProductModelsOnTag(ctx context.Context, tag string) (int64, error) {
	row := q.db.QueryRow(ctx, countProductModelsOnTag, tag)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*)
FROM product.tag
WHERE ($1::text IS NULL OR tag ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR description ILIKE '%' || $2 || '%')
`

type CountTagsParams struct {
	Tag         pgtype.Text `json:"tag"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CountTags(ctx context.Context, arg CountTagsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTags, arg.Tag, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO product.tag (tag,
                         description)
VALUES ($1, $2)
`

type CreateTagParams struct {
	Tag         string `json:"tag"`
	Description string `json:"description"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.db.Exec(ctx, createTag, arg.Tag, arg.Description)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE
FROM product.tag
WHERE tag = $1
`

func (q *Queries) DeleteTag(ctx context.Context, tag string) error {
	_, err := q.db.Exec(ctx, deleteTag, tag)
	return err
}

const getTag = `-- name: GetTag :one
SELECT id, tag, description
FROM product.tag
WHERE tag = $1
`

func (q *Queries) GetTag(ctx context.Context, tag string) (ProductTag, error) {
	row := q.db.QueryRow(ctx, getTag, tag)
	var i ProductTag
	err := row.Scan(&i.ID, &i.Tag, &i.Description)
	return i, err
}

const getTags = `-- name: GetTags :many
SELECT tag
FROM product.tag_on_product_model
WHERE product_model_id = $1
`

func (q *Queries) GetTags(ctx context.Context, productModelID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getTags, productModelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, tag, description
FROM product.tag
WHERE ($1::text IS NULL OR tag ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR description ILIKE '%' || $2 || '%')
ORDER BY tag LIMIT $4
OFFSET $3
`

type ListTagsParams struct {
	Tag         pgtype.Text `json:"tag"`
	Description pgtype.Text `json:"description"`
	Offset      int32       `json:"offset"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]ProductTag, error) {
	rows, err := q.db.Query(ctx, listTags,
		arg.Tag,
		arg.Description,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductTag{}
	for rows.Next() {
		var i ProductTag
		if err := rows.Scan(&i.ID, &i.Tag, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTags = `-- name: RemoveTags :exec
DELETE
FROM product.tag_on_product_model
WHERE product_model_id = $1
  AND tag = ANY ($2::text[])
`

type RemoveTagsParams struct {
	ProductModelID int64    `json:"product_model_id"`
	Tags           []string `json:"tags"`
}

func (q *Queries) RemoveTags(ctx context.Context, arg RemoveTagsParams) error {
	_, err := q.db.Exec(ctx, removeTags, arg.ProductModelID, arg.Tags)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE product.tag
SET tag         = COALESCE($2, tag),
    description = COALESCE($3, description)
WHERE tag = $1
`

type UpdateTagParams struct {
	Tag         string      `json:"tag"`
	NewTag      pgtype.Text `json:"new_tag"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.db.Exec(ctx, updateTag, arg.Tag, arg.NewTag, arg.Description)
	return err
}
